using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;
using Terraria;
using Terraria.ModLoader;
using TranslateTest2.Core;
using TranslateTest2.Config;

namespace TranslateTest2
{
	public class TranslateTest2 : Mod
	{
		public static TranslateTest2 Instance { get; private set; }
		
		public override void Load()
		{
			try
			{
				Instance = this;
				
				TooltipTranslator.Load(this);
				var cfg = ModContent.GetInstance<ClientConfig>();
				DeepLTranslator.ApplyConfig(cfg);

				// Hook registration with error handling
				On_Projectile.GetWhipSettings += hook_get_whip_settings;
				On_Projectile.AI += hook_projectile_ai;
				
				Logger?.Info("TranslateTest2 loaded successfully");
			}
			catch (Exception ex)
			{
				Logger?.Error($"Error loading TranslateTest2: {ex}");
				throw;
			}
		}

		public override void Unload()
		{
			try
			{
				TooltipTranslator.Unload();
				DeepLTranslator.Unload();
				
				// 安全なフック解除
				try { On_Projectile.GetWhipSettings -= hook_get_whip_settings; } catch { }
				try { On_Projectile.AI -= hook_projectile_ai; } catch { }
				
				Logger?.Info("TranslateTest2 unloaded successfully");
			}
			catch (Exception ex)
			{
				Logger?.Warn($"Error during unload: {ex.Message}");
			}
			finally
			{
				Instance = null;
			}
		}

		// 最適化されたプロジェクタイルAIフック
		private void hook_projectile_ai(On_Projectile.orig_AI orig, Projectile self)
		{
			try
			{
				// 基本的な null チェックと状態確認
				if (self?.active != true)
				{
					orig?.Invoke(self);
					return;
				}

				if (self.minion || self.sentry)
				{
					var globalProjectile = self.GetGlobalProjectile<SPGlobalProj>();
					if (globalProjectile?.MinionUpdateSpeed > 0f)
					{
						globalProjectile.UpdateCounter += globalProjectile.MinionUpdateSpeed;
						int iterations = 0;
						const int maxIterations = 10; // 無限ループ防止

						while (globalProjectile.UpdateCounter >= 1.0 && iterations < maxIterations)
						{
							iterations++;
							globalProjectile.UpdateCounter -= 1.0f;
							orig?.Invoke(self);

							// HandleMovement 呼び出しの最適化
							if (globalProjectile.UpdateCounter >= 1.0 && iterations < maxIterations)
							{
								try
								{
									var method = typeof(Projectile).GetMethod("HandleMovement", 
										BindingFlags.NonPublic | BindingFlags.Instance);
									if (method != null)
									{
										method.Invoke(self, new object[] { self.velocity, null, null });
									}
								}
								catch { /* HandleMovement エラーは無視 */ }
							}
						}
					}
					else
					{
						orig?.Invoke(self);
					}
				}
				else
				{
					orig?.Invoke(self);
				}
			}
			catch (Exception ex)
			{
				Logger?.Warn($"Error in hook_projectile_ai: {ex.GetType().Name}: {ex.Message}");
				// フォールバック処理
				try
				{
					orig?.Invoke(self);
				}
				catch { /* 最終的な安全策 */ }
			}
		}

		// 最適化されたウィップ設定フック
		private void hook_get_whip_settings(
			On_Projectile.orig_GetWhipSettings orig,
			Projectile proj,
			out float timeToFlyOut,
			out int segments,
			out float rangeMultiplier)
		{
			// デフォルト値で初期化
			timeToFlyOut = 0f;
			segments = 0;
			rangeMultiplier = 1f;

			try
			{
				// 元の処理を安全に呼び出し
				orig?.Invoke(proj, out timeToFlyOut, out segments, out rangeMultiplier);
				
				// プロジェクタイルの基本チェック
				if (proj?.active != true || !proj.friendly)
					return;

				// プレイヤーオーナーの安全なチェック
				if (IsValidPlayerIndex(proj.owner))
				{
					var player = GetSafePlayer(proj.owner);
					if (player?.active == true && player.HeldItem?.IsAir == false)
					{
						try
						{
							var globalItem = player.HeldItem.global();
							if (globalItem != null && globalItem.WhipRangeMult != 1f)
							{
								rangeMultiplier *= globalItem.WhipRangeMult;
							}
						}
						catch (Exception ex)
						{
							Logger?.Debug($"Error accessing global item: {ex.Message}");
						}
					}
				}
			}
			catch (Exception ex)
			{
				Logger?.Warn($"Error in hook_get_whip_settings: {ex.GetType().Name}: {ex.Message}");
				// エラー時はデフォルト値を保持
			}
		}

		// プレイヤーインデックスの安全な検証
		private static bool IsValidPlayerIndex(int playerIndex)
		{
			return playerIndex >= 0 && 
				   playerIndex < Main.maxPlayers && 
				   playerIndex != 255 &&
				   Main.player != null &&
				   Main.player.Length > playerIndex;
		}

		// プレイヤーの安全な取得
		private static Player GetSafePlayer(int playerIndex)
		{
			try
			{
				if (IsValidPlayerIndex(playerIndex))
				{
					return Main.player[playerIndex];
				}
			}
			catch (IndexOutOfRangeException)
			{
				TranslateTest2.Instance?.Logger?.Debug($"Player index out of range: {playerIndex}");
			}
			catch (Exception ex)
			{
				TranslateTest2.Instance?.Logger?.Debug($"Error getting player {playerIndex}: {ex.Message}");
			}
			return null;
		}

		// モジュール状態の診断用
		public override void PostSetupContent()
		{
			try
			{
				Logger?.Info($"PostSetupContent: Translator loaded={TooltipTranslator.IsLoaded}, DeepL enabled={DeepLTranslator.IsEnabled}");
			}
			catch (Exception ex)
			{
				Logger?.Warn($"PostSetupContent error: {ex.Message}");
			}
		}
	}
}
