using Microsoft.Xna.Framework;
using System;
using System.IO;
using Terraria;
using Terraria.DataStructures;
using Terraria.ID;
using Terraria.ModLoader;
using Terraria.ModLoader.IO;

namespace TranslateTest2
{
    public class SPGlobalProj : GlobalProjectile
    {
        public float MultedMinionSlot = 1f;
        public float UpdateCounter;
        public float MinionUpdateSpeed = 1f;
        public bool deviation;
        public bool echo;
        public bool blessing;
        public float LifeSteal;
        public bool contract;
        public float MinionCrit;
        public bool electrified;
        
        // 新しいPrefix効果
        public bool vengeful;
        public bool affable;
        public int mega;
        public bool brisk;
        public bool steady;
        public bool loyal;
        public bool oracle;
        
        public static bool EchoDoubleProj = true;

        public override bool InstancePerEntity => true;

        public override void SendExtraAI(
            Projectile projectile,
            BitWriter bitWriter,
            BinaryWriter binaryWriter)
        {
            binaryWriter.Write(blessing);
            binaryWriter.Write(MinionUpdateSpeed);
            binaryWriter.Write(vengeful);
            binaryWriter.Write(affable);
            binaryWriter.Write(mega);
            binaryWriter.Write(steady);
            binaryWriter.Write(loyal);
            binaryWriter.Write(oracle);
        }

        public override void ReceiveExtraAI(
            Projectile projectile,
            BitReader bitReader,
            BinaryReader binaryReader)
        {
            blessing = binaryReader.ReadBoolean();
            MinionUpdateSpeed = binaryReader.ReadSingle();
            vengeful = binaryReader.ReadBoolean();
            affable = binaryReader.ReadBoolean();
            mega = binaryReader.ReadInt32();
            steady = binaryReader.ReadBoolean();
            loyal = binaryReader.ReadBoolean();
            oracle = binaryReader.ReadBoolean();
        }

        public override void OnSpawn(Projectile projectile, IEntitySource source)
        {
            if (source is EntitySource_ItemUse entitySourceItemUse && (projectile.minion || projectile.sentry) && entitySourceItemUse.Item.isMinionSummonItem())
            {
                var globalItem = entitySourceItemUse.Item.global();
                
                // 基本効果
                projectile.minionSlots *= globalItem.MinionSlotMult;
                MultedMinionSlot = projectile.minionSlots;
                MinionUpdateSpeed = globalItem.MinionUpdateSpeed; // 修正: MinionSpeedMult -> MinionUpdateSpeed
                projectile.scale *= globalItem.MinionScaleMult;
                projectile.knockBack *= globalItem.MinionKnockbackMult;
                LifeSteal = globalItem.MinionLifeSteal;
                MinionCrit = globalItem.MinionCritAdd;
                
                // 既存Prefix効果
                deviation = entitySourceItemUse.Item.prefix == ModContent.PrefixType<Prefixes.Deviation>();
                echo = entitySourceItemUse.Item.prefix == ModContent.PrefixType<Prefixes.Echo>();
                blessing = entitySourceItemUse.Item.prefix == ModContent.PrefixType<Prefixes.Blessing>();
                contract = entitySourceItemUse.Item.prefix == ModContent.PrefixType<Prefixes.Contract>();
                electrified = globalItem.electrified;
                
                // 新しいPrefix効果
                vengeful = globalItem.vengeful;
                affable = globalItem.affable;
                mega = globalItem.mega;
                brisk = entitySourceItemUse.Item.prefix == ModContent.PrefixType<Prefixes.Brisk>();
                steady = globalItem.steady;
                loyal = globalItem.loyal;
                oracle = globalItem.oracle;
                
                // Brisk効果: プロジェクタイルの更新速度上昇
                if (brisk)
                {
                    MinionUpdateSpeed *= (1f + Prefixes.Brisk.SpeedIncrease);
                }
                
                projectile.netUpdate = true;
            }
            
            if (!(source is EntitySource_Parent entitySourceParent))
                return;
                
            if (entitySourceParent.Entity is Projectile entity1)
                LifeSteal = entity1.GetGlobalProjectile<SPGlobalProj>().LifeSteal;
                
            if (entitySourceParent.Entity is Projectile entity2 && (entity2.minion || entity2.sentry))
            {
                var parentGlobal = entity2.GetGlobalProjectile<SPGlobalProj>();
                
                if (parentGlobal.deviation)
                    projectile.velocity = Utils.RotateRandom(projectile.velocity, 0.30000001192092896);
                    
                if (parentGlobal.echo && EchoDoubleProj && Utils.NextFloat(Main.rand) < Prefixes.Echo.DoubleChance)
                {
                    EchoDoubleProj = false;
                    Projectile.NewProjectile(source, projectile.position, Utils.RotatedByRandom(projectile.velocity, 0.059999998658895493), projectile.type, projectile.damage / 4, projectile.knockBack, projectile.owner, projectile.ai[0], projectile.ai[1], projectile.ai[2]);
                    EchoDoubleProj = true;
                }
            }
            projectile.netUpdate = true;
        }

        public override void ModifyHitNPC(Projectile projectile, NPC target, ref NPC.HitModifiers modifiers)
        {
            try
            {
                // Vengeful効果: 失った体力に基づくダメージボーナス
                if (vengeful && projectile.TryGetOwner(out Player owner))
                {
                    float healthPercent = (float)owner.statLife / owner.statLifeMax;
                    float missingHealthPercent = 1f - healthPercent;
                    float damageMultiplier = 1f + (missingHealthPercent * Prefixes.Vengeful.DamageBonusPercentPerMissingHealth);
                    modifiers.SourceDamage *= damageMultiplier;
                }

                // Electrified効果: 追加ダメージ
                if (electrified && projectile.TryGetOwner(out Player player))
                {
                    int bonusDamage = (int)(player.statLifeMax * Prefixes.Electrified.DmgMultByPlayerMaxHealth);
                    modifiers.FlatBonusDamage += bonusDamage;
                }

                // Oracle効果: 魔法ダメージタイプのプロジェクタイルにボーナス
                if (oracle && projectile.DamageType == DamageClass.Magic)
                {
                    modifiers.SourceDamage *= (1f + Prefixes.Oracle.MagicDamageIncrease);
                }

                // Loyal効果: ターゲット検出範囲拡大（AI段階で処理）
                if (loyal && projectile.minion)
                {
                    // この効果はPreAIで処理される
                }
            }
            catch (System.Exception ex)
            {
                TranslateTest2.Instance?.Logger?.Debug($"Error in ModifyHitNPC: {ex.Message}");
            }
        }

        public override void OnHitNPC(Projectile projectile, NPC target, NPC.HitInfo hit, int damageDone)
        {
            Player player1;
            if (ProjectileID.Sets.IsAWhip[projectile.type] && projectile.TryGetOwner(out player1) && player1.HeldItem.global().wTag != null && player1.HeldItem.global().CanGiveTag)
                target.AddTag(player1.HeldItem.global().wTag.Clone());
                
            // LifeSteal効果
            Player player2;
            if (LifeSteal > 0.0 && projectile.TryGetOwner(out player2) && player2.GetModPlayer<SPModPlayer>().HealMe((int)Math.Ceiling(player2.statLifeMax2 * LifeSteal), 5))
            {
                for (float num = 0.0f; num <= 1.0; num += 0.005f)
                {
                    Dust dust = Dust.NewDustDirect(Vector2.Lerp(player2.Center, target.Center, num), 1, 1, DustID.SomethingRed, 0.0f, 0.0f, 0, new Color(), 1f);
                    dust.velocity = Vector2.Add(Vector2.Multiply(Utils.ToRotationVector2(Utils.NextFloat(Main.rand) * 6.28318548f), Utils.NextFloat(Main.rand, -1f, 1f)), Vector2.Multiply(Utils.SafeNormalize(Vector2.Subtract(player2.Center, target.Center), Vector2.Zero), 3.6f));
                    dust.scale = 0.8f;
                    dust.position = Vector2.Lerp(player2.Center, target.Center, num);
                }
            }

            // Affable効果: 攻撃時に体力回復
            if (affable && projectile.TryGetOwner(out Player affableOwner))
            {
                int healAmount = (int)(Prefixes.Affable.RegenIncrease * 0.1f); // 攻撃時の回復量
                if (healAmount > 0)
                {
                    affableOwner.GetModPlayer<SPModPlayer>().HealMe(healAmount, 1);
                }
            }
        }

        public override bool PreAI(Projectile projectile)
        {
            // Electrified効果: 定期的な電撃レーザー生成
            Player player;
            if (electrified && Main.GameUpdateCount % 12U == 0U && projectile.TryGetOwner(out player))
                Projectile.NewProjectile(projectile.GetSource_FromThis(), projectile.Center, Vector2.Zero, ModContent.ProjectileType<Projectiles.ElectricLaser>(), (int)(player.statLifeMax2 * Prefixes.Electrified.DmgMultByPlayerMaxHealth), 0.0f, player.whoAmI, player.Center.X, player.Center.Y, 0.0f);

            // Loyal効果: ターゲット検出範囲拡大
            if (loyal && projectile.minion && projectile.TryGetOwner(out Player loyalOwner))
            {
                // ミニオンの検出範囲を拡大する処理
                // 実装はMinion AIのカスタマイズが必要だが、基本的な効果として距離ボーナスを適用
                float detectionRange = 16f * 32f * Prefixes.Loyal.TargetingRange; // タイルサイズ換算
                // この効果は個別のMinion AIで実装される必要がある
            }

            return true;
        }
    }
}