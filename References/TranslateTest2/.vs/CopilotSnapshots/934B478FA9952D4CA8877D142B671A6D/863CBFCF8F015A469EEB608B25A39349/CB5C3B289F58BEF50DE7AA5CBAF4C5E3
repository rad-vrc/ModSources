using Microsoft.Xna.Framework;
using System;
using System.IO;
using Terraria;
using Terraria.DataStructures;
using Terraria.ID;
using Terraria.ModLoader;
using Terraria.ModLoader.IO;

namespace TranslateTest2
{
    public class SPGlobalProj : GlobalProjectile
    {
        public float MultedMinionSlot = 1f;
        public float UpdateCounter;
        public float MinionUpdateSpeed = 1f;
        public bool deviation;
        public bool echo;
        public bool blessing;
        public float LifeSteal;
        public bool contract;
        public float MinionCrit;
        public bool electrified;
        
        public static bool EchoDoubleProj = true;

        public override bool InstancePerEntity => true;

        public override void SendExtraAI(
            Projectile projectile,
            BitWriter bitWriter,
            BinaryWriter binaryWriter)
        {
            binaryWriter.Write(blessing);
            binaryWriter.Write(MinionUpdateSpeed);
            binaryWriter.Write(electrified);
        }

        public override void ReceiveExtraAI(
            Projectile projectile,
            BitReader bitReader,
            BinaryReader binaryReader)
        {
            blessing = binaryReader.ReadBoolean();
            MinionUpdateSpeed = binaryReader.ReadSingle();
            electrified = binaryReader.ReadBoolean();
        }

        public override void OnSpawn(Projectile projectile, IEntitySource source)
        {
            try
            {
                if (source is EntitySource_ItemUse entitySourceItemUse && (projectile.minion || projectile.sentry) && entitySourceItemUse.Item.isMinionSummonItem())
                {
                    var globalItem = entitySourceItemUse.Item.global();
                    var item = entitySourceItemUse.Item;
                    
                    // 基本効果の安全な適用
                    if (globalItem != null)
                    {
                        projectile.minionSlots = Math.Max(0f, projectile.minionSlots * globalItem.MinionSlotMult);
                        MultedMinionSlot = projectile.minionSlots;
                        MinionUpdateSpeed = Math.Max(0.1f, globalItem.MinionUpdateSpeed);
                        projectile.scale = Math.Max(0.1f, projectile.scale * globalItem.MinionScaleMult);
                        projectile.knockBack = Math.Max(0f, projectile.knockBack * globalItem.MinionKnockbackMult);
                        LifeSteal = Math.Max(0f, globalItem.MinionLifeSteal);
                        MinionCrit = Math.Max(0f, globalItem.MinionCritAdd);
                        
                        // Prefix判定による効果設定
                        int prefixType = item.prefix;
                        
                        deviation = prefixType == ModContent.PrefixType<Prefixes.Deviation>();
                        echo = prefixType == ModContent.PrefixType<Prefixes.Echo>();
                        blessing = prefixType == ModContent.PrefixType<Prefixes.Blessing>();
                        contract = prefixType == ModContent.PrefixType<Prefixes.Contract>();
                        electrified = globalItem.electrified;
                        
                        // Brisk効果: プロジェクタイルの更新速度上昇
                        if (brisk)
                        {
                            MinionUpdateSpeed = Math.Max(0.1f, MinionUpdateSpeed * (1f + Prefixes.Brisk.SpeedIncrease));
                        }
                    }
                    
                    projectile.netUpdate = true;
                }
                
                if (source is EntitySource_Parent entitySourceParent)
                {
                    if (entitySourceParent.Entity is Projectile entity1)
                    {
                        var parentGlobal = entity1.GetGlobalProjectile<SPGlobalProj>();
                        LifeSteal = Math.Max(0f, parentGlobal?.LifeSteal ?? 0f);
                    }
                        
                    if (entitySourceParent.Entity is Projectile entity2 && (entity2.minion || entity2.sentry))
                    {
                        var parentGlobal = entity2.GetGlobalProjectile<SPGlobalProj>();
                        if (parentGlobal != null)
                        {
                            if (parentGlobal.deviation)
                                projectile.velocity = Utils.RotateRandom(projectile.velocity, 0.30000001192092896);
                                
                            if (parentGlobal.echo && EchoDoubleProj && Utils.NextFloat(Main.rand) < Prefixes.Echo.DoubleChance)
                            {
                                EchoDoubleProj = false;
                                try
                                {
                                    Projectile.NewProjectile(source, projectile.position, Utils.RotatedByRandom(projectile.velocity, 0.059999998658895493), 
                                        projectile.type, Math.Max(1, projectile.damage / 4), projectile.knockBack, projectile.owner, 
                                        projectile.ai[0], projectile.ai[1], projectile.ai[2]);
                                }
                                catch (System.Exception ex)
                                {
                                    TranslateTest2.Instance?.Logger?.Debug($"Echo projectile creation error: {ex.Message}");
                                }
                                EchoDoubleProj = true;
                            }
                        }
                    }
                }
                projectile.netUpdate = true;
            }
            catch (System.Exception ex)
            {
                TranslateTest2.Instance?.Logger?.Debug($"Error in OnSpawn: {ex.Message}");
            }
        }

        public override void ModifyHitNPC(Projectile projectile, NPC target, ref NPC.HitModifiers modifiers)
        {
            try
            {
                // Electrified効果: 体力割合ダメージ
                if (electrified && projectile.TryGetOwner(out Player electrifiedPlayer))
                {
                    int bonusDamage = (int)(electrifiedPlayer.statLifeMax * Prefixes.Electrified.DmgMultByPlayerMaxHealth);
                    modifiers.FlatBonusDamage += bonusDamage;
                }
            }
            catch (System.Exception ex)
            {
                TranslateTest2.Instance?.Logger?.Debug($"Error in ModifyHitNPC: {ex.Message}");
            }
        }

        public override void OnHitNPC(Projectile projectile, NPC target, NPC.HitInfo hit, int damageDone)
        {
            // Whipタグ処理
            if (ProjectileID.Sets.IsAWhip[projectile.type] && projectile.TryGetOwner(out Player whipPlayer) && whipPlayer.HeldItem.global().wTag != null && whipPlayer.HeldItem.global().CanGiveTag)
                target.AddTag(whipPlayer.HeldItem.global().wTag.Clone());
                
            // LifeSteal効果
            if (LifeSteal > 0.0 && projectile.TryGetOwner(out Player lifeStealPlayer) && lifeStealPlayer.GetModPlayer<SPModPlayer>().HealMe((int)Math.Ceiling(lifeStealPlayer.statLifeMax2 * LifeSteal), 5))
            {
                for (float num = 0.0f; num <= 1.0; num += 0.005f)
                {
                    Dust dust = Dust.NewDustDirect(Vector2.Lerp(lifeStealPlayer.Center, target.Center, num), 1, 1, DustID.SomethingRed, 0.0f, 0.0f, 0, new Color(), 1f);
                    dust.velocity = Vector2.Add(Vector2.Multiply(Utils.ToRotationVector2(Utils.NextFloat(Main.rand) * 6.28318548f), Utils.NextFloat(Main.rand, -1f, 1f)), Vector2.Multiply(Utils.SafeNormalize(Vector2.Subtract(lifeStealPlayer.Center, target.Center), Vector2.Zero), 3.6f));
                    dust.scale = 0.8f;
                    dust.position = Vector2.Lerp(lifeStealPlayer.Center, target.Center, num);
                }
            }
        }

        public override bool PreAI(Projectile projectile)
        {
            // Electrified効果: 定期的な電撃レーザー生成
            if (electrified && Main.GameUpdateCount % 12U == 0U && projectile.TryGetOwner(out Player electrifiedPlayer))
            {
                int laserDamage = (int)(electrifiedPlayer.statLifeMax2 * Prefixes.Electrified.DmgMultByPlayerMaxHealth);
                Projectile.NewProjectile(projectile.GetSource_FromThis(), projectile.Center, Vector2.Zero, ModContent.ProjectileType<Projectiles.ElectricLaser>(), laserDamage, 0.0f, electrifiedPlayer.whoAmI, electrifiedPlayer.Center.X, electrifiedPlayer.Center.Y, 0.0f);
            }

            return true;
        }
    }
}