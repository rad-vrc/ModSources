using Microsoft.Xna.Framework;
using System;
using System.Collections.Generic;
using Terraria;
using Terraria.ID;
using Terraria.ModLoader;

namespace TranslateTest2
{
    public class SPModPlayer : ModPlayer
    {
        public int HealingCd;
        
        // パフォーマンス最適化用フラグ
        private bool _hasFocusedWhip = false;
        private int _checkCooldown = 0;

        public bool HealMe(int amount, int Cooldown)
        {
            if (HealingCd > 0 || Player?.active != true)
                return false;
                
            HealingCd = Cooldown;
            Player.Heal(amount);
            return true;
        }

        public override void PostUpdateMiscEffects()
        {
            if (Player?.active != true) return;

            // ヒーリングクールダウンの更新
            if (HealingCd > 0)
                HealingCd--;

            // 定期的なアイテムチェック（パフォーマンス最適化）
            if (++_checkCooldown >= 10) // 10フレームに1回チェック
            {
                _checkCooldown = 0;
                _hasFocusedWhip = Player.HeldItem?.IsAir == false && 
                                Player.HeldItem.prefix == ModContent.PrefixType<Prefixes.Focused_Whip>();
            }

            // Focused_Whip prefix効果の適用
            if (_hasFocusedWhip)
            {
                try
                {
                    Player.GetDamage(DamageClass.Summon) += Prefixes.Focused_Whip.SummonDmgAddition;
                    Player.maxMinions -= Prefixes.Focused_Whip.MinionSlotDecrease;
                }
                catch (Exception ex)
                {
                    TranslateTest2.Instance?.Logger?.Debug($"Error in Focused_Whip effect: {ex.Message}");
                }
            }

            // プロジェクタイル処理の最適化
            ProcessActiveProjectiles();
            
            // 新しいPrefix効果の適用
            ApplyItemBasedPrefixEffects();
        }

        // アイテムベースのPrefix効果
        private void ApplyItemBasedPrefixEffects()
        {
            if (Player?.HeldItem?.IsAir != false) return;

            var globalItem = Player.HeldItem.global();
            if (globalItem == null) return;

            try
            {
                // Vengeful: 失った体力に基づくダメージボーナス（プレイヤーレベル）
                if (globalItem.vengeful)
                {
                    float healthPercent = (float)Player.statLife / Player.statLifeMax;
                    float missingHealthPercent = 1f - healthPercent;
                    float damageBonus = missingHealthPercent * Prefixes.Vengeful.DamageBonusPercentPerMissingHealth;
                    Player.GetDamage(DamageClass.Summon) += damageBonus;
                }

                // Affable: 体力再生増加（プレイヤー効果）
                if (globalItem.affable)
                {
                    Player.lifeRegen += (int)Prefixes.Affable.RegenIncrease;
                }

                // Mega: 追加ミニオンスロット
                if (globalItem.mega > 0)
                {
                    Player.maxMinions += globalItem.mega;
                }

                // Steady: 防御力増加とノックバック耐性
                if (globalItem.steady)
                {
                    Player player = Player;
                    player.statDefense += (int)Prefixes.Steady.DefenseIncrease;
                    Player.noKnockback = true; // 完全ノックバック無効
                }

                // Oracle: 魔法ダメージとマナ再生
                if (globalItem.oracle)
                {
                    Player.GetDamage(DamageClass.Magic) += Prefixes.Oracle.MagicDamageIncrease;
                    Player.manaRegen += (int)Prefixes.Oracle.ManaRegenIncrease;
                }

                // Brisk効果はプロジェクタイル生成時にSPGlobalProjで処理される

                // Loyal効果もプロジェクタイルレベルで処理される
            }
            catch (Exception ex)
            {
                TranslateTest2.Instance?.Logger?.Debug($"Error in item-based prefix effects: {ex.Message}");
            }
        }

        // プロジェクタイル処理を分離して最適化（正しいIterator使用版）
        private void ProcessActiveProjectiles()
        {
            float blessingBonus = 0.0f;
            var contractDefenseReduction = 0;
            var projectilesProcessed = new HashSet<int>(); // HashSetで高速化、IDで管理

            try
            {
                // Main.ActiveProjectilesの安全な反復処理
                foreach (Projectile projectile in Main.ActiveProjectiles)
                {
                    try
                    {
                        if (projectile?.active != true || projectile.owner != Player.whoAmI)
                            continue;

                        // 重複処理防止（プロジェクタイルIDを使用）
                        if (!projectilesProcessed.Add(projectile.whoAmI))
                            continue;

                        var globalProj = projectile.GetGlobalProjectile<SPGlobalProj>();
                        if (globalProj == null) continue;

                        // Contract prefix効果 - 防御力減少を蓄積
                        if ((projectile.minion || projectile.sentry) && globalProj.contract)
                        {
                            contractDefenseReduction += Prefixes.Contract.ArmorDecrease;
                        }

                        // Blessing prefix効果
                        if (globalProj.blessing && projectile.Distance(Player.Center) < Prefixes.Blessing.range)
                        {
                            blessingBonus += Prefixes.Blessing.Bonus;
                            CreateBlessingDustEffect(projectile);
                        }
                    }
                    catch (System.Exception ex)
                    {
                        TranslateTest2.Instance?.Logger?.Debug($"Error processing individual projectile: {ex.Message}");
                        continue; // 個別の問題は継続
                    }
                }

                // Contract効果の適用 - 正しい防御力修正
                if (contractDefenseReduction > 0)
                {
                    Player player = Player;
                    player.statDefense -= contractDefenseReduction;
                }
            }
            catch (System.Exception ex)
            {
                TranslateTest2.Instance?.Logger?.Debug($"Error processing projectiles: {ex.Message}");
            }

            // Blessing効果の適用
            ApplyBlessingEffects(blessingBonus);
        }

        // Dustエフェクト生成の最適化
        private void CreateBlessingDustEffect(Projectile projectile)
        {
            try
            {
                // フレーム制限でパフォーマンス向上
                if (Main.GameUpdateCount % 3 != 0) return; // 3フレームに1回

                // Dust生成数を削減
                for (float num2 = 0.0f; num2 <= 1.0; num2 += 0.05f) // 0.01f -> 0.05f
                {
                    var position = Vector2.Lerp(Player.Center, projectile.Center, num2);
                    var dust = Dust.NewDustDirect(position, 1, 1, DustID.OrangeStainedGlass, 
                        0.0f, 0.0f, 0, new Color(), 0.8f);
                    
                    if (dust != null)
                    {
                        dust.velocity = Vector2.Zero;
                        dust.noGravity = true;
                        dust.scale = 0.4f;
                    }
                }
            }
            catch (Exception ex)
            {
                TranslateTest2.Instance?.Logger?.Debug($"Error creating blessing dust: {ex.Message}");
            }
        }

        // Blessing効果の適用
        private void ApplyBlessingEffects(float blessingBonus)
        {
            if (blessingBonus <= 0.0f) return;

            try
            {
                int defenseBonus = (int)Math.Ceiling(blessingBonus * 3.0);
                int regenBonus = (int)Math.Ceiling(blessingBonus * 5.0);
                float damageBonus = blessingBonus * 0.02f;

                // 元コードの方式を維持しつつ最適化
                Player player1 = Player;
                player1.statDefense += Math.Min(defenseBonus, 100); // 最大100防御力
                Player.lifeRegen += Math.Min(regenBonus, 50); // 最大50再生
                Player.GetDamage(DamageClass.Generic) += Math.Min(damageBonus, 2.0f); // 最大200%
            }
            catch (Exception ex)
            {
                TranslateTest2.Instance?.Logger?.Debug($"Error applying blessing effects: {ex.Message}");
            }
        }

        // プレイヤーリセット時にフラグもリセット
        public override void OnEnterWorld()
        {
            _hasFocusedWhip = false;
            _checkCooldown = 0;
            HealingCd = 0;
        }

        public override void OnRespawn()
        {
            _hasFocusedWhip = false;
            _checkCooldown = 0;
            HealingCd = 0;
        }
    }
}