===== FILE: D:\TranslateTest2\PrefixGlobalItem.cs =====
using Terraria;
using Terraria.ModLoader;
using System.IO;

namespace TranslateTest2
{
    public class PrefixGlobalItem : GlobalItem
    {
        public float WhipRangeMult = 1f;
        public WhipTag wTag;
        public bool CanGiveTag;
        public float MinionSlotMult = 1f;
        public float MinionSpeedMult = 1f;
        public float MinionScaleMult = 1f;
        public float MinionKnockbackMult = 1f;
        public float MinionLifeSteal;
        public float MinionCritAdd;
        public bool electrified;

        public override bool InstancePerEntity => true;

        public override void NetSend(Item item, BinaryWriter writer) => writer.Write(WhipRangeMult);

        public override void NetReceive(Item item, BinaryReader reader) => WhipRangeMult = reader.ReadSingle();

        public override void SetDefaults(Item entity)
        {
            CanGiveTag = false;
            wTag = null;
            if (entity.shoot > Terraria.ID.ProjectileID.None && Terraria.ID.ProjectileID.Sets.IsAWhip[entity.shoot])
                wTag = new WhipTag(entity.Name, 0);
            WhipRangeMult = 1f;
        }
    }
}


===== FILE: D:\TranslateTest2\SPGlobalProj.cs =====
using Microsoft.Xna.Framework;
using System;
using System.IO;
using Terraria;
using Terraria.DataStructures;
using Terraria.ID;
using Terraria.ModLoader;
using Terraria.ModLoader.IO;

namespace TranslateTest2
{
    public class SPGlobalProj : GlobalProjectile
    {
        public float MultedMinionSlot = 1f;
        public float UpdateCounter;
        public float MinionUpdateSpeed = 1f;
        public bool deviation;
        public bool echo;
        public bool blessing;
        public float LifeSteal;
        public bool contract;
        public float MinionCrit;
        public bool electrified;
        
        public static bool EchoDoubleProj = true;

        public override bool InstancePerEntity => true;

        public override void SendExtraAI(
            Projectile projectile,
            BitWriter bitWriter,
            BinaryWriter binaryWriter)
        {
            binaryWriter.Write(blessing);
            binaryWriter.Write(MinionUpdateSpeed);
        }

        public override void ReceiveExtraAI(
            Projectile projectile,
            BitReader bitReader,
            BinaryReader binaryReader)
        {
            blessing = binaryReader.ReadBoolean();
            MinionUpdateSpeed = binaryReader.ReadSingle();
        }

        public override void OnSpawn(Projectile projectile, IEntitySource source)
        {
            if (source is EntitySource_ItemUse itemUse && (projectile.minion || projectile.sentry) && itemUse.Item.isMinionSummonItem())
            {
                projectile.minionSlots *= itemUse.Item.global().MinionSlotMult;
                MultedMinionSlot = projectile.minionSlots;
                MinionUpdateSpeed = itemUse.Item.global().MinionSpeedMult;
                projectile.scale *= itemUse.Item.global().MinionScaleMult;
                projectile.knockBack *= itemUse.Item.global().MinionKnockbackMult;
                LifeSteal = itemUse.Item.global().MinionLifeSteal;
                MinionCrit = itemUse.Item.global().MinionCritAdd;
                deviation = itemUse.Item.prefix == ModContent.PrefixType<Prefixes.Deviation>();
                echo = itemUse.Item.prefix == ModContent.PrefixType<Prefixes.Echo>();
                blessing = itemUse.Item.prefix == ModContent.PrefixType<Prefixes.Blessing>();
                contract = itemUse.Item.prefix == ModContent.PrefixType<Prefixes.Contract>();
                projectile.netUpdate = true;
                electrified = itemUse.Item.global().electrified;
            }
            if (source is EntitySource_Parent parent)
            {
                if (parent.Entity is Projectile p1)
                    LifeSteal = p1.GetGlobalProjectile<SPGlobalProj>().LifeSteal;
                if (parent.Entity is Projectile p2 && (p2.minion || p2.sentry))
                {
                    var pg = p2.GetGlobalProjectile<SPGlobalProj>();
                    if (pg.deviation)
                        projectile.velocity = projectile.velocity.RotatedByRandom(0.3);
                    if (pg.echo && EchoDoubleProj && Utils.NextFloat(Main.rand) < Prefixes.Echo.DoubleChance)
                    {
                        EchoDoubleProj = false;
                        Projectile.NewProjectile(source, projectile.position, projectile.velocity.RotatedByRandom(0.06), projectile.type, projectile.damage / 4, projectile.knockBack, projectile.owner, projectile.ai[0], projectile.ai[1], projectile.ai[2]);
                        EchoDoubleProj = true;
                    }
                }
                projectile.netUpdate = true;
            }
        }

    // 原典では Electrified の追加平坦ダメージ修正は存在しないため削除

        public override void OnHitNPC(Projectile projectile, NPC target, NPC.HitInfo hit, int damageDone)
        {
            // Whipタグ処理
            if (ProjectileID.Sets.IsAWhip[projectile.type] && projectile.TryGetOwner(out Player whipPlayer) && whipPlayer.HeldItem.global().wTag != null && whipPlayer.HeldItem.global().CanGiveTag)
                target.AddTag(whipPlayer.HeldItem.global().wTag.Clone());
                
            // LifeSteal効果
            if (LifeSteal > 0f && projectile.TryGetOwner(out Player lifeStealPlayer) && lifeStealPlayer.GetModPlayer<SPModPlayer>().HealMe((int)Math.Ceiling(lifeStealPlayer.statLifeMax2 * LifeSteal), 5))
            {
                if (!Main.dedServ)
                {
                    for (float num = 0f; num <= 1f; num += 0.005f)
                    {
                        Dust dust = Dust.NewDustDirect(Vector2.Lerp(lifeStealPlayer.Center, target.Center, num), 1, 1, DustID.SomethingRed, 0f, 0f, 0, new Color(), 1f);
                        dust.velocity = Utils.ToRotationVector2(Utils.NextFloat(Main.rand) * MathHelper.TwoPi) * Utils.NextFloat(Main.rand, -1f, 1f) + Utils.SafeNormalize(lifeStealPlayer.Center - target.Center, Vector2.Zero) * 3.6f;
                        dust.scale = 0.8f;
                        dust.position = Vector2.Lerp(lifeStealPlayer.Center, target.Center, num);
                    }
                }
            }
        }

        public override bool PreAI(Projectile projectile)
        {
            // Electrified効果: 定期的な電撃レーザー生成
            if (electrified && Main.GameUpdateCount % 12U == 0U && projectile.TryGetOwner(out Player electrifiedPlayer))
            {
                int laserDamage = (int)(electrifiedPlayer.statLifeMax2 * Prefixes.Electrified.DmgMultByPlayerMaxHealth);
                Projectile.NewProjectile(projectile.GetSource_FromThis(), projectile.Center, Vector2.Zero, ModContent.ProjectileType<Projectiles.ElectricLaser>(), laserDamage, 0.0f, electrifiedPlayer.whoAmI, electrifiedPlayer.Center.X, electrifiedPlayer.Center.Y, 0.0f);
            }

            return true;
        }
    }
}


===== FILE: D:\TranslateTest2\SPModPlayer.cs =====
using Microsoft.Xna.Framework;
using System;
using System.Collections.Generic;
using Terraria;
using Terraria.ID;
using Terraria.ModLoader;

namespace TranslateTest2
{
    public class SPModPlayer : ModPlayer
    {
        public int HealingCd;

        public bool HealMe(int amount, int Cooldown)
        {
            if (HealingCd > 0) return false;
            HealingCd = Cooldown;
            Player.Heal(amount);
            return true;
        }

        public override void PostUpdateMiscEffects()
        {
            HealingCd--;
            float blessingBonus = 0f;
            if (!Player.HeldItem.IsAir && Player.HeldItem.prefix == ModContent.PrefixType<Prefixes.Focused_Whip>())
            {
                Player.GetDamage(DamageClass.Summon) += Prefixes.Focused_Whip.SummonDmgAddition;
                Player.maxMinions -= Prefixes.Focused_Whip.MinionSlotDecrease;
            }
            foreach (var proj in Main.ActiveProjectiles)
            {
                if ((proj.minion || proj.sentry) && proj.owner == Player.whoAmI && proj.GetGlobalProjectile<SPGlobalProj>().contract)
                    Player.statDefense -= Prefixes.Contract.ArmorDecrease;
                if (proj.GetGlobalProjectile<SPGlobalProj>().blessing && proj.Distance(Player.Center) < Prefixes.Blessing.range)
                {
                    blessingBonus += Prefixes.Blessing.Bonus;
                    for (float num2 = 0f; num2 <= 1f; num2 += 0.01f)
                    {
                        Dust dust = Dust.NewDustDirect(Vector2.Lerp(Player.Center, proj.Center, num2), 1, 1, DustID.TerraBlade, 0f, 0f, 0, new Color(), 1f);
                        dust.velocity = Vector2.Zero;
                        dust.noGravity = true;
                        dust.scale = 0.4f;
                        dust.position = Vector2.Lerp(Player.Center, proj.Center, num2);
                    }
                }
            }
            if (blessingBonus > 0f)
            {
                Player.statDefense += (int)Math.Ceiling(blessingBonus * 3f);
                Player.lifeRegen += (int)Math.Ceiling(blessingBonus * 5f);
                Player.GetDamage(DamageClass.Generic) += blessingBonus * 0.02f;
            }
        }
    }
}


===== FILE: D:\TranslateTest2\SummonerPrefixUtils.cs =====
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using System;
using System.Collections.Generic;
using System.Linq;
using Terraria;
using Terraria.ID;
using Terraria.ModLoader;

namespace TranslateTest2
{
    public static class SummonerPrefixUtils
    {
        public static float getDistance(Vector2 v1, Vector2 v2)
        {
            // XNA の最適化済み実装を利用して割り当てと double 演算を回避
            return Vector2.Distance(v1, v2);
        }

        public static void UseBlendState(this SpriteBatch sb, BlendState blend, SamplerState s = null)
        {
            sb.End();
            sb.Begin((SpriteSortMode)1, blend, s == null ? Main.DefaultSamplerState : s, DepthStencilState.None, Main.Rasterizer, (Effect)null, Main.GameViewMatrix.ZoomMatrix);
        }

        public static bool LineThroughRect(
            Vector2 start,
            Vector2 end,
            Rectangle rect,
            int lineWidth = 4,
            int checkDistance = 8)
        {
            float num = 0.0f;
            return Collision.CheckAABBvLineCollision(TopLeft(rect), Size(rect), start, end, (float)lineWidth, ref num);
        }

        private static Vector2 TopLeft(Rectangle rect) => new Vector2(rect.X, rect.Y);
        private static Vector2 Size(Rectangle rect) => new Vector2(rect.Width, rect.Height);

        public static PrefixGlobalItem global(this Item item)
        {
            // 原典仕様: 既存インスタンスが無い場合は新規インスタンスを生成して返す（tMLにアタッチしない一時オブジェクト）
            PrefixGlobalItem existing;
            return item.TryGetGlobalItem<PrefixGlobalItem>(out existing) ? item.GetGlobalItem<PrefixGlobalItem>() : new PrefixGlobalItem();
        }

        public static void AddTag(this NPC npc, WhipTag tag)
        {
            WhipTagGNPC globalNpc = npc.GetGlobalNPC<WhipTagGNPC>();
            foreach (WhipTag tag1 in globalNpc.tags)
            {
                if (tag1.ID == tag.ID)
                {
                    tag1.TimeLeft = tag.TimeLeft;
                    tag1.TagDamage = tag.TagDamage;
                    tag1.TagDamageMult = tag.TagDamageMult;
                    tag1.CritAdd = tag.CritAdd;
                    return;
                }
            }
            globalNpc.tags.Add(tag);
        }

        public static bool isMinionSummonItem(this Item item, bool sentry = true)
        {
            if (item.shoot != ProjectileID.None)
            {
                Projectile projectile1 = new Projectile();
                projectile1.SetDefaults(item.shoot);
                if (projectile1.minion || (projectile1.sentry && sentry))
                {
                    return true;
                }
            }
            return false;
        }

        public static void Replace(this List<TooltipLine> tooltips, string targetStr, string to)
        {
            if (Main.dedServ)
                return;
            tooltips.FindAndReplace(targetStr, to);
        }

        public static void Replace(this List<TooltipLine> tooltips, string targetStr, int to)
        {
            if (Main.dedServ)
                return;
            tooltips.FindAndReplace(targetStr, to.ToString());
        }

        public static void Replace(this List<TooltipLine> tooltips, string targetStr, float to)
        {
            if (Main.dedServ)
                return;
            tooltips.FindAndReplace(targetStr, to.ToString());
        }

        public static int ToPercent(this float f) => (int)Math.Round((double)f * 100.0);

        public static void Replace(this TooltipLine tl, string targetStr, string to)
        {
            tl.Text = tl.Text.Replace(targetStr, to);
        }

        public static void FindAndReplace(
            this List<TooltipLine> tooltips,
            string replacedKey,
            string newKey)
        {
            TooltipLine tooltipLine = tooltips.FirstOrDefault<TooltipLine>((Func<TooltipLine, bool>)(x => x.Mod == "Terraria" && x.Text.Contains(replacedKey)));
            if (tooltipLine == null)
                return;
            tooltipLine.Text = tooltipLine.Text.Replace(replacedKey, newKey);
        }
    }
}


===== FILE: D:\TranslateTest2\TranslateTest2.cs =====
using InventoryDrag;
using InventoryDrag.Config;
using InventoryDrag.Compatability;
using System.Reflection;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Terraria;
using Terraria.Localization;
using Terraria.ModLoader;
using Terraria.UI; // needed for ItemSlot & On_ItemSlot hooks
using MonoMod.RuntimeDetour; // for MonoModHooks
using MonoMod.RuntimeDetour.HookGen; // ensure hookgen symbols
using TranslateTest2.Core;
using TranslateTest2.Config;

namespace TranslateTest2
{
	using System.Reflection;
	public class TranslateTest2 : Mod
	{
		public static TranslateTest2 Instance { get; private set; }
		public static MethodInfo ItemLoader_CanRightClick = typeof(ItemLoader).GetMethod("CanRightClick", BindingFlags.Public|BindingFlags.NonPublic|BindingFlags.Static);
		public static MethodInfo PlayerLoader_ShiftClickSlot = typeof(PlayerLoader).GetMethod("ShiftClickSlot", BindingFlags.Public|BindingFlags.NonPublic|BindingFlags.Static);
		// InventoryDrag original delegate signatures for MonoModHooks
		private delegate bool orig_ItemLoader_CanRightClick(Item item);
		private delegate bool orig_PlayerLoader_ShiftClickSlot(Player player, Item[] inventory, int context, int slot);
		
		public override void Load()
		{
			try
			{
				Instance = this;
				
				TooltipTranslator.Load(this);
				var cfg = ModContent.GetInstance<ClientConfig>();
				DeepLTranslator.ApplyConfig(cfg);

				// Hook registration with additional safety checks and failure recovery
				bool whipHookSuccess = false;
				bool aiHookSuccess = false;

				try
				{
					On_Projectile.GetWhipSettings += hook_get_whip_settings;
					whipHookSuccess = true;
					Logger?.Info("WhipSettings hook registered successfully");
				}
				catch (Exception ex)
				{
					Logger?.Error($"Failed to register WhipSettings hook: {ex.Message}");
				}

				try
				{
					On_Projectile.AI += hook_projectile_ai;
					aiHookSuccess = true;
					Logger?.Info("Projectile AI hook registered successfully");
				}
				catch (Exception ex)
				{
					Logger?.Error($"Failed to register Projectile AI hook: {ex.Message}");
				}

				// 診断情報を出力
				Logger?.Info($"Hook registration status: WhipSettings={whipHookSuccess}, ProjectileAI={aiHookSuccess}");
				
				if (!whipHookSuccess && !aiHookSuccess)
				{
					Logger?.Warn("Critical: No hooks were registered successfully. Some features may not work.");
				}
				
				Logger?.Info("TranslateTest2 loaded successfully");
			}
			catch (Exception ex)
			{
				Logger?.Error($"Critical error loading TranslateTest2: {ex}");
				// クリティカルエラーでも完全に失敗させない
				try
				{
					Instance = this; // 最低限のインスタンス設定は維持
				}
				catch { }
			}
			
			// InventoryDrag integration begin
			try
			{
				On_ItemSlot.MouseHover_ItemArray_int_int += Hook_ItemSlot_MouseHover;
				On_ItemSlot.RightClick_ItemArray_int_int += Hook_ItemSlot_RightClick;
				On_ItemSlot.Handle_refItem_int += Hook_ItemSlot_Handle;
				On_ItemSlot.LeftClick_ItemArray_int_int += Hook_ItemSlot_LeftClick;
				On_Main.DrawInventory += Hook_Main_DrawInventory;
				// MonoModHooks.Add with (origDelegate, args...) signature to mirror original mod implementation exactly
				MonoModHooks.Add(ItemLoader_CanRightClick, (orig_ItemLoader_CanRightClick orig, Item item) => On_ItemLoader_CanRightClick_Item(orig, item));
				MonoModHooks.Add(PlayerLoader_ShiftClickSlot, (orig_PlayerLoader_ShiftClickSlot orig, Player pl, Item[] inv, int ctx, int sl) => On_PlayerLoader_ShiftClickSlot(orig, pl, inv, ctx, sl));
				AndroLib.Load(this);
			}
			catch (System.Exception ex)
			{
				Logger?.Error($"InventoryDrag integration failed: {ex.Message}");
			}
			// InventoryDrag integration end
		}

		public override void Unload()
		{
			try
			{
				TooltipTranslator.Unload();
				DeepLTranslator.Unload();
				
				// 安全なフック解除
				try { On_Projectile.GetWhipSettings -= hook_get_whip_settings; } catch { }
				try { On_Projectile.AI -= hook_projectile_ai; } catch { }
				
				// InventoryDrag integration unload begin
				try
				{
					On_ItemSlot.MouseHover_ItemArray_int_int -= Hook_ItemSlot_MouseHover;
					On_ItemSlot.RightClick_ItemArray_int_int -= Hook_ItemSlot_RightClick;
					On_ItemSlot.Handle_refItem_int -= Hook_ItemSlot_Handle;
					On_ItemSlot.LeftClick_ItemArray_int_int -= Hook_ItemSlot_LeftClick;
					On_Main.DrawInventory -= Hook_Main_DrawInventory;
					AndroLib.Unload(this);
				}
				catch { }
				// InventoryDrag integration unload end
				
				Logger?.Info("TranslateTest2 unloaded successfully");
			}
			catch (Exception ex)
			{
				Logger?.Warn($"Error during unload: {ex.Message}");
			}
			finally
			{
				Instance = null;
			}
		}

		private static readonly MethodInfo HandleMovementMI = typeof(Projectile).GetMethod("HandleMovement", BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public);
		private void hook_projectile_ai(On_Projectile.orig_AI orig, Projectile self)
		{
			if (self == null) return;
			if (self.minion || self.sentry)
			{
				var gp = self.GetGlobalProjectile<SPGlobalProj>();
				gp.UpdateCounter += gp.MinionUpdateSpeed;
				while (gp.UpdateCounter >= 1f)
				{
					gp.UpdateCounter -= 1f;
					orig(self);
					if (gp.UpdateCounter >= 1f && HandleMovementMI != null)
					{
						try { HandleMovementMI.Invoke(self, new object[] { self.velocity, null, null }); } catch { }
					}
				}
			}
			else
			{
				orig(self);
			}
		}

		private void hook_get_whip_settings(
			On_Projectile.orig_GetWhipSettings orig,
			Projectile proj,
			out float timeToFlyOut,
			out int segments,
			out float rangeMultiplier)
		{
			orig(proj, out timeToFlyOut, out segments, out rangeMultiplier);
			if (!proj.friendly || proj.owner == 255) return;
			Player player = Main.player[proj.owner];
			if (player?.HeldItem?.IsAir == false)
				rangeMultiplier *= player.HeldItem.global().WhipRangeMult;
		}

		// プレイヤーインデックスの安全な検証（強化版）
		private static bool IsValidPlayerIndex(int playerIndex)
		{
			try
			{
				return playerIndex >= 0 && 
					   playerIndex < Main.maxPlayers && 
					   playerIndex != 255 &&
					   Main.player != null &&
					   playerIndex < Main.player.Length &&
					   Main.player[playerIndex] != null;
			}
			catch
			{
				return false;
			}
		}

		// プレイヤーの安全な取得（例外処理強化版）
		private static Player GetSafePlayer(int playerIndex)
		{
			try
			{
				if (!IsValidPlayerIndex(playerIndex))
					return null;

				// 二重チェックで安全性を確保
				var players = Main.player;
				if (players == null || playerIndex >= players.Length)
					return null;

				var player = players[playerIndex];
				return player?.active == true ? player : null;
			}
			catch (IndexOutOfRangeException)
			{
				TranslateTest2.Instance?.Logger?.Debug($"Player index out of range: {playerIndex}");
				return null;
			}
			catch (System.Exception ex)
			{
				TranslateTest2.Instance?.Logger?.Debug($"Error getting player {playerIndex}: {ex.Message}");
				return null;
			}
		}

		// モジュール状態の診断用
		public override void PostSetupContent()
		{
			try
			{
				Logger?.Info($"PostSetupContent: Translator loaded={TooltipTranslator.IsLoaded}, DeepL enabled={DeepLTranslator.IsEnabled}");
				
				// Prefix登録状況の診断とCategory検証
				var prefixTypes = new[]
				{
					"Abusive", "Affable", "Blessing", "Brisk", "Contract", "Deviation", "Devoted",
					"Eager", "Echo", "Electrified", "Extended", "Fabled", "Focused", "Focused_Whip",
					"Huge", "Loyal", "Mega", "Oracle", "Overload", "Steady", "Vengeful"
				};
				
				int registeredCount = 0;
				int meleeCount = 0;
				int magicCount = 0;
				
				foreach (var prefixName in prefixTypes)
				{
					try
					{
						var prefixType = ModContent.Find<ModPrefix>($"TranslateTest2/{prefixName}");
						if (prefixType != null)
						{
							registeredCount++;
							string category = prefixType.Category.ToString();
							if (prefixType.Category == PrefixCategory.Melee) meleeCount++;
							else if (prefixType.Category == PrefixCategory.Magic) magicCount++;
							
							Logger?.Debug($"Prefix registered: {prefixName} (ID: {prefixType.Type}, Category: {category})");
						}
						else
						{
							Logger?.Warn($"Prefix NOT registered: {prefixName}");
						}
					}
					catch (Exception ex)
					{
						Logger?.Error($"Error checking prefix {prefixName}: {ex.Message}");
					}
				}
				
				Logger?.Info($"Registered Prefixes: {registeredCount}/{prefixTypes.Length} (Melee: {meleeCount}, Magic: {magicCount})");
				
				// Prefix適用テスト結果の要約
				Logger?.Info("Prefix Category Assignment:");
				Logger?.Info("- Whip Prefixes (Melee): Focused_Whip, Devoted, Extended, Vengeful, Abusive, Oracle");
				Logger?.Info("- Summon Prefixes (Magic): Focused, Affable, Blessing, Brisk, Contract, Deviation, Eager, Echo, Electrified, Fabled, Huge, Loyal, Mega, Overload, Steady");
				
				// ローカリゼーション対応Prefixのツールチップ診断
				Logger?.Info("Localized Prefix Tooltips:");
				DiagnosePrefixTooltips();
			}
			catch (Exception ex)
			{
				Logger?.Warn($"PostSetupContent error: {ex.Message}");
			}
		}

		private void DiagnosePrefixTooltips()
		{
			try
			{
				Logger?.Info("=== Localization Diagnosis ===");
				
				// 現在の言語設定確認
				Logger?.Info($"Current Language: {Language.ActiveCulture?.Name ?? "Unknown"}");
				
				// ファイルの存在確認と内容の一部確認
				var localizationFiles = new[]
				{
					"Localization/en-US_Mods.TranslateTest2.hjson",
					"Localization/ja-JP_Mods.TranslateTest2.hjson"
				};
				
				foreach (var file in localizationFiles)
				{
					try
					{
						using var stream = TranslateTest2.Instance.GetFileStream(file);
						if (stream != null)
						{
							Logger?.Info($"  File {file}: EXISTS");
							
							// ファイル内容の一部を確認
							using var reader = new System.IO.StreamReader(stream);
							var content = reader.ReadToEnd();
							
							// PrefixBriskDescrが含まれているか確認
							if (content.Contains("PrefixBriskDescr"))
							{
								Logger?.Info($"    - Contains PrefixBriskDescr: YES");
								
								// 該当行を抽出
								var lines = content.Split('\n');
								foreach (var line in lines)
								{
									if (line.Contains("PrefixBriskDescr") && !line.Trim().StartsWith("//") && !line.Trim().StartsWith("/*"))
									{
										Logger?.Info($"    - Line: {line.Trim()}");
									}
								}
							}
							else
							{
								Logger?.Warn($"    - Contains PrefixBriskDescr: NO");
							}
						}
						else
						{
							Logger?.Warn($"  File {file}: NOT FOUND");
						}
					}
					catch (Exception ex)
					{
						Logger?.Warn($"  File {file}: ERROR ({ex.Message})");
					}
				}
				
				// 直接的なキーテスト
				var directTests = new[]
				{
					"Mods.TranslateTest2.PrefixBriskDescr",
					"Mods.TranslateTest2.PrefixAffableDescr", 
					"Mods.TranslateTest2.PrefixFocusedDescr",
					"Mods.TranslateTest2.PrefixExtendedDescr",
					"Mods.TranslateTest2.PrefixOracleDescr"
				};
				
				Logger?.Info("Direct Key Tests:");
				foreach (var testKey in directTests)
				{
					try
					{
						var value = Language.GetTextValue(testKey);
						bool isResolved = !string.IsNullOrEmpty(value) && value != testKey;
						Logger?.Info($"  {testKey}: {(isResolved ? "RESOLVED" : "UNRESOLVED")} -> \"{value}\"");
						
						// 特に「攻撃範囲」の文言があるかチェック
						if (isResolved && value.Contains("攻撃範囲"))
						{
							Logger?.Info($"    ✓ Contains '攻撃範囲' - Localization applied successfully!");
						}
					}
					catch (Exception ex)
					{
						Logger?.Error($"  {testKey}: EXCEPTION -> {ex.Message}");
					}
				}
				
			}
			catch (Exception ex)
			{
				Logger?.Warn($"Error diagnosing tooltip localization: {ex.Message}");
			}
		}
		
		private static bool On_ItemLoader_CanRightClick_Item(orig_ItemLoader_CanRightClick orig, Item item)
		{
			bool flag = orig(item);
			return (!InventoryConfig.Instance.SplittableGrabBags.Enabled || !ItemSlot.ShiftInUse || Main.ItemDropsDB.GetRulesForItemID(item.type).Count <= 0) && flag;
		}
		private static bool On_PlayerLoader_ShiftClickSlot(orig_PlayerLoader_ShiftClickSlot orig, Player player, Item[] inventory, int context, int slot)
		{
			bool flag = orig(player, inventory, context, slot);
			if (player.TryGetModPlayer<InventoryPlayer>(out var ip)) ip.overrideShiftLeftClick = flag; return flag;
		}
		private static void Hook_ItemSlot_MouseHover(On_ItemSlot.orig_MouseHover_ItemArray_int_int orig, Item[] inv, int context, int slot)
		{
			if (Main.LocalPlayer.TryGetModPlayer<InventoryPlayer>(out var ip)) Main.LocalPlayer.GetModPlayer<InventoryPlayer>().OverrideHover(inv, context, slot);
			orig(inv, context, slot);
		}
		private static void Hook_ItemSlot_RightClick(On_ItemSlot.orig_RightClick_ItemArray_int_int orig, Item[] inv, int context, int slot)
		{
			if (Main.LocalPlayer.TryGetModPlayer<InventoryPlayer>(out var ip)) ip.rightClickCache = Main.mouseRightRelease;
			orig(inv, context, slot);
		}
		private void Hook_ItemSlot_LeftClick(On_ItemSlot.orig_LeftClick_ItemArray_int_int orig, Item[] inv, int context, int slot)
		{
			if (Main.LocalPlayer.TryGetModPlayer<InventoryPlayer>(out var ip)) ip.leftClickCache = Main.mouseLeftRelease;
			orig(inv, context, slot);
		}
		private void Hook_ItemSlot_Handle(On_ItemSlot.orig_Handle_refItem_int orig, ref Item inv, int context)
		{
			if (Main.LocalPlayer.TryGetModPlayer<InventoryPlayer>(out var ip)) ip.noSlot = false;
			orig(ref inv, context);
		}
		private void Hook_Main_DrawInventory(On_Main.orig_DrawInventory orig, Main self)
		{
			var mp = Main.LocalPlayer.GetModPlayer<InventoryPlayer>();
			mp.hovering = false;
			orig(self);
			mp.noSlot = !mp.hovering;
		}
		public static void DebugInChat(string text)
		{
			if (!InventoryConfig.Instance.DebugMessages) return;
			Main.NewText(text, byte.MaxValue, byte.MaxValue, byte.MaxValue);
		}
	}
}



===== FILE: D:\TranslateTest2\TranslateTest2.csproj =====
<Project Sdk="Microsoft.NET.Sdk">

	<!-- Import tModLoader mod properties -->
	<Import Project="..\tModLoader.targets" />

	<!-- General -->
	<PropertyGroup>
		
	</PropertyGroup>

	<!-- References -->
	<ItemGroup>
		
	</ItemGroup>

</Project>


===== FILE: D:\TranslateTest2\WhipTag.cs =====
namespace TranslateTest2
{
    public class WhipTag
    {
        public string SpecialType = "";
        public int TimeLeft;
        public string ID = "";
        public float CritAdd;
        public int TagDamage;
        public float TagDamageMult = 1f;

        public WhipTag(string id, int tagDmg, float crit = 0.0f, float dmgMult = 1f, int time = 300)
        {
            this.ID = id;
            this.TagDamage = tagDmg;
            this.CritAdd = crit;
            this.TagDamageMult = dmgMult;
            this.TimeLeft = time;
        }

        public WhipTag Clone()
        {
            return new WhipTag(this.ID, this.TagDamage, this.CritAdd, this.TagDamageMult, this.TimeLeft)
            {
                SpecialType = this.SpecialType
            };
        }
    }
}


===== FILE: D:\TranslateTest2\WhipTagGNPC.cs =====
using Microsoft.Xna.Framework;
using System;
using System.Collections.Generic;
using System.Linq;
using Terraria;
using Terraria.ID;
using Terraria.ModLoader;

namespace TranslateTest2
{
    public class WhipTagGNPC : GlobalNPC
    {
        public List<WhipTag> tags = new List<WhipTag>();
        public override bool InstancePerEntity => true;

        public override bool PreAI(NPC npc)
        {
            if (tags.Count > 0)
            {
                for (int i = tags.Count - 1; i >= 0; i--)
                {
                    tags[i].TimeLeft--;
                    if (tags[i].TimeLeft <= 0)
                        tags.RemoveAt(i);
                }
            }
            bool hasDevoted = false;
            foreach (var tag in tags)
            {
                if (tag.SpecialType == "Devoted") { hasDevoted = true; break; }
            }
            if (hasDevoted)
            {
                for (float num = 0f; num < 360f; num += 2f)
                {
                    Dust dust = Dust.NewDustDirect(npc.Center + Utils.ToRotationVector2(MathHelper.ToRadians(num)) * 24f, 1, 1, DustID.Demonite, 0f, 0f, 0, new Color(), 1f);
                    dust.velocity = Vector2.Zero;
                    dust.noGravity = true;
                    dust.scale = 0.8f;
                }
            }
            return true;
        }

        public override void ModifyHitByProjectile(NPC npc, Projectile projectile, ref NPC.HitModifiers modifiers)
        {
            if (projectile.npcProj || projectile.trap || !projectile.IsMinionOrSentryRelated) return;
            bool hasDevoted = false;
            float tagDamageMultBase = ProjectileID.Sets.SummonTagDamageMultiplier[projectile.type];
            int flatTagDamage = 0;
            float critAdd = 0f;
            float sourceDamageMult = 1f;
            critAdd += projectile.GetGlobalProjectile<SPGlobalProj>().MinionCrit;
            foreach (var tag in tags)
            {
                if (tag.SpecialType == "Devoted") hasDevoted = true;
                flatTagDamage += tag.TagDamage;
                critAdd += tag.CritAdd;
                sourceDamageMult += (tag.TagDamageMult - 1f) * tagDamageMultBase;
            }
            if (projectile.TryGetOwner(out Player player))
            {
                var item = player.HeldItem;
                if (item.shoot > 0 && ProjectileID.Sets.IsAWhip[item.shoot] && item.global().wTag.SpecialType == "Devoted")
                {
                    if (hasDevoted) sourceDamageMult += Prefixes.Devoted.Increase; else sourceDamageMult -= Prefixes.Devoted.Decrease;
                }
            }
            modifiers.FlatBonusDamage += flatTagDamage * tagDamageMultBase;
            modifiers.SourceDamage *= sourceDamageMult;
            if (Utils.NextFloat(Main.rand) < critAdd) modifiers.SetCrit();
        }
    }
}


===== FILE: D:\TranslateTest2\BInfoAcc\BInfoAcc.cs =====
using Terraria.ModLoader;

namespace BInfoAcc
{
	public class BInfoAcc : Mod
	{
	}
}


===== FILE: D:\TranslateTest2\BInfoAcc\BInfoAcc.csproj =====

<Project Sdk="Microsoft.NET.Sdk">
  <Import Project="..\tModLoader.targets" />
  <PropertyGroup>
    <AssemblyName>BInfoAcc</AssemblyName>
    <LangVersion>latest</LangVersion>
  </PropertyGroup>
  <ItemGroup>
  </ItemGroup>
</Project>


===== FILE: D:\TranslateTest2\BInfoAcc\Common\Config.cs =====
using System.ComponentModel;
using Terraria.ModLoader.Config;

namespace BInfoAcc.Common
{
	public class ConfigServer : ModConfig
	{
		public override ConfigScope Mode => ConfigScope.ServerSide;

		[DefaultValue(false)]
		public bool easySell;

		[DefaultValue(true)]
		[ReloadRequired]
		public bool extendedRecipe;

        [DefaultValue(true)]
		public bool updatedPhones;

        [DefaultValue(false)]
        public bool simpleDisplay;

        [Range(30, 600)]
        [DefaultValue(60)]
        public int refreshRate;
   
        [Range(0.25f, 4f)]
        [Increment(.25f)]
        [DefaultValue(1f)]
        public float cycleRate;

        [DefaultValue(true)]
        public bool prioModBiomes;
    }
}



===== FILE: D:\TranslateTest2\BInfoAcc\Common\InfoDisplays.cs =====
using Terraria;
using Terraria.ModLoader;
using Microsoft.Xna.Framework;
using System;
using Terraria.Localization;
using Humanizer;
using Terraria.GameContent.Events;
using Terraria.ID;
using System.Collections.Generic;

namespace BInfoAcc.Common
{
	[LegacyName ("LuckInfoDisplay")]
	public class InfoDisplay0 : InfoDisplay
	{
		
		public override bool Active()
		{
			return Main.LocalPlayer.GetModPlayer<InfoPlayer>().luckDisplay;
		}

        public override string DisplayValue(ref Color displayColor, ref Color displayShadowColor)
        {
            float luckValue = Main.LocalPlayer.luck;
            luckValue = (float)Math.Round(luckValue, 2);

            if (luckValue == 0)
            {
                displayColor = InactiveInfoTextColor;
            }
            else if (luckValue > 0)
            {
                displayColor = new Color(120, 190, 120);
            }
            else if (luckValue < 0)
            {
                displayColor = new Color(190, 120, 120);
            }

            return Language.GetTextValue("Mods.BInfoAcc.CommonItemtooltip.LuckDisplay").FormatWith(luckValue);
        }
	}

    [LegacyName("MinionInfoDisplay")]
    public class InfoDisplay7 : InfoDisplay
	{
		public override bool Active()
		{
			return Main.LocalPlayer.GetModPlayer<InfoPlayer>().minionDisplay;
		}

		public override string DisplayValue(ref Color displayColor, ref Color displayShadowColor)
		{
			float minionCount = 0;
			for (int i = 0; i < Main.maxProjectiles; i++)
			{
				Projectile proj = Main.projectile[i];
				if (proj.active && proj.minionSlots > 0f && proj.owner == Main.myPlayer)
				{
					minionCount += proj.minionSlots;
				}
			}

			minionCount = (float)Math.Round(minionCount, 2);

			int maxMinions = Main.LocalPlayer.maxMinions;

			if (minionCount == 0)
			{
				displayColor = InactiveInfoTextColor;
			}

			return Language.GetTextValue("Mods.BInfoAcc.CommonItemtooltip.MinionDisplay").FormatWith(minionCount, maxMinions);
        }
	}

    [LegacyName("SentryInfoDisplay")]
    public class InfoDisplay8 : InfoDisplay
	{
		public override bool Active()
		{
			return Main.LocalPlayer.GetModPlayer<InfoPlayer>().sentryDisplay;
		}

		public override string DisplayValue(ref Color displayColor, ref Color displayShadowColor)
		{
			int sentryCount = 0;
			for (int i = 0; i < Main.maxProjectiles; i++)
			{
				Projectile proj = Main.projectile[i];
				if (proj.active && proj.sentry && !DD2SentryCheck(proj) && proj.owner == Main.myPlayer)
				{
					sentryCount ++;
				}
			}

			int maxSentries = Main.LocalPlayer.maxTurrets;

			if (sentryCount == 0)
			{
				displayColor = InactiveInfoTextColor;
			}

			return Language.GetTextValue("Mods.BInfoAcc.CommonItemtooltip.SentryDisplay").FormatWith(sentryCount, maxSentries);
		}

		private static bool DD2SentryCheck(Projectile proj)
		{
			if(DD2Event.Ongoing &&
				(proj.type == ProjectileID.DD2BallistraTowerT1 || proj.type == ProjectileID.DD2BallistraTowerT2 || proj.type == ProjectileID.DD2BallistraTowerT3
				|| proj.type == ProjectileID.DD2FlameBurstTowerT1 || proj.type == ProjectileID.DD2FlameBurstTowerT2 || proj.type == ProjectileID.DD2FlameBurstTowerT3
                || proj.type == ProjectileID.DD2ExplosiveTrapT1 || proj.type == ProjectileID.DD2ExplosiveTrapT2 || proj.type == ProjectileID.DD2ExplosiveTrapT3
                || proj.type == ProjectileID.DD2LightningAuraT1 || proj.type == ProjectileID.DD2LightningAuraT2 || proj.type == ProjectileID.DD2LightningAuraT3))
			{
				return true;
			}
			return false;
		}
	}

    [LegacyName("RegenInfoDisplay")]
    public class InfoDisplay1 : InfoDisplay
	{
		public override bool Active()
		{
			return Main.LocalPlayer.GetModPlayer<InfoPlayer>().regenDisplay;
		}

		public override string DisplayValue(ref Color displayColor, ref Color displayShadowColor)
		{
			float lifeRegen = Main.LocalPlayer.lifeRegen;
			lifeRegen *= 0.5f;
			lifeRegen = (float)Math.Round(lifeRegen, 2);

            if (Main.LocalPlayer.statLife >= Main.LocalPlayer.statLifeMax2)
            {
                return Language.GetTextValue("Mods.BInfoAcc.CommonItemtooltip.RegenDisplayFull");
            }
            else if (lifeRegen == 0)
			{
				displayColor = InactiveInfoTextColor;
			}
			else if (lifeRegen > 0)
			{			
				displayColor = new Color(120, 190, 120);
			}
			else if (lifeRegen < 0)
			{
				displayColor = new Color(190, 120, 120);
			}

			return lifeRegen > 0 ? Language.GetTextValue("Mods.BInfoAcc.CommonItemtooltip.RegenDisplayPos").FormatWith(lifeRegen) : Language.GetTextValue("Mods.BInfoAcc.CommonItemtooltip.RegenDisplayNeg").FormatWith(lifeRegen);
        }
	}

    [LegacyName("SpawnRateInfoDisplay")]
    public class InfoDisplay3 : InfoDisplay
	{
		public override bool Active()
		{
			return Main.LocalPlayer.GetModPlayer<InfoPlayer>().spawnRateDisplay;
		}

		public override string DisplayValue(ref Color displayColor, ref Color displayShadowColor)
		{
			int spawnRateRaw = Main.LocalPlayer.GetModPlayer<InfoPlayer>().spawnRate;
            int spawnCap = Main.LocalPlayer.GetModPlayer<InfoPlayer>().spawnCap;

            // Spawn Rate is the chance for an enemy spawn per tick; this translates that chance to be per second instead
            float spawnRateAdapted = spawnRateRaw == 0 ? 0 : 60f / spawnRateRaw;
			spawnRateAdapted = (float)Math.Round(spawnRateAdapted, 2);

			// Manual pluarlization since our input is a float
			string spawnRatePluralized = ModContent.GetInstance<ConfigServer>().simpleDisplay ? "" : "~";
            spawnRatePluralized += spawnRateAdapted == 1 ? Language.GetTextValue("Mods.BInfoAcc.CommonItemtooltip.SpawnRateDisplayS").FormatWith(spawnRateAdapted) : Language.GetTextValue("Mods.BInfoAcc.CommonItemtooltip.SpawnRateDisplayP").FormatWith(spawnRateAdapted);
            if(spawnRateRaw == 0)
			{
				spawnRatePluralized = Language.GetTextValue("Mods.BInfoAcc.CommonItemtooltip.SpawnRateDisplayError");
            }

            string spawnCapString = ModContent.GetInstance<ConfigServer>().simpleDisplay ? "" : "~";
            spawnCapString += Language.GetTextValue("Mods.BInfoAcc.CommonItemtooltip.SpawnCapDisplay").FormatWith(spawnCap);
			

            InfoPlayer player = Main.LocalPlayer.GetModPlayer<InfoPlayer>();
			bool altDisplay = (player.displayTimer / 1000) % 2 == 0;

			string textToShow = altDisplay ? spawnRatePluralized : spawnCapString;

            if (!ModContent.GetInstance<ConfigServer>().simpleDisplay)
            {
                textToShow += " +"; // Adds a '+' on to the end of the line, indicating there is more information (Like Weather Radio during a Sandstorm)
            }

            return textToShow;
        }
	}

    [LegacyName("ComboInfoDisplay")]
    public class InfoDisplay6 : InfoDisplay
	{
		public override bool Active()
		{
			return Main.LocalPlayer.GetModPlayer<InfoPlayer>().comboDisplay;
		}

		public override string DisplayValue(ref Color displayColor, ref Color displayShadowColor)
		{
			InfoPlayer player = Main.LocalPlayer.GetModPlayer<InfoPlayer>();

			int hits = player.hitCounter;
			int dmg = player.comboDmg;
			float time = player.comboTime / 60f;
			time = (float)Math.Round(time, 1);

			if (hits == 0)
			{
				displayColor = InactiveInfoTextColor;
				return Language.GetTextValue("Mods.BInfoAcc.CommonItemtooltip.ComboDisplayNone");
            }

			// Convert to strings
			string hitCount = CompactNumbers(hits);
			string timeCount = CompactTime(time);
			string dmgCount = CompactNumbers(dmg);

            bool altDisplay = (player.displayTimer / 1000) % 2 == 0;
            string text = altDisplay ? Language.GetTextValue("Mods.BInfoAcc.CommonItemtooltip.ComboDisplayDmg").FormatWith(hitCount, dmgCount)
							  : Language.GetTextValue("Mods.BInfoAcc.CommonItemtooltip.ComboDisplayTime").FormatWith(hitCount ,timeCount);

			if (!ModContent.GetInstance<ConfigServer>().simpleDisplay)
			{
				text += " +"; // Adds a '+' on to the end of the line, indicating there is more information (Like Weather Radio during a Sandstorm)
			}
			return text;
        }

		private static string CompactNumbers(int baseInt)
        {
			float baseFloat = (float)baseInt;
			string suffix = "";
			if(baseFloat < 0)
            {
				return Language.GetTextValue("Mods.BInfoAcc.CommonItemtooltip.ComboError");
            }

			if (baseFloat >= 100000000f)
			{
				suffix = Language.GetTextValue("Mods.BInfoAcc.CommonItemtooltip.SuffixBillion");
                baseFloat /= 1000000000f;
				baseFloat = (float)Math.Round(baseFloat, 1);
			}
			else if (baseFloat >= 100000f)
			{
				suffix = Language.GetTextValue("Mods.BInfoAcc.CommonItemtooltip.SuffixMillion");
                baseFloat /= 1000000f;
				baseFloat = (float)Math.Round(baseFloat, 1);
			}
			else if (baseFloat >= 1000f)
			{
				suffix = Language.GetTextValue("Mods.BInfoAcc.CommonItemtooltip.SuffixThousand");
                baseFloat /= 1000f;
				baseFloat = (float)Math.Round(baseFloat, 1);
			}
			return $"{baseFloat}" + suffix;
		}

		private static string CompactTime(float baseNum)
        {
			string suffix = Language.GetTextValue("Mods.BInfoAcc.CommonItemtooltip.SuffixSeconds");
            if (baseNum >= 3600f)
			{
				suffix = Language.GetTextValue("Mods.BInfoAcc.CommonItemtooltip.SuffixHours");
                baseNum /= 3600f;
				baseNum = (float)Math.Round(baseNum, 1);
			}
			else if (baseNum >= 60f)
            {
				suffix = Language.GetTextValue("Mods.BInfoAcc.CommonItemtooltip.SuffixMinutes");
                baseNum /= 60f;
				baseNum = (float)Math.Round(baseNum, 1);
			}
			return $"{baseNum}" + suffix;
		}
	}

    [LegacyName("BiomeInfoDisplay")]
    public class InfoDisplay4 : InfoDisplay
    {
        public override bool Active()
        {
            return Main.LocalPlayer.GetModPlayer<InfoPlayer>().biomeDisplay;
        }

        public override string DisplayValue(ref Color displayColor, ref Color displayShadowColor)
        {
            InfoPlayer player = Main.LocalPlayer.GetModPlayer<InfoPlayer>();

			string biomeToDisplay = Language.GetTextValue("Mods.BInfoAcc.Biomes.Neutral");

			List<string> biomeNames = new List<string>();
			if (player.biomeNames != null)
			{
				biomeNames = player.biomeNames;
			}	
            if (biomeNames.Count > 0)
			{
				int stateTimer = player.displayTimer;
				while(stateTimer > 2000) // Effectivley caps displayTimer (Which goes from 0-4000) to 0-1000 whilst preserving resultant cycle speed
                {
					stateTimer -= 2000;
				}

                int displayState = -1;
				while(stateTimer > 0)
				{
                    stateTimer -= 2000 / biomeNames.Count;
					displayState++;
                }

				if (displayState > -1 && displayState < biomeNames.Count)
				{
					if (biomeNames[displayState] != null && biomeNames[displayState] != "")
					{
                        biomeToDisplay = biomeNames[displayState];
                    }
				}
            }

			if(!ModContent.GetInstance<ConfigServer>().simpleDisplay && biomeNames.Count > 1)
			{
                biomeToDisplay += " +"; // Adds a '+' on to the end of the line, indicating there is more information (Like Weather Radio during a Sandstorm)
            }

			return biomeToDisplay;
        }
    }

    [LegacyName("AggroInfoDisplay")]
    public class InfoDisplay5 : InfoDisplay
    {
        public override bool Active()
        {
            return Main.LocalPlayer.GetModPlayer<InfoPlayer>().aggroDisplay;
        }

        public override string DisplayValue(ref Color displayColor, ref Color displayShadowColor)
        {
            int aggroValue = Main.LocalPlayer.aggro;

            if (aggroValue == 0)
            {
                displayColor = InactiveInfoTextColor;
            }
            else if (aggroValue < 0)
            {
                displayColor = new Color(120, 190, 120);
            }
            else if (aggroValue > 0)
            {
                displayColor = new Color(190, 120, 120);
            }

            return Language.GetTextValue("Mods.BInfoAcc.CommonItemtooltip.AggroDisplay").FormatWith(aggroValue);
        }
    }

    [LegacyName("ManaInfoDisplay")]
    public class InfoDisplay2 : InfoDisplay
    {
        public override bool Active()
        {
            return Main.LocalPlayer.GetModPlayer<InfoPlayer>().manaDisplay;
        }

        public override string DisplayValue(ref Color displayColor, ref Color displayShadowColor)
        {
			int manaUsage = Main.LocalPlayer.GetModPlayer<InfoPlayer>().GetMPS();
            int naturalRegen = Main.LocalPlayer.manaRegen;
			if(naturalRegen > 1) // 2 points of manaRegen == 1 mana/sec
			{
				naturalRegen /= 2;
			}

			int totalMPS;
			if(naturalRegen > 0 && Main.LocalPlayer.manaRegenDelay <= 0)
			{
				totalMPS = naturalRegen;
            }
			else
			{
				totalMPS = -manaUsage + naturalRegen;
            }

            if (Main.LocalPlayer.statMana >= Main.LocalPlayer.statManaMax2)
            {
                return Language.GetTextValue("Mods.BInfoAcc.CommonItemtooltip.ManaDisplayFull");
            }
            else if (totalMPS == 0)
            {
                displayColor = InactiveInfoTextColor;
            }
            else if (totalMPS > 0)
            {
                displayColor = new Color(120, 190, 120);
            }
            else if (totalMPS < 0)
            {
                displayColor = new Color(190, 120, 120);
            }

            return totalMPS > 0 ? Language.GetTextValue("Mods.BInfoAcc.CommonItemtooltip.ManaDisplayPos").FormatWith(totalMPS) : Language.GetTextValue("Mods.BInfoAcc.CommonItemtooltip.ManaDisplayNeg").FormatWith(totalMPS);
        }
    }
}


===== FILE: D:\TranslateTest2\BInfoAcc\Common\InfoPlayer.cs =====
using BInfoAcc.Content;
using Microsoft.Xna.Framework;
using System;
using System.Collections.Generic;
using System.Reflection;
using Terraria;
using Terraria.ID;
using Terraria.Localization;
using Terraria.ModLoader;

namespace BInfoAcc.Common
{
	public class InfoPlayer : ModPlayer
	{
		public bool minionDisplay;
		public bool luckDisplay;
		public bool sentryDisplay;
		public bool comboDisplay;
		public bool spawnRateDisplay;
		public bool regenDisplay;
        public bool biomeDisplay;
        public bool aggroDisplay;
        public bool manaDisplay;

        // Used by some data trackers to reduce frequency of checks, to prevent flckering data and help reduce potential lag
        public int bufferedInfoUpdateTimer;
        // Used by some data trackers to cycle between different display states, similar to the weather radio displaying sandstorms
        public int displayTimer;

        // For spawn rate/cap
        public int spawnRate; // The actual spawn rate recorded
        public int spawnCap; // The actual spawn limit recorded
        static FieldInfo spawnRateFieldInfo; // Used in reflection for obtaining spawn rate
        static FieldInfo spawnCapFieldInfo; // Used in reflection for obtaining spawn limit

        // For combo
        public int hitCounter;
        public int comboTime;
        public int comboDmg;
        int expirationCounter = -1;

        // For biomes
        public List<string> biomeNames;

        // For mana; adapted from DPS meter
        public DateTime mpsStart;
        public DateTime mpsEnd;
        public DateTime mpsLastUse;
        public int mpsAmount;
        public bool mpsStarted;

        public override void ResetInfoAccessories()
		{
			minionDisplay = false;
			luckDisplay = false;
			sentryDisplay = false;
			comboDisplay = false;
			spawnRateDisplay = false;
			regenDisplay = false;
            biomeDisplay = false;
            aggroDisplay = false;
            manaDisplay = false;
        }

		public override void RefreshInfoAccessoriesFromTeamPlayers(Player otherPlayer)
		{
			if (otherPlayer.GetModPlayer<InfoPlayer>().minionDisplay)
			{
				minionDisplay = true;
			}
			if (otherPlayer.GetModPlayer<InfoPlayer>().luckDisplay)
			{
				luckDisplay = true;
			}
			if (otherPlayer.GetModPlayer<InfoPlayer>().sentryDisplay)
			{
				sentryDisplay = true;
			}
			if (otherPlayer.GetModPlayer<InfoPlayer>().comboDisplay)
			{
				comboDisplay = true;
			}
			if (otherPlayer.GetModPlayer<InfoPlayer>().spawnRateDisplay)
			{
				spawnRateDisplay = true;
			}
			if (otherPlayer.GetModPlayer<InfoPlayer>().regenDisplay)
			{
				regenDisplay = true;
			}
            if (otherPlayer.GetModPlayer<InfoPlayer>().manaDisplay)
            {
                manaDisplay = true;
            }
            if (otherPlayer.GetModPlayer<InfoPlayer>().aggroDisplay)
            {
                aggroDisplay = true;
            }
            if (otherPlayer.GetModPlayer<InfoPlayer>().biomeDisplay)
            {
                biomeDisplay = true;
            }
        }

        public override void PreUpdate()
        {
            if(bufferedInfoUpdateTimer > 0)
            {
                bufferedInfoUpdateTimer--;
			}

            displayTimer += (int)(ModContent.GetInstance<ConfigServer>().cycleRate * 4f);
            if (displayTimer > 4000)
            {
                displayTimer = 1;
            }

            // Handles combo display info
            if (hitCounter > 0 && expirationCounter > 0 && !Player.dead && Player.active)
            {
                expirationCounter--;
                comboTime++;
            }
            else
            {
                hitCounter = 0;
                comboTime = 0;
                comboDmg = 0;
                expirationCounter = -1;
            }
        }

        public override void PostUpdateEquips()
        {
            if (!manaDisplay && mpsStarted) // Adapted from DPS meter
            {
                mpsStarted = false;
                mpsEnd = DateTime.Now;
            }
        }

        public override void PostUpdate()
        {
            if(bufferedInfoUpdateTimer <= 0)
            {
                bufferedInfoUpdateTimer = ModContent.GetInstance<ConfigServer>().refreshRate;

                if(spawnRateDisplay)
                {
                    // !Reflection!
                    spawnRateFieldInfo = typeof(NPC).GetField("spawnRate", BindingFlags.Static | BindingFlags.NonPublic);
                    spawnCapFieldInfo = typeof(NPC).GetField("maxSpawns", BindingFlags.Static | BindingFlags.NonPublic);

                    spawnRate = (int)spawnRateFieldInfo.GetValue(null);
                    spawnCap = (int)spawnCapFieldInfo.GetValue(null);
                }

                if(biomeDisplay)
                {
                    Point tilePos = Player.Center.ToTileCoordinates();
                    biomeNames = GetBiomes(Main.tile[tilePos.X, tilePos.Y]);
                }
            }
        }

        public override void OnHitNPC(NPC target, NPC.HitInfo hit, int damageDone)
        {
            IncrementHitCounter(damageDone);
        }

        private void IncrementHitCounter(int dmg)
        {
            if (Player.dead || !Player.active)
            {
                return;
            }
            hitCounter++;
            comboDmg += dmg;

            // Hard cap values to avoid integer limit
            if (hitCounter >= int.MaxValue - 1 || hitCounter < 0)
            {
                hitCounter = int.MaxValue - 1;
            }
            if (comboDmg >= int.MaxValue - 1 || comboDmg < 0)
            {
                comboDmg = int.MaxValue - 1;
            }
            expirationCounter = 180;
        }

        public override void OnConsumeMana(Item item, int manaConsumed)
        {
            AddMPS(manaConsumed);
        }

        // Mana Display functions; adapted from DPS meter
        public void AddMPS(int mana) 
        {
            if (mpsStarted)
            {
                mpsLastUse = DateTime.Now;
                mpsAmount += mana;
                mpsEnd = DateTime.Now;
            }
            else
            {
                mpsStarted = true;
                mpsStart = DateTime.Now;
                mpsEnd = DateTime.Now;
                mpsLastUse = DateTime.Now;
                mpsAmount = mana;
            }
        }

        public void CheckMPSTime()
        {
            if (mpsStarted)
            {
                TimeSpan val = DateTime.Now - mpsLastUse;
                if (val.Seconds > 1 || (Player.manaRegenDelay <= 0 && Player.manaRegen > 0))
                {
                    mpsStarted = false;
                }
            }
        }

        public int GetMPS()
        {
            TimeSpan timeSpan = mpsEnd - mpsStart;
            float num = (float)(timeSpan.Milliseconds / 1000f);
            num += (float)(timeSpan.Seconds);
            num += (float)(timeSpan.Minutes / 60f);
            if (num >= 3f)
            {
                mpsStart = DateTime.Now;
                mpsStart = mpsStart.AddSeconds(-1.0);
                mpsAmount = (int)((float)mpsAmount / num);
                timeSpan = mpsEnd - mpsStart;

                num = (float)(timeSpan.Milliseconds / 1000f);
                num += (float)(timeSpan.Seconds);
                num += (float)(timeSpan.Minutes / 60f);
            }
            if (num < 1f)
            {
                num = 1f;
            }
            return (int)((float)mpsAmount / num);
        }

        // Helper methods for biome display
        private List<string> GetBiomes(Tile plrCenterTile)
        {
            List<string> biomeNames = new List<string>();

            // Towns have highest prio
            if (Player.townNPCs > 2f && !Player.ZoneShadowCandle)
            {
                AddBiomeName(ref biomeNames, "Vanilla.Town");
            }
            // Space and Underworld have high prio, but depend on the depth meter
            if (Player.accDepthMeter != 0)
            {
                if (Player.ZoneUnderworldHeight)
                {
                    if(TryCheckInBiome("TheDepths", "DepthsBiome")) // The Depths mod compat.
                    {
                        AddBiomeName(ref biomeNames, "Depths.Depths");
                    }
                    else
                    {
                        AddBiomeName(ref biomeNames, "Vanilla.Underworld");
                    }
                }
                if (Player.ZoneSkyHeight)
                {
                    AddBiomeName(ref biomeNames, "Vanilla.Space");
                }
            }
            if (ModContent.GetInstance<ConfigServer>().prioModBiomes)
            {
                AddModdedBiomeNames(ref biomeNames);
                AddVanillaBiomeNames(ref biomeNames, plrCenterTile);
            }
            else
            {
                AddVanillaBiomeNames(ref biomeNames, plrCenterTile);
                AddModdedBiomeNames(ref biomeNames);
            }
            // Underground/Cavern has lowest prio. Also dependent on depth meter like space and underworld
            if ((Player.ZoneRockLayerHeight || Player.ZoneDirtLayerHeight || Player.ZoneUndergroundDesert)
                && Player.accDepthMeter != 0)
            {
                AddBiomeName(ref biomeNames, "Vanilla.Underground");
            }

            return biomeNames;
        }

        private void AddVanillaBiomeNames(ref List<string> biomeNames, Tile plrCenterTile)
        {
            // High prio
            if (Player.ZoneTowerSolar)
            {
                AddBiomeName(ref biomeNames, "Vanilla.Solar");
            }
            if (Player.ZoneTowerVortex)
            {
                AddBiomeName(ref biomeNames, "Vanilla.Vortex");
            }
            if (Player.ZoneTowerNebula)
            {
                AddBiomeName(ref biomeNames, "Vanilla.Nebula");
            }
            if (Player.ZoneTowerStardust)
            {
                AddBiomeName(ref biomeNames, "Vanilla.Stardust");
            }
            if (Player.ZoneMeteor)
            {
                AddBiomeName(ref biomeNames, "Vanilla.Meteor");
            }
            if (Player.ZoneDungeon)
            {
                AddBiomeName(ref biomeNames, "Vanilla.Dungeon");
            }
            if (Player.ZoneLihzhardTemple || plrCenterTile.WallType == WallID.LihzahrdBrickUnsafe)
            {
                AddBiomeName(ref biomeNames, "Vanilla.Temple", ModLoader.HasMod("Remnants"));
            }
            if (Player.ZoneShimmer)
            {
                AddBiomeName(ref biomeNames, "Vanilla.Aether");
            }
            if (plrCenterTile.WallType == WallID.SpiderUnsafe) // Spider
            {
                AddBiomeName(ref biomeNames, "Vanilla.Spider");
            }

            // Standard prio
            if (Player.ZoneCorrupt)
            {
                AddBiomeName(ref biomeNames, "Vanilla.Corruption", true);
            }
            if (Player.ZoneCrimson)
            {
                AddBiomeName(ref biomeNames, "Vanilla.Crimson", true);
            }
            if (Player.ZoneGlowshroom)
            {
                AddBiomeName(ref biomeNames, "Vanilla.Shroom");
            }
            if (Player.ZoneJungle)
            {
                AddBiomeName(ref biomeNames, "Vanilla.Jungle");
            }
            if (Player.ZoneHallow)
            {
                AddBiomeName(ref biomeNames, "Vanilla.Hallow", true);
            }
            if (Player.ZoneBeach)
            {
                AddBiomeName(ref biomeNames, "Vanilla.Ocean", ModLoader.HasMod("Remnants"));
            }
            if (Player.ZoneSnow)
            {
                AddBiomeName(ref biomeNames, "Vanilla.Snow", true);
            }
            if (Player.ZoneDesert || Player.ZoneUndergroundDesert)
            {
                AddBiomeName(ref biomeNames, "Vanilla.Desert", true);
            }

            // Low prio
            if (Player.ZoneHive)
            {
                AddBiomeName(ref biomeNames, "Vanilla.Beehive", ModLoader.HasMod("Remnants"));
            }
            if (Player.ZoneGranite)
            {
                AddBiomeName(ref biomeNames, "Vanilla.Granite");
            }
            if (Player.ZoneMarble)
            {
                AddBiomeName(ref biomeNames, "Vanilla.Marble", ModLoader.HasMod("Remnants"));
            }
            if (Player.ZoneGraveyard &&
                !(Player.ZoneUnderworldHeight || Player.ZoneRockLayerHeight || Player.ZoneDirtLayerHeight))
            {
                AddBiomeName(ref biomeNames, "Vanilla.Graveyard");
            }
            else if (Player.ZoneForest)
            {
                AddBiomeName(ref biomeNames, "Vanilla.Forest");
            }
        }

        // Mod support
        private void AddModdedBiomeNames(ref List<string> biomeNames)
        {      
            AddStarsAboveBiomeNames(ref biomeNames);
            AddCalamityBiomeNames(ref biomeNames);
            AddThoriumBiomeNames(ref biomeNames);
            AddRedemptionBiomeNames(ref biomeNames);
            AddAvalonBiomeNames(ref biomeNames);
            AddSpiritBiomeNames(ref biomeNames); 
            AddConfectionBiomeNames(ref biomeNames);
            AddSpookyBiomeNames(ref biomeNames);
            AddAequusBiomeNames(ref biomeNames);
            AddVerdantBiomeNames(ref biomeNames);
            AddValhallaBiomeNames(ref biomeNames);
            AddRiseOfAgesBiomeNames(ref biomeNames);
            AddRemnantsBiomeNames(ref biomeNames);
            AddFFFBiomeNames(ref biomeNames);
        }

        private void AddThoriumBiomeNames(ref List<string> biomeNames)
        {
            string modName = "ThoriumMod";
            if (TryCheckInBiome(modName, "DepthsBiome")
                && Player.position.Y > Main.worldSurface * 16)
            {
                AddBiomeName(ref biomeNames, "Thorium.Depths");
            }
        }

        private void AddCalamityBiomeNames(ref List<string> biomeNames)
        {
            string modName = "CalamityMod";

            // Astral Infection
            if(TryCheckInBiome(modName, "AstralInfectionBiome"))
            {
                AddBiomeName(ref biomeNames, "Calamity.Astral", true);
            }
            if (TryCheckInBiome(modName, "AbovegroundAstralSnowBiome"))
            {
                AddBiomeName(ref biomeNames, "Calamity.Astral", true);
                AddBiomeName(ref biomeNames, "Vanilla.Snow", true);
            }
            if (TryCheckInBiome(modName, "AbovegroundAstralDesertBiome"))
            {
                AddBiomeName(ref biomeNames, "Calamity.Astral", true);
                AddBiomeName(ref biomeNames, "Vanilla.Desert", true);
            }
            if (TryCheckInBiome(modName, "UndergroundAstralBiome"))
            {
                AddBiomeName(ref biomeNames, "Calamity.Astral", true);
                AddBiomeName(ref biomeNames, "Vanilla.Underground", true);
            }

            if (TryCheckInBiome(modName, "BrimstoneCragsBiome"))
            {
                AddBiomeName(ref biomeNames, "Calamity.Crags");
            }
            if (TryCheckInBiome(modName, "SulphurousSeaBiome"))
            {
                AddBiomeName(ref biomeNames, "Calamity.SulphurousSea");
                RemoveBiomeName(ref biomeNames, "Vanilla.Ocean");
            }
            if (TryCheckInBiome(modName, "SunkenSeaBiome"))
            {
                AddBiomeName(ref biomeNames, "Calamity.SunkenSea");
            }

            // The Abyss   
            if (TryCheckInBiome(modName, "AbyssLayer4Biome"))
            {
                AddBiomeName(ref biomeNames, "Calamity.AbyssMain");
                AddBiomeName(ref biomeNames, "Calamity.Abyss4");
            }
            else if (TryCheckInBiome(modName, "AbyssLayer3Biome"))
            {
                AddBiomeName(ref biomeNames, "Calamity.AbyssMain");
                AddBiomeName(ref biomeNames, "Calamity.Abyss3");
            }
            else if (TryCheckInBiome(modName, "AbyssLayer2Biome"))
            {
                AddBiomeName(ref biomeNames, "Calamity.AbyssMain");
                AddBiomeName(ref biomeNames, "Calamity.Abyss2");
            }
            else if (TryCheckInBiome(modName, "AbyssLayer1Biome"))
            {
                AddBiomeName(ref biomeNames, "Calamity.AbyssMain");
                AddBiomeName(ref biomeNames, "Calamity.Abyss1");
            }
        }

        private void AddRedemptionBiomeNames(ref List<string> biomeNames)
        {
            string modName = "Redemption";
            if (TryCheckInBiome(modName, "LabBiome"))
            {
                AddBiomeName(ref biomeNames, "Redemption.Lab");
            }
            if (TryCheckInBiome(modName, "SoullessBiome"))
            {
                AddBiomeName(ref biomeNames, "Redemption.Soulless");
            }


            if (TryCheckInBiome(modName, "WastelandCorruptionBiome"))
            {
                AddBiomeName(ref biomeNames, "Redemption.Wasteland", true);
                AddBiomeName(ref biomeNames, "Vanilla.Corruption", true);
            }
            if (TryCheckInBiome(modName, "WastelandCrimsonBiome"))
            {
                AddBiomeName(ref biomeNames, "Redemption.Wasteland", true);
                AddBiomeName(ref biomeNames, "Vanilla.Crimson", true);
            }
            if (TryCheckInBiome(modName, "WastelandSnowBiome"))
            {
                AddBiomeName(ref biomeNames, "Redemption.Wasteland", true);
                AddBiomeName(ref biomeNames, "Vanilla.Snow", true);
            }
            if (TryCheckInBiome(modName, "WastelandDesertBiome"))
            {
                AddBiomeName(ref biomeNames, "Redemption.Wasteland", true);
                AddBiomeName(ref biomeNames, "Vanilla.Desert", true);
            }
            if (TryCheckInBiome(modName, "WastelandPurityBiome"))
            {
                AddBiomeName(ref biomeNames, "Redemption.Wasteland", true);
            }
        }

        private void AddAequusBiomeNames(ref List<string> biomeNames)
        {
            string modName = "Aequus";
            if (TryCheckInBiome(modName, "CrabCreviceBiome"))
            {
                AddBiomeName(ref biomeNames, "Aequus.Crevice");
            }
        }

        private void AddConfectionBiomeNames(ref List<string> biomeNames)
        {
            string modName = "TheConfectionRebirth";
            if (TryCheckInBiome(modName, "SandConfectionUndergroundBiome"))
            {
                AddBiomeName(ref biomeNames, "Confection.Confection", true);
                AddBiomeName(ref biomeNames, "Vanilla.Desert", true);
            }
            else if (TryCheckInBiome(modName, "SandConfectionSurfaceBiome"))
            {
                AddBiomeName(ref biomeNames, "Confection.Confection", true);
                AddBiomeName(ref biomeNames, "Vanilla.Desert", true);
            }
            if (TryCheckInBiome(modName, "IceConfectionUndergroundBiome"))
            {
                AddBiomeName(ref biomeNames, "Confection.Confection", true);
                AddBiomeName(ref biomeNames, "Vanilla.Snow", true);
            }
            else if (TryCheckInBiome(modName, "IceConfectionSurfaceBiome"))
            {
                AddBiomeName(ref biomeNames, "Confection.Confection", true);
                AddBiomeName(ref biomeNames, "Vanilla.Snow", true);
            }
            if (TryCheckInBiome(modName, "ConfectionUndergroundBiome"))
            {
                AddBiomeName(ref biomeNames, "Confection.Confection", true);
            }
            else if (TryCheckInBiome(modName, "ConfectionBiome"))
            {
                AddBiomeName(ref biomeNames, "Confection.Confection", true);
            }
        }

        private void AddFFFBiomeNames(ref List<string> biomeNames)
        {
            string modName = "CosmeticVariety";
            if (TryCheckInBiome(modName, "CelestialSurfaceBiome"))
            {
                AddBiomeName(ref biomeNames, "FFF.Celestial");
            }
            if (TryCheckInBiome(modName, "GardenBiome"))
            {
                AddBiomeName(ref biomeNames, "FFF.Garden");
            }
            else if (TryCheckInBiome(modName, "GardenSurfaceBiome"))
            {
                AddBiomeName(ref biomeNames, "FFF.Garden");
            }
        }

        private void AddRemnantsBiomeNames(ref List<string> biomeNames)
        {
            string modName = "Remnants";
            // Vanilla biome overhauls
            if (TryCheckInBiome(modName, "OceanCave"))
            {
                AddBiomeName(ref biomeNames, "Vanilla.Ocean", true);
            }
            if (TryCheckInBiome(modName, "Hive"))
            {
                AddBiomeName(ref biomeNames, "Vanilla.Beehive", true);
            }
            if (TryCheckInBiome(modName, "JungleTemple"))
            {
                AddBiomeName(ref biomeNames, "Vanilla.Temple", true);
            }
            if (TryCheckInBiome(modName, "MarbleCave"))
            {
                AddBiomeName(ref biomeNames, "Vanilla.Marble", true);
            }
            // Remnants-exclusive
            if (TryCheckInBiome(modName, "AerialGarden"))
            {
                AddBiomeName(ref biomeNames, "Remnants.AerialGarden");
            }
            if (TryCheckInBiome(modName, "EchoingHalls"))
            {
                AddBiomeName(ref biomeNames, "Remnants.EchoingHalls");
            }
            if (TryCheckInBiome(modName, "ForgottenTomb"))
            {
                AddBiomeName(ref biomeNames, "Remnants.Tomb");
            }
            if (TryCheckInBiome(modName, "Undergrowth"))
            {
                AddBiomeName(ref biomeNames, "Remnants.Undergrowth");
            }
            if (TryCheckInBiome(modName, "MagicalLab"))
            {
                AddBiomeName(ref biomeNames, "Remnants.MagicLab");
            }
        }

        private void AddSpiritBiomeNames(ref List<string> biomeNames)
        {
            string modName = "SpiritMod"; // Spirit Classic
            if (TryCheckInBiome(modName, "AsteroidBiome"))
            {
                AddBiomeName(ref biomeNames, "Spirit.Asteroid", true);
            }
            if (TryCheckInBiome(modName, "SpiritUndergroundBiome"))
            {
                AddBiomeName(ref biomeNames, "Spirit.Spirit", true);
            }
            else if (TryCheckInBiome(modName, "SpiritSurfaceBiome"))
            {
                AddBiomeName(ref biomeNames, "Spirit.Spirit", true);
            }
            if (TryCheckInBiome(modName, "BriarUndergroundBiome"))
            {
                AddBiomeName(ref biomeNames, "Spirit.Reach", true);
            }
            else if(TryCheckInBiome(modName, "BriarSurfaceBiome"))
            {
                AddBiomeName(ref biomeNames, "Spirit.Reach", true);
            }

            modName = "SpiritReforged"; // Spirit Reforged
            if (TryCheckInBiome(modName, "SavannaBiome"))
            {
                AddBiomeName(ref biomeNames, "Spirit.Savanna", true);
            }
        }

        private void AddStarsAboveBiomeNames(ref List<string> biomeNames)
        {
            string modName = "StarsAbove";
            if (TryCheckInBiome(modName, "ObservatoryBiome"))
            {
                AddBiomeName(ref biomeNames, "StarsAbove.Observatory", true);
            }
            if (TryCheckInBiome(modName, "AstarteDriverBiome"))
            {
                AddBiomeName(ref biomeNames, "StarsAbove.Astarte", true);
            }
            if (TryCheckInBiome(modName, "BleachedWorldBiome"))
            {
                AddBiomeName(ref biomeNames, "StarsAbove.Bleached", true);
            }
            if (TryCheckInBiome(modName, "CorvusBiome"))
            {
                AddBiomeName(ref biomeNames, "StarsAbove.Corvus", true);
            }
            if (TryCheckInBiome(modName, "LyraBiome"))
            {
                AddBiomeName(ref biomeNames, "StarsAbove.Lyra", true);
            }
            if (TryCheckInBiome(modName, "FriendlySpaceBiome"))
            {
                AddBiomeName(ref biomeNames, "StarsAbove.Pyxis", true);
            }
            if (TryCheckInBiome(modName, "MoonBiome"))
            {
                AddBiomeName(ref biomeNames, "StarsAbove.Moon", true);
            }
            if (TryCheckInBiome(modName, "SeaOfStarsBiome"))
            {
                AddBiomeName(ref biomeNames, "StarsAbove.StarSea", true);
            }
        }

        private void AddSpookyBiomeNames(ref List<string> biomeNames)
        {
            string modName = "Spooky";
            if (TryCheckInBiome(modName, "CatacombBiome"))
            {
                AddBiomeName(ref biomeNames, "Spooky.Catacomb", true);
            }
            if (TryCheckInBiome(modName, "SpookyBiomeUg"))
            {
                AddBiomeName(ref biomeNames, "Spooky.Spooky", true);
            }
            else if (TryCheckInBiome(modName, "SpookyHellBiome"))
            {
                AddBiomeName(ref biomeNames, "Spooky.Spooky", true);
            }
            else if (TryCheckInBiome(modName, "SpookyBiome"))
            {
                AddBiomeName(ref biomeNames, "Spooky.Spooky", true);
            }
        }

        private void AddVerdantBiomeNames(ref List<string> biomeNames)
        {
            string modName = "Verdant";
            if (TryCheckInBiome(modName, "VerdantUndergroundBiome"))
            {
                AddBiomeName(ref biomeNames, "Verdant.Verdant", true);
            }
            else if (TryCheckInBiome(modName, "VerdantBiome"))
            {
                AddBiomeName(ref biomeNames, "Verdant.Verdant", true);
            }
        }

        private void AddValhallaBiomeNames(ref List<string> biomeNames)
        {
            string modName = "ValhallaMod";
            if (TryCheckInBiome(modName, "TarBiome"))
            {
                AddBiomeName(ref biomeNames, "Valhalla.Tar");
            }
        }

        private void AddAvalonBiomeNames(ref List<string> biomeNames)
        {
            string modName = "Avalon";

            // The Dungeon
            if (TryCheckInBiome(modName, "DungeonAltColors"))
            {
                AddBiomeName(ref biomeNames, "Vanilla.Dungeon", true);
            }

            // Dungeons
            if (TryCheckInBiome(modName, "Hellcastle"))
            {
                AddBiomeName(ref biomeNames, "Avalon.Hellcastle");
            }
            else if (TryCheckInBiome(modName, "NearHellcastle"))
            {
                AddBiomeName(ref biomeNames, "Avalon.PhantomGardens");
            }
            if (TryCheckInBiome(modName, "SkyFortress"))
            {
                AddBiomeName(ref biomeNames, "Avalon.SkyFortress");
            }

            // Contagion
            if (TryCheckInBiome(modName, "ContagionDesert") || 
                TryCheckInBiome(modName, "ContagionCaveDesert"))
            {
                AddBiomeName(ref biomeNames, "Avalon.Contagion", true);
                AddBiomeName(ref biomeNames, "Vanilla.Desert", true);
            }
            if (TryCheckInBiome(modName, "UndergroundContagionIce"))
            {
                AddBiomeName(ref biomeNames, "Avalon.Contagion", true);
                AddBiomeName(ref biomeNames, "Vanilla.Snow", true);
            }
            if (TryCheckInBiome(modName, "UndergroundContagion") ||
                TryCheckInBiome(modName, "Contagion"))
            {
                AddBiomeName(ref biomeNames, "Avalon.Contagion", true);
            }

            // Savanna/Tropics
            if (TryCheckInBiome(modName, "TuhrtlOutpost"))
            {
                AddBiomeName(ref biomeNames, "Avalon.TuhrtlOutpost");
            }
            if (TryCheckInBiome(modName, "UndergroundTropics") 
                || TryCheckInBiome(modName, "Tropics"))
            {
                AddBiomeName(ref biomeNames, "Avalon.Tropics", true);
            }

            // Misc
            if (TryCheckInBiome(modName, "DarkMatter"))
            {
                AddBiomeName(ref biomeNames, "Avalon.DarkMatter");
            }
            if (TryCheckInBiome(modName, "CaesiumBlastplains"))
            {
                AddBiomeName(ref biomeNames, "Avalon.Blastplains");
            }
            if (TryCheckInBiome(modName, "BasaltObeliskBiome"))
            {
                AddBiomeName(ref biomeNames, "Avalon.BasaltObelisk");
            }
        }

        private void AddRiseOfAgesBiomeNames(ref List<string> biomeNames)
        {
            string modName = "RoA";
            if (TryCheckInBiome(modName, "BackwoodsBiome"))
            {
                AddBiomeName(ref biomeNames, "RiseOfAges.Backwoods");
            }
        }
        //

        private bool TryCheckInBiome(string modName, string biomeName)
        {
            if (ModLoader.TryGetMod(modName, out Mod mod))
            {
                if (mod.TryFind(biomeName, out ModBiome biome))
                {
                    return Player.InModBiome(biome);
                }
                
            }
            return false;
        }

        private static void AddBiomeName(ref List<string> biomeNames, string keySuffix, bool noDuplicates = false)
        {
            string localizationKey = "Mods.BInfoAcc.Biomes." + keySuffix;

            if(noDuplicates)
            {
                if(biomeNames.Contains(Language.GetTextValue(localizationKey)))
                {
                    return;
                }
            }

            biomeNames.Add(Language.GetTextValue(localizationKey));
        }

        private static void RemoveBiomeName(ref List<string> biomeNames, string keySuffix)
        {
            string localizationKey = "Mods.BInfoAcc.Biomes." + keySuffix;

            biomeNames.RemoveAll(name => name == Language.GetTextValue(localizationKey));
        }

        // Q.O.L. 3000 cross-mod
        public override void UpdateEquips()
        {
            bool crossModActive = false;
            if(ModLoader.TryGetMod("BlockQoL", out Mod BlockQoL) && BlockQoL.Call("BankPassivesActive") is bool bankPassives && bankPassives)
            {
                crossModActive = true;
            }
            if (ModLoader.HasMod("GlobalTrinkets")) // Also adds compatibility with Global Trinkets, which does the same thing
            {
                crossModActive = true;
            }
            if (ModLoader.HasMod("Fargowiltas")) // Also adds compatibility with Fargo's Mutant, which does the same thing
            {
                crossModActive = true;
            }

            if (!crossModActive)
            {
                return;
            }

            bool hasPDA = Player.HasItemInAnyInventory(ItemID.PDA) || Player.HasItemInAnyInventory(ItemID.CellPhone) ||
                Player.HasItemInAnyInventory(ItemID.ShellphoneDummy) || Player.HasItemInAnyInventory(ItemID.Shellphone) ||
                Player.HasItemInAnyInventory(ItemID.ShellphoneHell) || Player.HasItemInAnyInventory(ItemID.ShellphoneSpawn) || Player.HasItemInAnyInventory(ItemID.ShellphoneOcean);

            // Thorium Cross-Mod
            if (ModLoader.TryGetMod("ThoriumMod", out Mod thorium) && thorium.TryFind("WishingGlass", out ModItem wishingGlass)
                && Player.HasItemInAnyInventory(wishingGlass.Type))
            {
                hasPDA = true;
            }

            if(!ModContent.GetInstance<ConfigServer>().updatedPhones)
            {
                hasPDA = false;
            }

            if (hasPDA || Player.HasItemInAnyInventory(ModContent.ItemType<AttendanceLog>()) || Player.HasItemInAnyInventory(ModContent.ItemType<ScryingMirror>()))
            {
                minionDisplay = true;
            }
            if (hasPDA || Player.HasItemInAnyInventory(ModContent.ItemType<EngiRegistry>()) || Player.HasItemInAnyInventory(ModContent.ItemType<ScryingMirror>()))
            {
                sentryDisplay = true;
            }
            if (hasPDA || Player.HasItemInAnyInventory(ModContent.ItemType<FortuneMirror>()) || Player.HasItemInAnyInventory(ModContent.ItemType<ScryingMirror>()))
            {
                luckDisplay = true;
            }
            if (hasPDA || Player.HasItemInAnyInventory(ModContent.ItemType<SmartHeart>()) || Player.HasItemInAnyInventory(ModContent.ItemType<RSH>()))
            {
                regenDisplay = true;
            }
            if (hasPDA || Player.HasItemInAnyInventory(ModContent.ItemType<Magimeter>()) || Player.HasItemInAnyInventory(ModContent.ItemType<RSH>()))
            {
                manaDisplay = true;
            }
            if (hasPDA || Player.HasItemInAnyInventory(ModContent.ItemType<HitMarker>()) || Player.HasItemInAnyInventory(ModContent.ItemType<RSH>()))
            {
                comboDisplay = true;
            }
            if (hasPDA || Player.HasItemInAnyInventory(ModContent.ItemType<SafteyScanner>()) || Player.HasItemInAnyInventory(ModContent.ItemType<ThreatAnalyzer>()))
            {
                spawnRateDisplay = true;
            }
            if (hasPDA || Player.HasItemInAnyInventory(ModContent.ItemType<BiomeCrystal>()) || Player.HasItemInAnyInventory(ModContent.ItemType<ThreatAnalyzer>()))
            {
                biomeDisplay = true;
            }
            if (hasPDA || Player.HasItemInAnyInventory(ModContent.ItemType<WantedPoster>()) || Player.HasItemInAnyInventory(ModContent.ItemType<ThreatAnalyzer>()))
            {
                aggroDisplay = true;
            }
        }
    }
}


===== FILE: D:\TranslateTest2\BInfoAcc\Common\ItemShimmers.cs =====
using BInfoAcc.Content;
using Terraria.ID;
using Terraria.ModLoader;

namespace BInfoAcc.Common
{
    public class ItemShimmers : GlobalItem 
    {
        public override void SetStaticDefaults()
        {
            // Magic Mirror < > Fortune Mirror
            ItemID.Sets.ShimmerTransformToItem[ItemID.MagicMirror] = ModContent.ItemType<FortuneMirror>();
            ItemID.Sets.ShimmerTransformToItem[ModContent.ItemType<FortuneMirror>()] = ItemID.MagicMirror;

            // Band of Regeneration < > Smart Heart
            ItemID.Sets.ShimmerTransformToItem[ItemID.BandofRegeneration] = ModContent.ItemType<SmartHeart>();
            ItemID.Sets.ShimmerTransformToItem[ModContent.ItemType<SmartHeart>()] = ItemID.BandofRegeneration;

            // Forest Pylon < > Biome Crystal
            ItemID.Sets.ShimmerTransformToItem[ItemID.TeleportationPylonPurity] = ModContent.ItemType<BiomeCrystal>();
            ItemID.Sets.ShimmerTransformToItem[ModContent.ItemType<BiomeCrystal>()] = ItemID.TeleportationPylonPurity;
        }
    }
}


===== FILE: D:\TranslateTest2\BInfoAcc\Common\NPCShops.cs =====
﻿using BInfoAcc.Content;
using Terraria;
using Terraria.ID;
using Terraria.ModLoader;

namespace BInfoAcc.Common
{
	class BInfoAccShop : GlobalNPC
	{
		public override void ModifyShop(NPCShop shop)
		{
			if(shop.NpcType == NPCID.GoblinTinkerer)
            {
				shop.Add(ModContent.ItemType<EngiRegistry>());
            }
            if (shop.NpcType == NPCID.ArmsDealer)
            {
                shop.Add(ModContent.ItemType<WantedPoster>());
            }
            if (shop.NpcType == NPCID.SkeletonMerchant)
			{
                var safteyScannerCondition = new Condition("Mods.BInfoAcc.CommonItemtooltip.ScannerCondition", () => 
				Condition.EclipseOrBloodMoon.IsMet() || 
				((Condition.InRockLayerHeight.IsMet() || Condition.InDirtLayerHeight.IsMet() || Condition.InUnderworldHeight.IsMet()) && 
				(Condition.InUndergroundDesert.IsMet() || Condition.InSnow.IsMet() || Condition.InJungle.IsMet() || 
				Condition.InHallow.IsMet() || Condition.InCorrupt.IsMet() || Condition.InCrimson.IsMet()))
				);

				shop.Add(ModContent.ItemType<SafteyScanner>(),safteyScannerCondition);
			}

			if (shop.NpcType == NPCID.Merchant)
			{
				var merchantSalesCondition = new Condition("Mods.BInfoAcc.CommonItemtooltip.MerchantSaleCondition", () => ModContent.GetInstance<ConfigServer>().easySell);

				shop.Add(ModContent.ItemType<SmartHeart>(),new Condition("Mods.BInfoAcc.CommonItemtooltip.MerchantAccConditionG", () => 
														merchantSalesCondition.IsMet() && Condition.MoonPhaseWaningGibbous.IsMet()));
                shop.Add(ModContent.ItemType<Magimeter>(), new Condition("Mods.BInfoAcc.CommonItemtooltip.MerchantAccConditionG", () =>
                                                        merchantSalesCondition.IsMet() && Condition.MoonPhaseWaxingCrescent.IsMet()));
                shop.Add(ModContent.ItemType<HitMarker>(), new Condition("Mods.BInfoAcc.CommonItemtooltip.MerchantAccConditionG", () =>
                                                        merchantSalesCondition.IsMet() && Condition.MoonPhaseWaxingCrescent.IsMet()));


                shop.Add(ModContent.ItemType<AttendanceLog>(),new Condition("Mods.BInfoAcc.CommonItemtooltip.MerchantAccConditionQ", () =>
														merchantSalesCondition.IsMet() && Condition.MoonPhaseThirdQuarter.IsMet()));
				shop.Add(ModContent.ItemType<EngiRegistry>(),new Condition("Mods.BInfoAcc.CommonItemtooltip.MerchantAccConditionQ", () =>
														merchantSalesCondition.IsMet() && Condition.MoonPhaseFirstQuarter.IsMet()));
				shop.Add(ModContent.ItemType<FortuneMirror>(),new Condition("Mods.BInfoAcc.CommonItemtooltip.MerchantAccConditionQ", () =>
														merchantSalesCondition.IsMet() && Condition.MoonPhaseWaxingGibbous.IsMet()));


                shop.Add(ModContent.ItemType<SafteyScanner>(), new Condition("Mods.BInfoAcc.CommonItemtooltip.MerchantAccConditionC", () =>
                                                        merchantSalesCondition.IsMet() && Condition.MoonPhaseWaningCrescent.IsMet()));
                shop.Add(ModContent.ItemType<BiomeCrystal>(), new Condition("Mods.BInfoAcc.CommonItemtooltip.MerchantAccConditionC", () =>
                                                        merchantSalesCondition.IsMet() && Condition.MoonPhaseWaningCrescent.IsMet()));
                shop.Add(ModContent.ItemType<WantedPoster>(), new Condition("Mods.BInfoAcc.CommonItemtooltip.MerchantAccConditionC", () =>
                                                        merchantSalesCondition.IsMet() && Condition.MoonPhaseWaningCrescent.IsMet()));
            }
		}
    }
}



===== FILE: D:\TranslateTest2\BInfoAcc\Common\PhoneTweaks.cs =====
using BInfoAcc.Content;
using System.Collections.Generic;
using Terraria;
using Terraria.ID;
using Terraria.ModLoader;

namespace BInfoAcc.Common
{
    public class RecipeTweak : ModSystem
    {
        public override void PostAddRecipes()
        {
            if (!ModContent.GetInstance<ConfigServer>().extendedRecipe)
            {
                return;
            }
            for (int i = 0; i < Recipe.numRecipes; i++)
            {
                Recipe recipe = Main.recipe[i];

                if (recipe.HasIngredient(ItemID.GPS) && recipe.HasIngredient(ItemID.FishFinder) 
                    && recipe.HasIngredient(ItemID.GoblinTech) && recipe.HasIngredient(ItemID.REK)          
                    && recipe.HasTile(TileID.TinkerersWorkbench) 
                    && recipe.HasResult(ItemID.PDA)
                    && !recipe.HasIngredient<ScryingMirror>() && !recipe.HasIngredient<RSH>() && !recipe.HasIngredient<ThreatAnalyzer>())
                {
                    recipe.AddIngredient<ScryingMirror>();
                    recipe.AddIngredient<RSH>();
                    recipe.AddIngredient<ThreatAnalyzer>();
                }
            }
        }
    }

    public class PhoneTweaks : GlobalItem 
    {
        public override bool AppliesToEntity(Item entity, bool lateInstantiation)
        {
            if(entity.type == ItemID.PDA || entity.type == ItemID.CellPhone ||
               entity.type == ItemID.Shellphone || entity.type == ItemID.ShellphoneSpawn ||
               entity.type == ItemID.ShellphoneHell || entity.type == ItemID.ShellphoneOcean)
            {
                return true;
            }


            // Thorium Cross-Mod and support for The Depths's Shellphone variant 
            if (ModLoader.TryGetMod("ThoriumMod", out Mod thorium) && thorium.TryFind("WishingGlass", out ModItem wishingGlass)
                && entity.type == wishingGlass.Type)
            {
                return true;
            }
            if(ModLoader.TryGetMod("TheDepths", out Mod depths) && depths.TryFind("ShellPhoneDepths", out ModItem shellphoneDepths)
                && entity.type == shellphoneDepths.Type)
            {
                return true;
            }
            if (ModLoader.TryGetMod("Avalon", out Mod avalon))
            {
                List<int> phoneTypes = new List<int>();
                if(avalon.TryFind("ShadowPhoneHome", out ModItem sPhoneHome))
                {
                    phoneTypes.Add(sPhoneHome.Type);
                }
                if (avalon.TryFind("ShadowPhoneRandom", out ModItem sPhoneRand))
                {
                    phoneTypes.Add(sPhoneRand.Type);
                }
                if (avalon.TryFind("ShadowPhoneJungleTropics", out ModItem sPhoneJungle))
                {
                    phoneTypes.Add(sPhoneJungle.Type);
                }
                if (avalon.TryFind("ShadowPhoneHell", out ModItem sPhoneHell))
                {
                    phoneTypes.Add(sPhoneHell.Type);
                }
                if (avalon.TryFind("ShadowPhoneOcean", out ModItem sPhoneOcean))
                {
                    phoneTypes.Add(sPhoneOcean.Type);
                }
                if (avalon.TryFind("ShadowPhoneDungeon", out ModItem sPhoneDungeon))
                {
                    phoneTypes.Add(sPhoneDungeon.Type);
                }
                if (avalon.TryFind("ShadowPhoneSurface", out ModItem sPhoneSurface))
                {
                    phoneTypes.Add(sPhoneSurface.Type);
                }
                if (avalon.TryFind("ShadowPhoneNone", out ModItem sPhoneNone))
                {
                    phoneTypes.Add(sPhoneNone.Type);
                }


                if (phoneTypes.Contains(entity.type))
                {
                    return true;
                }
            }
            if (ModLoader.TryGetMod("MaddieQoL", out Mod completenessMod))
            {
                List<int> phoneTypes = new List<int>();
                if (completenessMod.TryFind("ShellphonePlusHome", out ModItem sPhonePlusHome))
                {
                    phoneTypes.Add(sPhonePlusHome.Type);
                }
                if (completenessMod.TryFind("ShellphonePlusRandomReturn", out ModItem sPhonePlusReturn))
                {
                    phoneTypes.Add(sPhonePlusReturn.Type);
                }
                if (completenessMod.TryFind("ShellphonePlusHell", out ModItem sPhonePlusHell))
                {
                    phoneTypes.Add(sPhonePlusHell.Type);
                }
                if (completenessMod.TryFind("ShellphonePlusOcean", out ModItem sPhonePlusOcean))
                {
                    phoneTypes.Add(sPhonePlusOcean.Type);
                }
                if (completenessMod.TryFind("ShellphonePlusSpawn", out ModItem sPhonePlusSpawn))
                {
                    phoneTypes.Add(sPhonePlusSpawn.Type);
                }
                if (completenessMod.TryFind("ShellphonePlusDummy", out ModItem sPhonePlusNone))
                {
                    phoneTypes.Add(sPhonePlusNone.Type);
                }
                if (completenessMod.TryFind("CellPhonePlus", out ModItem phonePlus))
                {
                    phoneTypes.Add(phonePlus.Type);
                }

                if (phoneTypes.Contains(entity.type))
                {
                    return true;
                }
            }
            if (ModLoader.TryGetMod("FargowiltasSouls", out Mod fargoSouls))
            {
                List<int> soulTypes = new List<int>();
                if (fargoSouls.TryFind("WorldShaperSoul", out ModItem worldSoul))
                {
                    soulTypes.Add(worldSoul.Type);
                }
                if (fargoSouls.TryFind("DimensionSoul", out ModItem dimentionSoul))
                {
                    soulTypes.Add(dimentionSoul.Type);
                }
                if (fargoSouls.TryFind("EternitySoul", out ModItem eternitySoul))
                {
                    soulTypes.Add(eternitySoul.Type);
                }


                if (soulTypes.Contains(entity.type))
                {
                    return true;
                }
            }

            return false;
        }

        public override void UpdateInfoAccessory(Item item, Player player)
        {
            if (!ModContent.GetInstance<ConfigServer>().updatedPhones)
            {
                return;
            }

            player.GetModPlayer<InfoPlayer>().comboDisplay = true;
            player.GetModPlayer<InfoPlayer>().regenDisplay = true;
            player.GetModPlayer<InfoPlayer>().spawnRateDisplay = true;
            player.GetModPlayer<InfoPlayer>().minionDisplay = true;
            player.GetModPlayer<InfoPlayer>().sentryDisplay = true;
            player.GetModPlayer<InfoPlayer>().luckDisplay = true;
            player.GetModPlayer<InfoPlayer>().biomeDisplay = true;
            player.GetModPlayer<InfoPlayer>().aggroDisplay = true;
            player.GetModPlayer<InfoPlayer>().manaDisplay = true;
        }
    }
}


===== FILE: D:\TranslateTest2\BInfoAcc\Content\AttendanceLog.cs =====
using BInfoAcc.Common;
using Terraria;
using Terraria.ID;
using Terraria.ModLoader;

namespace BInfoAcc.Content
{
	public class AttendanceLog : ModItem
	{
		public override void SetDefaults()
		{
			Item.width = 16;
			Item.height = 16;
			Item.accessory = true;
			Item.rare = ItemRarityID.Blue;
			Item.value = Item.buyPrice(0, 5, 0, 0);
		}

		public override void UpdateInfoAccessory(Player player)
		{
			player.GetModPlayer<InfoPlayer>().minionDisplay = true;
		}

		public override void AddRecipes()
		{
			CreateRecipe()
				.AddIngredient(ItemID.Book)
				.AddIngredient(ItemID.BlackInk)
				.AddIngredient(ItemID.Gel, 20)
				.AddTile(TileID.Chairs)
				.AddTile(TileID.Tables)
				.Register();

			// Alt. recipe using black paint
            CreateRecipe()
                .AddIngredient(ItemID.Book)
                .AddIngredient(ItemID.BlackPaint, 10)
                .AddIngredient(ItemID.Gel, 20)
                .AddTile(TileID.Chairs)
                .AddTile(TileID.Tables)
                .Register();
        }
	}
}


===== FILE: D:\TranslateTest2\BInfoAcc\Content\BiomeCrystal.cs =====
using BInfoAcc.Common;
using Terraria;
using Terraria.ID;
using Terraria.ModLoader;

namespace BInfoAcc.Content
{
	public class BiomeCrystal : ModItem
	{
		public override void SetDefaults()
		{
			Item.width = 16;
			Item.height = 16;
			Item.accessory = true;
			Item.rare = ItemRarityID.Blue;
			Item.value = Item.buyPrice(0, 5, 0, 0);
		}

		public override void UpdateInfoAccessory(Player player)
		{
			player.GetModPlayer<InfoPlayer>().biomeDisplay = true;
		}
	}
}


===== FILE: D:\TranslateTest2\BInfoAcc\Content\EngiRegistry.cs =====
using BInfoAcc.Common;
using Terraria;
using Terraria.ID;
using Terraria.ModLoader;

namespace BInfoAcc.Content
{
	public class EngiRegistry : ModItem
	{
		public override void SetDefaults()
		{
			Item.width = 16;
			Item.height = 16;
			Item.accessory = true;
			Item.rare = ItemRarityID.Blue;
			Item.value = Item.buyPrice(0, 5, 0, 0);
		}

		public override void UpdateInfoAccessory(Player player)
		{
			player.GetModPlayer<InfoPlayer>().sentryDisplay = true;
		}
	}
}


===== FILE: D:\TranslateTest2\BInfoAcc\Content\FortuneMirror.cs =====
using BInfoAcc.Common;
using Terraria;
using Terraria.ID;
using Terraria.ModLoader;

namespace BInfoAcc.Content
{
	public class FortuneMirror : ModItem
	{
		public override void SetDefaults()
		{
			Item.width = 16;
			Item.height = 16;
			Item.accessory = true;
			Item.rare = ItemRarityID.Blue;
			Item.value = Item.buyPrice(0, 5, 0, 0);
		}

        public override void UpdateAccessory(Player player, bool hideVisual)
        {
			player.equipmentBasedLuckBonus += 0.05f;
		}

        public override void UpdateInfoAccessory(Player player)
		{
			player.GetModPlayer<InfoPlayer>().luckDisplay = true;
		}
	}
}


===== FILE: D:\TranslateTest2\BInfoAcc\Content\HitMarker.cs =====
using BInfoAcc.Common;
using Terraria;
using Terraria.ID;
using Terraria.ModLoader;

namespace BInfoAcc.Content
{
	public class HitMarker : ModItem
	{
		public override void SetDefaults()
		{
			Item.width = 16;
			Item.height = 16;
			Item.accessory = true;
			Item.rare = ItemRarityID.Blue;
			Item.value = Item.buyPrice(0, 5, 0, 0);
		}

		public override void UpdateInfoAccessory(Player player)
		{
			player.GetModPlayer<InfoPlayer>().comboDisplay = true;
		}

		public override void AddRecipes()
		{
			CreateRecipe()
				.AddIngredient(ItemID.CopperWatch)
				.AddIngredient(ItemID.Lens , 3)
				.AddIngredient(ItemID.DemoniteBar, 5)
				.AddTile(TileID.Anvils)
				.AddDecraftCondition(Condition.CorruptWorld)
				.Register();

			CreateRecipe()
				.AddIngredient(ItemID.TinWatch)
				.AddIngredient(ItemID.Lens, 3)
				.AddIngredient(ItemID.DemoniteBar, 5)
				.AddTile(TileID.Anvils)
				.AddDecraftCondition(Condition.CorruptWorld)
				.Register();

			CreateRecipe()
				.AddIngredient(ItemID.CopperWatch)
				.AddIngredient(ItemID.Lens, 3)
				.AddIngredient(ItemID.CrimtaneBar, 5)
				.AddTile(TileID.Anvils)
				.AddDecraftCondition(Condition.CrimsonWorld)
				.Register();

			CreateRecipe()
				.AddIngredient(ItemID.TinWatch)
				.AddIngredient(ItemID.Lens, 3)
				.AddIngredient(ItemID.CrimtaneBar, 5)
				.AddTile(TileID.Anvils)
				.AddDecraftCondition(Condition.CrimsonWorld)
				.Register();
		}
	}
}


===== FILE: D:\TranslateTest2\BInfoAcc\Content\Magimeter.cs =====
using BInfoAcc.Common;
using Terraria;
using Terraria.ID;
using Terraria.ModLoader;

namespace BInfoAcc.Content
{
	public class Magimeter : ModItem
	{
		public override void SetDefaults()
		{
			Item.width = 16;
			Item.height = 16;
			Item.accessory = true;
			Item.rare = ItemRarityID.Blue;
			Item.value = Item.buyPrice(0, 5, 0, 0);
		}

		public override void UpdateInfoAccessory(Player player)
		{
			player.GetModPlayer<InfoPlayer>().manaDisplay = true;
		}

		public override void AddRecipes()
		{
			CreateRecipe()
				.AddIngredient(ItemID.ManaCrystal)
				.AddIngredient(ItemID.Glass , 10)
				.AddIngredient(ItemID.GoldBar, 10)
                .AddIngredient(ItemID.Diamond)
                .AddTile(TileID.WorkBenches)
				.Register();

			CreateRecipe()
				.AddIngredient(ItemID.ManaCrystal)
                .AddIngredient(ItemID.Glass, 10)
                .AddIngredient(ItemID.PlatinumBar, 10)
                .AddIngredient(ItemID.Diamond)
                .AddTile(TileID.WorkBenches)
				.Register();
		}
	}
}


===== FILE: D:\TranslateTest2\BInfoAcc\Content\RSH.cs =====
using BInfoAcc.Common;
using Terraria;
using Terraria.ID;
using Terraria.ModLoader;

namespace BInfoAcc.Content
{
	public class RSH : ModItem
	{
		public override void SetDefaults()
		{
			Item.width = 16;
			Item.height = 16;
			Item.accessory = true;
			Item.rare = ItemRarityID.Orange;
			Item.value = Item.buyPrice(0, 15, 0, 0);
		}

		public override void UpdateInfoAccessory(Player player)
		{
			player.GetModPlayer<InfoPlayer>().comboDisplay = true;
			player.GetModPlayer<InfoPlayer>().regenDisplay = true;
			player.GetModPlayer<InfoPlayer>().manaDisplay = true;
		}

		public override void AddRecipes()
		{
			CreateRecipe()	
				.AddIngredient<HitMarker>()
				.AddIngredient<SmartHeart>()
                .AddIngredient<Magimeter>()
                .AddTile(TileID.TinkerersWorkbench)
				.Register();
		}
	}
}


===== FILE: D:\TranslateTest2\BInfoAcc\Content\SafteyScanner.cs =====
using BInfoAcc.Common;
using Microsoft.Xna.Framework;
using System.Collections.Generic;
using Terraria;
using Terraria.ID;
using Terraria.Localization;
using Terraria.ModLoader;

namespace BInfoAcc.Content
{
	public class SafteyScanner : ModItem
	{
		public override void SetDefaults()
		{
			Item.width = 16;
			Item.height = 16;
			Item.accessory = true;
			Item.rare = ItemRarityID.Blue;
			Item.value = Item.buyPrice(0, 5, 0, 0);
		}

		public override void UpdateInfoAccessory(Player player)
		{
			player.GetModPlayer<InfoPlayer>().spawnRateDisplay = true;
		}

        public override void ModifyTooltips(List<TooltipLine> tooltips)
        {
            if(Main.netMode == NetmodeID.MultiplayerClient)
			{
				tooltips.Add(new TooltipLine(Mod, "MultiplayerError", Language.GetTextValue("Mods.BInfoAcc.CommonItemtooltip.BrokenSpawnRate")) 
				{ OverrideColor = new Color(190, 120, 120) });
			}
        }
    }
}


===== FILE: D:\TranslateTest2\BInfoAcc\Content\ScryingMirror.cs =====
using BInfoAcc.Common;
using Terraria;
using Terraria.ID;
using Terraria.ModLoader;

namespace BInfoAcc.Content
{
	public class ScryingMirror : ModItem
	{
		public override void SetDefaults()
		{
			Item.width = 16;
			Item.height = 16;
			Item.accessory = true;
			Item.rare = ItemRarityID.Orange;
			Item.value = Item.buyPrice(0, 15, 0, 0);
		}

		public override void UpdateInfoAccessory(Player player)
		{
			player.GetModPlayer<InfoPlayer>().minionDisplay = true;
			player.GetModPlayer<InfoPlayer>().sentryDisplay = true;
			player.GetModPlayer<InfoPlayer>().luckDisplay = true;
		}

		public override void AddRecipes()
		{
			CreateRecipe()
				.AddIngredient<FortuneMirror>()
				.AddIngredient<AttendanceLog>()
				.AddIngredient<EngiRegistry>()
				.AddTile(TileID.TinkerersWorkbench)
				.Register();
		}
	}
}


===== FILE: D:\TranslateTest2\BInfoAcc\Content\SmartHeart.cs =====
using BInfoAcc.Common;
using Terraria;
using Terraria.ID;
using Terraria.ModLoader;

namespace BInfoAcc.Content
{
	public class SmartHeart : ModItem
	{
		public override void SetDefaults()
		{
			Item.width = 16;
			Item.height = 16;
			Item.accessory = true;
			Item.rare = ItemRarityID.Blue;
			Item.value = Item.buyPrice(0, 5, 0, 0);
		}

		public override void UpdateInfoAccessory(Player player)
		{
			player.GetModPlayer<InfoPlayer>().regenDisplay = true;
		}
	}
}


===== FILE: D:\TranslateTest2\BInfoAcc\Content\ThreatAnalyzer.cs =====
using BInfoAcc.Common;
using Terraria;
using Terraria.ID;
using Terraria.ModLoader;

namespace BInfoAcc.Content
{
	public class ThreatAnalyzer : ModItem
	{
		public override void SetDefaults()
		{
			Item.width = 16;
			Item.height = 16;
			Item.accessory = true;
			Item.rare = ItemRarityID.Orange;
			Item.value = Item.buyPrice(0, 15, 0, 0);
		}

		public override void UpdateInfoAccessory(Player player)
		{
			player.GetModPlayer<InfoPlayer>().biomeDisplay = true;
			player.GetModPlayer<InfoPlayer>().spawnRateDisplay = true;
			player.GetModPlayer<InfoPlayer>().aggroDisplay = true;
		}

		public override void AddRecipes()
		{
			CreateRecipe()
				.AddIngredient<SafteyScanner>()
				.AddIngredient<BiomeCrystal>()
				.AddIngredient<WantedPoster>()
				.AddTile(TileID.TinkerersWorkbench)
				.Register();
		}
	}
}


===== FILE: D:\TranslateTest2\BInfoAcc\Content\WantedPoster.cs =====
using BInfoAcc.Common;
using Terraria;
using Terraria.ID;
using Terraria.ModLoader;

namespace BInfoAcc.Content
{
	public class WantedPoster : ModItem
	{
		public override void SetDefaults()
		{
			Item.width = 16;
			Item.height = 16;
			Item.accessory = true;
			Item.rare = ItemRarityID.Blue;
			Item.value = Item.buyPrice(0, 5, 0, 0);
		}

		public override void UpdateInfoAccessory(Player player)
		{
			player.GetModPlayer<InfoPlayer>().aggroDisplay = true;
		}
	}
}


===== FILE: D:\TranslateTest2\BInfoAcc\Localization\en-US_Mods.BInfoAcc.hjson =====
CommonItemtooltip: {
	ScannerCondition: During Blood Moon or Eclipse, or in an underground biome varaiant
	MerchantSaleCondition: Enabled in config
	MerchantAccConditionG: "{$CommonItemtooltip.MerchantSaleCondition} & Gibbous Moon"
	MerchantAccConditionQ: "{$CommonItemtooltip.MerchantSaleCondition} & Quarter Moon"
	MerchantAccConditionC: "{$CommonItemtooltip.MerchantSaleCondition} & Crescent Moon"
	LuckDisplay: "{0} Luck"
	MinionDisplay: "{0}/{1} Minion Slots occupied"
	SentryDisplay: "{0}/{1} Sentry Slots occupied"
	RegenDisplayFull: Full Life
	RegenDisplayPos: +{0} life per second
	RegenDisplayNeg: "{0} life per second"
	SpawnRateDisplayS: "{0} spawn per second"
	SpawnRateDisplayP: "{0} spawns per second"
	SpawnCapDisplay: "{0}-enemy spawn limit"
	SpawnRateDisplayError: ERROR: Extremely high/low spawn rate!
	ComboDisplayNone: No combo
	ComboDisplayTime: "{0} hits (Duration: {1})"
	ComboDisplayDmg: "{0} hits (Total dmg: {1})"
	ComboError: ERROR: Value overflow
	AggroDisplay: "{0} Aggro"
	ManaDisplayFull: Full Mana
	ManaDisplayPos: +{0} mana per second
	ManaDisplayNeg: "{0} mana per second"
	SuffixThousand: " K"
	SuffixMillion: " Mil"
	SuffixBillion: " Bil"
	SuffixSeconds: " secs"
	SuffixMinutes: " mins"
	SuffixHours: " hrs"
	BrokenSpawnRate: Warning: Spawn rate/limit tracking is currently broken in multiplayer!
}

Biomes: {
	Neutral: N/A

	Vanilla: {
		Space: Space
		Underworld: Underworld
		Underground: Underground
		Solar: Solar Pillar
		Vortex: Vortex Pillar
		Nebula: Nebula Pillar
		Stardust: Stardust Pillar
		Meteor: Meteorite
		Dungeon: Dungeon
		Temple: Jungle Temple
		Aether: Aether
		Spider: Spider Nest
		Corruption: Corruption
		Crimson: Crimson
		Shroom: Glowing Mushrooms
		Jungle: Jungle
		Hallow: Hallow
		Ocean: Ocean
		Snow: Snow
		Desert: Desert
		Beehive: Bee Hive
		Granite: Granite Cave
		Marble: Marble Cave
		Graveyard: Graveyard
		Forest: Forest
		Town: Town
	}

	Thorium.Depths: Aquatic Depths

	Calamity: {
		Astral: Astral Infection
		Crags: Brimstone Crags
		SulphurousSea: Sulphurous Sea
		SunkenSea: Sunken Sea
		AbyssMain: The Abyss
		Abyss1: Sulphuric Depths
		Abyss2: Murky Waters
		Abyss3: Thermal Vents
		Abyss4: The Void
	}

	Redemption: {
		Lab: Abandoned Labratory
		Soulless: Soulless Caverns
		Wasteland: Wasteland
	}

	Aequus.Crevice: Crab Crevice
	Confection.Confection: Confection

	FFF: {
		Celestial: Celestial
		Garden: Garden
	}

	Avalon: {
		PhantomGardens: Phantom Gardens
		Hellcastle: Hellcastle
		Blastplains: Caesium Blastplains
		Contagion: Contagion
		AshenOvergrowth: Ashen Overgrowth
		SkyFortress: Sky Fortress
		DarkMatter: Dark Matter
		Tropics: Savanna
		TuhrtlOutpost: Tuhrtl Outpost
		BasaltObelisk: Basalt Obelisk
	}

	Spirit: {
		Reach: Briar
		Spirit: Spirit
		Asteroid: Asteroid Field
		Savanna: Savanna
	}

	StarsAbove: {
		Observatory: Observatory Hyperborea
		Astarte: Astarte Driver
		Bleached: Bleached World
		Corvus: Corvus
		Lyra: Lyra
		Pyxis: Pyxis
		Moon: Moon
		StarSea: Sea of Stars
	}

	Depths.Depths: Depths

	Spooky: {
		Spooky: Spooky
		Catacomb: Catacombs
	}

	Verdant.Verdant: Verdant
	Valhalla.Tar: Tar Cavern

	Remnants: {
		Undergrowth: Undergrowth
		MagicLab: Magical Lab
		Tomb: Forgotten Tomb
		AerialGarden: Aerial Garden
		EchoingHalls: Echoing Halls
	}

	RiseOfAges.Backwoods: Backwoods
}

Items: {
	EngiRegistry: {
		DisplayName: Engineer's Registry
		Tooltip:
			'''
			Displays the amount of Sentry Slots you have and how many are occupied
			'Engi-nearing your (sentry) limit'
			'''
	}

	AttendanceLog: {
		DisplayName: Attendance Log
		Tooltip: Displays the amount of Minion Slots you have and how many are occupied
	}

	FortuneMirror: {
		DisplayName: Fortune Mirror
		Tooltip: Displays luck
	}

	HitMarker: {
		DisplayName: Hit Marker
		Tooltip:
			'''
			Displays the hit count, duration, and total damage of combos
			Combos consist of hits you've landed consecutivley within 3 seconds of eachother
			'''
	}

	RSH: {
		DisplayName: C.R.M. Counter
		Tooltip: Displays combo, life regen, and mana economy
	}

	SafteyScanner: {
		DisplayName: Safety Scanner
		Tooltip: Displays the spawn rate of enemies
	}

	ScryingMirror: {
		DisplayName: Scrying Mirror
		Tooltip: Displays luck, minion slots, and sentry slots
	}

	SmartHeart: {
		DisplayName: Smart Heart
		Tooltip:
			'''
			Displays life regeneration and/or loss
			'Make sure to get your steps in'
			'''
	}

	BiomeCrystal: {
		DisplayName: Biome Crystal
		Tooltip: Displays the biome(s) you are located in
	}

	Magimeter: {
		DisplayName: Magimeter
		Tooltip: Displays mana regeneration, or usage when using mana-consuming items
	}

	WantedPoster: {
		DisplayName: Wanted Poster
		Tooltip:
			'''
			Displays aggro, which determines how likely enemies are to target you
			'They didn't even bother with the "or alive" part...'
			'''
	}

	ThreatAnalyzer: {
		DisplayName: Threat Analyzer
		Tooltip: Displays spawn rate, aggro, and biome(s)
	}
}

InfoDisplays: {
	# Sentry Count
	InfoDisplay8.DisplayName: Sentries
	# Minion Count
	InfoDisplay7.DisplayName: Minions
	# Luck
	InfoDisplay0.DisplayName: Luck
	# Spawn Rate/Limit
	InfoDisplay3.DisplayName: Spawn Rate
	# Life Regeneration
	InfoDisplay1.DisplayName: Life Regen
	# 'Combo'
	InfoDisplay6.DisplayName: Combo
	# Biomes
	InfoDisplay4.DisplayName: Nearby Biome(s)
	# Aggro
	InfoDisplay5.DisplayName: Aggro
	# Mana Economy
	InfoDisplay2.DisplayName: Mana Economy
}

Configs: {
	ConfigServer: {
		DisplayName: Main Config

		easySell: {
			Label: Merchant sells new info accessories
			Tooltip:
				'''
				When set to true, the Merchant will sell this mod's info accessories based on moon phase
				Good for if you want an easy way to obtain the new info displays
				'''
		}

		extendedRecipe: {
			Label: Add new accessories to PDA recipe
			Tooltip:
				'''
				Toggles if the PDA's recipe is overriden to require the Scrying Mirror, C.R.M. Counter, and Threat Analyzer from this mod
				If you don't want to jump through more hoops for your celluar device, then try turning this off
				'''
		}

		updatedPhones: {
			Label: Enable new info displays on PDA, Cell Phone, and Shellphone
			Tooltip:
				'''
				Determines if the PDA and its upgrades inherit the new info displays from this mod
				Also supports the Wishing Glass item from the Thorium Mod
				'''
		}

		refreshRate: {
			Label: Info Refresh Rate
			Tooltip:
				'''
				Certain info displays (Spawn Rate/Cap, and Biome) don't refresh their info every frame
				This is to prevent flickering text, and to reduce the potential for lag
				The delay between updates can be customized here; the value set is the amount of ticks between each update
				For reference, 1 second = 60 seconds
				'''
		}

		cycleRate: {
			Label: Info Display Cycle Rate
			Tooltip:
				'''
				Certain info displays (Spawn Rate/Cap, Combo, and Biome) have multiple lines of info they dispaly in a cycle
				This behavior is similar to that of the vanilla Weather Radio whilst a sandstorm is active
				This setting multiplies the speed of different info lines cycling
				'''
		}

		prioModBiomes: {
			Label: Biome Display Prioritizes Mod Biomes
			Tooltip:
				'''
				Causes the biome display to display (supported) modded biomes before (most) vanilla biomes
				All nearby biomes will still be cycled through; higher priority biomes are displayed earlier in the cycle
				Biome dispaly supprots the below mods:
				'Thorium Mod', 'Calamity Mod', 'Mod of Redemption', 'Exxo Avalon Origins' 'The Stars Above', 'Spirit Mod', 'Spooky Mod', 
				'Confection Rebaked', 'The Depths', 'Aequus', 'Verdant', 'Food, Furniture & Fun', and 'Remnants'
				'''
		}

		simpleDisplay: {
			Label: Simplified Displays
			Tooltip:
				'''
				Removes some extra symbols from certain displays, namely the "+" that appears on displays that alternate between multiple lines of info
				Also gets rid of the "~" (Shorthand for "approximately") in front of the Spawn Rate/Limit display
				Affects Biome, Combo, and Spawn Rate/Limit displays
				'''
		}
	}
}



===== FILE: D:\TranslateTest2\BInfoAcc\Localization\ja-JP_Mods.BInfoAcc.hjson =====
CommonItemtooltip: {
    ScannerCondition: ブラッドムーンまたは日食の間、または地下バイオームのバリエーション内
    MerchantSaleCondition: 設定で有効化されている場合
    MerchantAccConditionG: "{$CommonItemtooltip.MerchantSaleCondition} & 上弦の月"
    MerchantAccConditionQ: "{$CommonItemtooltip.MerchantSaleCondition} & 半月"
    MerchantAccConditionC: "{$CommonItemtooltip.MerchantSaleCondition} & 三日月"
    LuckDisplay: "{0} 運"
    MinionDisplay: "{0}/{1} ミニオンスロット使用中"
    SentryDisplay: "{0}/{1} セントリースロット使用中"
    RegenDisplayFull: ライフ満タン
    RegenDisplayPos: "+{0} ライフ/秒"
    RegenDisplayNeg: "{0} ライフ/秒"
    SpawnRateDisplayS: "{0} スポーン/秒"
    SpawnRateDisplayP: "{0} スポーン/秒"
    SpawnCapDisplay: "{0}体までの敵スポーン上限"
    SpawnRateDisplayError: エラー：敵の出現率が極端に高/低すぎます！
    ComboDisplayNone: コンボなし
    ComboDisplayTime: "{0} ヒット（持続時間：{1}）"
    ComboDisplayDmg: "{0} ヒット（合計ダメージ：{1}）"
    ComboError: エラー：値がオーバーフロー
    AggroDisplay: "{0} 注目度"
    ManaDisplayFull: マナ満タン
    ManaDisplayPos: "+{0} マナ/秒"
    ManaDisplayNeg: "{0} マナ/秒"
    SuffixThousand: " 千"
    SuffixMillion: " 百万"
    SuffixBillion: " 十億"
    SuffixSeconds: " 秒"
    SuffixMinutes: " 分"
    SuffixHours: " 時間"
    BrokenSpawnRate: 警告：マルチプレイヤーでの出現率/上限の追跡が現在壊れています！
}

Biomes: {
    Neutral: なし

    Vanilla: {
        Space: 宇宙
        Underworld: 地下世界
        Underground: 地下
        Solar: ソーラーピラー
        Vortex: ボルテックスピラー
        Nebula: ネビュラピラー
        Stardust: スターダストピラー
        Meteor: 隕石
        Dungeon: ダンジョン
        Temple: ジャングル寺院
        Aether: エーテル
        Spider: クモの巣
        Corruption: 不浄の地
        Crimson: 真紅の地
        Shroom: キノコ群生地
        Jungle: ジャングル
        Hallow: 聖域
        Ocean: 海
        Snow: 雪原
        Desert: 砂漠
        Beehive: ハチの巣
        Granite: 御影石の洞窟
        Marble: 大理石の洞窟
        Graveyard: 墓地
        Forest: 森林
        Town: 町
    }

    Thorium.Depths: アクアティックデプス

    Calamity: {
        Astral: アストラル感染
        Crags: ブリムストーンクラッグス
        SulphurousSea: 硫黄の海
        SunkenSea: 沈んだ海
        AbyssMain: 深淵
        Abyss1: サルファラスデプス
        Abyss2: 濁った水域
        Abyss3: サーマルベント
        Abyss4: 虚空
    }

    Redemption: {
        Lab: 廃棄された研究所
        Soulless: ソウルレスキャバーン
        Wasteland: 荒れ地
    }

    Aequus.Crevice: クラブクリーヴィス
    Confection.Confection: コンフェクション

    FFF: {
        Celestial: セレスティアル
        Garden: ガーデン
    }

    Avalon: {
        PhantomGardens: ファントムガーデン
        Hellcastle: ヘルキャッスル
        Blastplains: セシウムブラストプレイン
        Contagion: コンタジョン
        AshenOvergrowth: アシェンオーバーグロース
        SkyFortress: スカイフォートレス
        DarkMatter: ダークマター
        Tropics: サバンナ
        TuhrtlOutpost: タートルアウトポスト
        BasaltObelisk: バサルトオベリスク
    }

    Spirit: {
        Reach: ブライア
        Spirit: スピリット
        Asteroid: 小惑星フィールド
        Savanna: サバンナ
    }

    StarsAbove: {
        Observatory: オブザーバトリーハイパーボレア
        Astarte: アスタルテドライバー
        Bleached: ブリーチドワールド
        Corvus: コルヴス
        Lyra: リラ
        Pyxis: ピクシス
        Moon: 月
        StarSea: 星の海
    }

    Depths.Depths: デプス

    Spooky: {
        Spooky: スプーキー
        Catacomb: カタコンベ
    }

    Verdant.Verdant: ヴァーダント
    Valhalla.Tar: タールキャバーン
}

Items: {
    EngiRegistry: {
        DisplayName: エンジニアのレジストリ
        Tooltip:
            '''
            使用中のセントリースロットの数と合計数を表示する
            「セントリーの限界に近付いている‥」
            '''
    }

    AttendanceLog: {
        DisplayName: 召喚ログ
        Tooltip: 使用中のミニオンスロットの数と合計数を表示する
    }

    FortuneMirror: {
        DisplayName: フォーチュンミラー
        Tooltip: 運を表示する
    }

    HitMarker: {
        DisplayName: ヒットマーカー
        Tooltip:
            '''
            コンボのヒット数、持続時間、合計ダメージを表示する
            コンボは3秒以内に連続して命中したヒットで構成される
            '''
    }

    RSH: {
        DisplayName: C.R.M.カウンター
        Tooltip: コンボ、ライフ自然回復率、マナ消費率を表示する
    }

    SafteyScanner: {
        DisplayName: セーフティスキャナー
        Tooltip: 敵の出現率を表示する
    }

    ScryingMirror: {
        DisplayName: スクライングミラー
        Tooltip: 運、ミニオンスロット、セントリースロットを表示する
    }

    SmartHeart: {
        DisplayName: スマートハート
        Tooltip:
            '''
            ライフ自然回復率または減少率を表示する
            「しっかり歩数を稼いでね！」
            '''
    }

    BiomeCrystal: {
        DisplayName: バイオームクリスタル
        Tooltip: 現在いるバイオームを表示する
    }

    Magimeter: {
        DisplayName: マジメーター
        Tooltip: マナを消費するアイテム使用時のマナ再生または消費を表示する
    }

    WantedPoster: {
        DisplayName: 指名手配ポスター
        Tooltip:
            '''
            注目度を表示する
            注目度は敵があなたをターゲットにする可能性を示す
            「「生け捕り」という選択肢は、初めから無かったらしい…」
            '''
    }

    ThreatAnalyzer: {
        DisplayName: 脅威検出器
        Tooltip: 敵の出現率、注目度、バイオームを表示する
    }
}

InfoDisplays: {
    # セントリー数
    InfoDisplay8.DisplayName: セントリー
    # ミニオン数
    InfoDisplay7.DisplayName: ミニオン
    # 運
    InfoDisplay0.DisplayName: 運
    # スポーンレート/制限
    InfoDisplay3.DisplayName: 敵の出現率
    # ライフ再生
    InfoDisplay1.DisplayName: ライフ自然回復率
    # 「コンボ」
    InfoDisplay6.DisplayName: コンボ
    # バイオーム
    InfoDisplay4.DisplayName: 近くのバイオーム
    # アグロ
    InfoDisplay5.DisplayName: 注目度
    # マナ経済
    InfoDisplay2.DisplayName: マナ消費率
}

Configs: {
    ConfigServer: {
        DisplayName: 基本設定

        easySell: {
            Label: 商人が新しい情報アクセサリーを販売
            Tooltip:
                '''
                trueに設定すると、商人は月の位相に基づいてこのMODの情報アクセサリーを販売します
                新しい情報ディスプレイを簡単に取得したい場合に便利です
                '''
        }

        extendedRecipe: {
            Label: PDAのレシピに新しいアクセサリーを追加
            Tooltip:
                '''
                このMODのスクライングミラー、C.R.M.カウンター、脅威検出器をPDAのレシピに必要とするかどうかを切り替えます
                携帯デバイスに余計な手間をかけたくない場合は、これをオフにしてください
                '''
        }

        updatedPhones: {
            Label: PDA、携帯電話、シェルフォンで新しい情報ディスプレイを有効化
            Tooltip:
                '''
                PDAとそのアップグレードがこのMODの新しい情報ディスプレイを継承するかどうかを決定します
                Thorium Modのウィッシンググラスアイテムもサポートしています
                '''
        }

        refreshRate: {
            Label: 情報更新レート
            Tooltip:
                '''
                特定の情報ディスプレイ（敵の出現率/上限、バイオーム）は毎フレーム情報を更新しません
                これはテキストのちらつきを防ぎ、潜在的なラグを軽減するためです
                ここで更新間の遅延をカスタマイズできます。設定値は各更新間のティックの数です
                参考：1秒 = 60ティック
                '''
        }

        cycleRate: {
            Label: 情報ディスプレイのサイクルレート
            Tooltip:
                '''
                特定の情報ディスプレイ（敵の出現率/上限、コンボ、バイオーム）は複数の情報をサイクルで表示します
                この動作は、砂嵐中のバニラの天気ラジオと似ています
                この設定は、異なる情報のサイクル速度を倍にします
                '''
        }

        prioModBiomes: {
            Label: バイオームディスプレイがMODバイオームを優先
            Tooltip:
                '''
                バイオームディスプレイが（サポートされている）MODのバイオームを（ほとんどの）バニラバイオームより先に表示するようにします
                すべての近くのバイオームは引き続きサイクルされますが、優先度の高いバイオームがサイクルの早い段階で表示されます
                バイオームディスプレイは以下のMODをサポートしています：
                「Thorium Mod」「Calamity Mod」「Mod of Redemption」「Exxo Avalon Origins」「The Stars Above」「Spirit Mod」「Spooky Mod」
                「Confection Rebaked」「The Depths」「Aequus」「Verdant」「Food, Furniture & Fun」「Remnants」
                '''
        }

        simpleDisplay: {
            Label: 簡易ディスプレイ
            Tooltip:
                '''
                特定のディスプレイから余計な記号を削除します。具体的には、複数の情報を切り替えるディスプレイの「+」記号を削除します
                また、敵の出現率/上限ディスプレイの「~」（「おおよそ」の略）を削除します
                バイオーム、コンボ、敵の出現率/上限ディスプレイに影響します
                '''
        }
    }
}


===== FILE: D:\TranslateTest2\Commands\DeepLCommand.cs =====
using System;
using Terraria;
using Terraria.ModLoader;
using TranslateTest2.Core;
using TranslateTest2.Config;

namespace TranslateTest2.Commands
{
    public class DeepLCommand : ModCommand
    {
        public override CommandType Type => CommandType.Chat;
        public override string Command => "deepl";
        public override string Usage => "/deepl status | /deepl test <text>";
        public override string Description => "DeepLの状態確認と簡易翻訳テストを行います";

        public override void Action(CommandCaller caller, string input, string[] args)
        {
            if (args.Length == 0)
            {
                Main.NewText("Usage: " + Usage);
                return;
            }

            var cfg = ModContent.GetInstance<ClientConfig>();

            var sub = args[0].ToLowerInvariant();
            if (sub == "status")
            {
                bool enabled = DeepLTranslator.IsEnabled;
                Main.NewText($"DeepL Enabled={enabled}, UseDeepL={cfg.UseDeepL}, HasKey={(string.IsNullOrWhiteSpace(cfg.DeepLApiKey) ? "No" : "Yes")}, TargetLang={cfg.TargetLang}");
                return;
            }
            if (sub == "test")
            {
                string text = args.Length >= 2 ? string.Join(" ", args, 1, args.Length - 1) : "Hello";
                if (!DeepLTranslator.IsEnabled)
                {
                    Main.NewText("DeepLが無効です。ConfigでAPIキーとUseDeepLを確認してください。");
                    return;
                }
                // 非同期で実行し、メインスレッドブロックを避ける
                Main.NewText($"翻訳要求中: '{text}'...");
                System.Threading.Tasks.Task.Run(async () =>
                {
                    try
                    {
                        var cts = new System.Threading.CancellationTokenSource(TimeSpan.FromSeconds(5));
                        var result = await DeepLTranslator.TranslateAsync(text).WaitAsync(cts.Token).ConfigureAwait(false);
                        bool changed = !string.IsNullOrEmpty(result) && !string.Equals(result, text, StringComparison.Ordinal);
                        Main.NewText(changed
                            ? $"DeepL OK: '{text}' -> '{result}'"
                            : "DeepL応答なし/同一結果（キー/エンドポイント/ネットワークをご確認ください）");
                    }
                    catch (OperationCanceledException)
                    {
                        Main.NewText("DeepLタイムアウト (5s)");
                    }
                    catch (Exception ex)
                    {
                        Main.NewText($"DeepLエラー: {ex.Message}");
                    }
                });
                return;
            }

            Main.NewText("Unknown subcommand. " + Usage);
        }
    }
}



===== FILE: D:\TranslateTest2\Config\ClientConfig.cs =====
using System.ComponentModel;
using Terraria.ModLoader.Config;
using TranslateTest2.Core;

namespace TranslateTest2.Config
{
    public class ClientConfig : ModConfig
    {
        public override ConfigScope Mode => ConfigScope.ClientSide;

        [DefaultValue("")]
        public string DeepLApiKey { get; set; } = "";

        [DefaultValue("ja")]
        public string TargetLang { get; set; } = "ja";

        [DefaultValue(true)]
        public bool UseDeepL { get; set; } = true;

        [DefaultValue(true)]
        public bool CacheDeepL { get; set; } = true;

        [DefaultValue(true)]
        public bool ShowShiftIndicator { get; set; } = true;

        [DefaultValue(true)]
        public bool EnableNameReconstruction { get; set; } = true;

    [DefaultValue(true)]
    public bool SkipBracketContentInNames { get; set; } = true;

        // DeepL 高速化のための設定
        [DefaultValue(1500)]
        [Range(250, 30000)] // 0.25s ～ 30s
        [Increment(250)]
        public int DeepLTimeoutMs { get; set; } = 1500;

        [DefaultValue(150)]
        [Range(50, 2000)] // 50ms ～ 2s
        [Increment(50)]
        public int DeepLBatchIntervalMs { get; set; } = 150;

        [DefaultValue(10)]
        [Range(1, 50)]
        public int DeepLBatchMax { get; set; } = 10;

        // DeepL 接続安定化用
        [DefaultValue("auto")] // auto | free | paid
        public string DeepLEndpointPreference { get; set; } = "auto";

        [DefaultValue(2)]
        [Range(0, 8)]
        public int DeepLRetryCount { get; set; } = 2;

        [DefaultValue(200)]
        [Range(0, 5000)]
        [Increment(100)]
        public int DeepLRetryInitialDelayMs { get; set; } = 200;

        [DefaultValue("")]
        public string ProxyUrl { get; set; } = "";

        public override void OnChanged()
        {
            // 設定変更が保存されたら即時反映
            DeepLTranslator.ApplyConfig(this);
        }

        public override void OnLoaded()
        {
            // 起動時/リロード時に反映
            DeepLTranslator.ApplyConfig(this);
        }
    }
}



===== FILE: D:\TranslateTest2\Config\ServerConfig.cs =====
using System.ComponentModel;
using Terraria.ModLoader;
using Terraria.ModLoader.Config;

namespace TranslateTest2.Config
{
    // 元は ServerSide だったが Mod 全体 side=Client のため ClientSide に変更
    public class BiomeDisplayClientConfig : ModConfig
    {
        public override ConfigScope Mode => ConfigScope.ClientSide;

    // Header はスペース不可の識別子/キーに変更
    [Header("BiomeDisplay")] 
        [DefaultValue(false)]
        public bool simpleDisplay;
    }
}



===== FILE: D:\TranslateTest2\Content\InfoDisplays\BiomeInfoDisplay.cs =====
using System.Collections.Generic;
using Terraria;
using Terraria.ModLoader;
using Terraria.Localization;
using Microsoft.Xna.Framework;
using TranslateTest2.Core;
using TranslateTest2.Config;

namespace TranslateTest2.Content.InfoDisplays
{
    public class BiomeInfoDisplay : InfoDisplay
    {
        public override bool Active()
        {
            return Main.LocalPlayer.GetModPlayer<InfoPlayer>().biomeDisplay;
        }

        public override string DisplayValue(ref Color displayColor, ref Color displayShadowColor)
        {
            var mp = Main.LocalPlayer.GetModPlayer<InfoPlayer>();
            var list = mp.biomeNames ?? InfoPlayer.EmptyList; // 念のため null セーフ
            int count = list.Count;
            if (count == 0)
            {
                return Language.GetTextValue("Mods.TranslateTest2.Biomes.Neutral");
            }

            // 2000tick 周期を count スロットに等分 (整数割り: 参照実装の挙動維持)
            const int period = 2000;
            int slotSize = period / count; // count が 2000 超えることは実質ない想定
            if (slotSize <= 0) slotSize = 1; // 安全策
            int timerMod = mp.displayTimer % period;
            int displayIndex = timerMod / slotSize;
            if (displayIndex >= count) displayIndex = count - 1; // 端数補正

            string biomeToDisplay = list[displayIndex];
            if (string.IsNullOrEmpty(biomeToDisplay))
                biomeToDisplay = Language.GetTextValue("Mods.TranslateTest2.Biomes.Neutral");

            bool simple = ModContent.GetInstance<BiomeDisplayClientConfig>().simpleDisplay;
            if (!simple && count > 1)
                biomeToDisplay += " +";

            return biomeToDisplay;
        }
    }
}



===== FILE: D:\TranslateTest2\Core\DeepLTranslator.cs =====
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using System.Net;
using System.Net.Http;
using System.Text.Json;
using System.Threading.Tasks;
using TranslateTest2.Config;
using System.Threading;

namespace TranslateTest2.Core
{
    public static class DeepLTranslator
    {
    private static HttpClient _client;
    private static HttpClientHandler _handler;
    private static readonly object _initLock = new();
        private static string _apiKey = string.Empty;
        private static string _targetLang = "ja";
        private static bool _use = true;
        private static bool _cacheEnabled = true;
    private static int _timeoutMs = 1500;
    private static int _batchIntervalMs = 150;
    private static int _batchMax = 10;
    private static string _endpointPref = "auto";
    private static int _retryCount = 2;
    private static int _retryDelayMs = 200;
    private static string _proxyUrl = string.Empty;

    private static readonly ConcurrentDictionary<string, string> _cache = new();
    // 処理中のテキスト（重複送信抑止）
    private static readonly ConcurrentDictionary<string, byte> _pending = new();
    // 直近の送信時刻（簡易クールダウン）
    private static readonly ConcurrentDictionary<string, long> _lastReqTicks = new();
    private static readonly ConcurrentQueue<string> _queue = new();
    private static Task _batchWorker;
    private static readonly object _workerLock = new();
    private static CancellationTokenSource _workerCts;
    // リクエスト間の最小間隔（全体スロットリング）
    private static int _minInterRequestDelayMs = 250;
    // 安全策: キュー長と文字列長の上限
    private static int _queueMax = 2000;
    private static int _textMaxLen = 4000;
    private static int _queueCount = 0;
    // 簡易キャッシュ上限（近似的に古いキーから削除）
    private static int _cacheMaxEntries = 10000;

    private static void PruneCacheIfNeeded()
    {
        try
        {
            int count = _cache.Count;
            if (count <= _cacheMaxEntries) return;
            int toRemove = Math.Max(0, count - _cacheMaxEntries);
            // 近似的に先頭から削除（ConcurrentDictionaryの列挙はスナップショット）
            foreach (var k in _cache.Keys.Take(toRemove))
            {
                _cache.TryRemove(k, out _);
            }
        }
        catch { }
    }

        public static void ApplyConfig(ClientConfig cfg)
        {
            _apiKey = cfg?.DeepLApiKey ?? string.Empty;
            _targetLang = NormalizeLang(string.IsNullOrWhiteSpace(cfg?.TargetLang) ? "ja" : cfg.TargetLang.Trim());
            _use = cfg?.UseDeepL ?? true;
            _cacheEnabled = cfg?.CacheDeepL ?? true;
            _timeoutMs = Math.Max(250, cfg?.DeepLTimeoutMs ?? 1500);
            _batchIntervalMs = Math.Max(50, cfg?.DeepLBatchIntervalMs ?? 150);
            _batchMax = Math.Clamp(cfg?.DeepLBatchMax ?? 10, 1, 50);
            _endpointPref = (cfg?.DeepLEndpointPreference ?? "auto").Trim().ToLowerInvariant();
            _retryCount = Math.Clamp(cfg?.DeepLRetryCount ?? 2, 0, 5);
            _retryDelayMs = Math.Max(0, cfg?.DeepLRetryInitialDelayMs ?? 200);
            _proxyUrl = cfg?.ProxyUrl ?? string.Empty;

            if (_client == null)
            {
                lock (_initLock)
                {
                    if (_client == null)
                    {
                        _handler = new HttpClientHandler();
                        try
                        {
                            // 軽量化のため自動圧縮を有効化（DeepLはgzip対応）
                            _handler.AutomaticDecompression = DecompressionMethods.GZip | DecompressionMethods.Deflate;
                        }
                        catch { }
                        try
                        {
                            System.Net.ServicePointManager.SecurityProtocol |= System.Net.SecurityProtocolType.Tls12;
                        }
                        catch { }
                        if (!string.IsNullOrWhiteSpace(_proxyUrl))
                        {
                            try
                            {
                                _handler.Proxy = new System.Net.WebProxy(_proxyUrl);
                                _handler.UseProxy = true;
                            }
                            catch { }
                        }
                        _client = new HttpClient(_handler, disposeHandler: true);
                    }
                }
            }

            try
            {
                bool hasKey = !string.IsNullOrWhiteSpace(_apiKey);
                global::TranslateTest2.TranslateTest2.Instance?.Logger?.Info(
                    $"DeepL configured: use={_use}, hasKey={hasKey}, target={_targetLang}, endpointPref={_endpointPref}, timeout={_timeoutMs}ms, retry={_retryCount}, delay={_retryDelayMs}ms, cache={_cacheEnabled}, proxy={( _handler != null && _handler.UseProxy && _handler.Proxy != null)}");
            }
            catch { }

            EnsureWorker();
        }

        public static void Unload()
        {
            try { _workerCts?.Cancel(); } catch { }
            _client?.Dispose();
            _client = null;
            _handler = null;
            _cache.Clear();
            _batchWorker = null;
            _pending.Clear();
            _lastReqTicks.Clear();
            // キューを完全排出し、カウントをリセット
            while (_queue.TryDequeue(out _)) { }
            Interlocked.Exchange(ref _queueCount, 0);
            try { _workerCts?.Dispose(); } catch { }
            _workerCts = null;
        }

        public static bool IsEnabled => _use && !string.IsNullOrWhiteSpace(_apiKey);

        public static bool TryGetCached(string text, out string translated)
        {
            if (string.IsNullOrEmpty(text)) { translated = text; return true; }
            return _cache.TryGetValue(text, out translated);
        }

    public static void RequestIfMissing(string text)
        {
            if (!IsEnabled || string.IsNullOrWhiteSpace(text)) return;
            if (text.Length > _textMaxLen) return;
            if (_cache.ContainsKey(text)) return;

            // 直近送信からのクールダウン（同一テキストを短時間で連投しない）
            if (_lastReqTicks.TryGetValue(text, out var lastTicks))
            {
                var deltaMs = (int)TimeSpan.FromTicks(DateTime.UtcNow.Ticks - lastTicks).TotalMilliseconds;
                if (deltaMs < Math.Max(_timeoutMs, 1000)) // タイムアウト相当の間は再送しない
                    return;
            }

            // 既にキューに乗っている/処理中ならスキップ
            if (!_pending.TryAdd(text, 0))
                return;

            // 厳密カウントで上限管理
            int current = Interlocked.CompareExchange(ref _queueCount, 0, 0);
            if (current >= _queueMax)
            {
                // キュー満杯なら pending ロールバック（ゴースト状態防止）
                _pending.TryRemove(text, out _);
                return;
            }
            _queue.Enqueue(text);
            Interlocked.Increment(ref _queueCount);
            EnsureWorker();
        }

        public static async Task<string> TranslateAsync(string text)
        {
            if (!IsEnabled || string.IsNullOrWhiteSpace(text)) return text;
            if (text.Length > _textMaxLen) return text;

            if (_cacheEnabled && _cache.TryGetValue(text, out var hit))
                return hit;

            try
            {
                var result = await TranslateCoreAsync(text).ConfigureAwait(false);

                if (string.IsNullOrEmpty(result))
                    return text;

                if (_cacheEnabled)
                {
                    _cache[text] = result;
                    PruneCacheIfNeeded();
                }

                return result;
            }
            catch
            {
                return text;
            }
        }

        private static async Task<string> TranslateCoreAsync(string text)
        {
            var endpoints = GetPreferredEndpoints();
            foreach (var ep in endpoints)
            {
                var r = await PostTranslateWithRetry(text, ep).ConfigureAwait(false);
                if (!string.IsNullOrEmpty(r)) return r;
            }
            return null;
        }

        private static async Task<Dictionary<string, string>> TranslateCoreBatchAsync(List<string> texts)
        {
            if (texts == null || texts.Count == 0) return new Dictionary<string, string>();
            // 異常な長文は除外
            texts = texts.Where(t => !string.IsNullOrEmpty(t) && t.Length <= _textMaxLen).Distinct().ToList();
            if (texts.Count == 0) return new Dictionary<string, string>();
            var endpoints = GetPreferredEndpoints();
            foreach (var ep in endpoints)
            {
                var r = await PostTranslateBatchWithRetry(texts, ep).ConfigureAwait(false);
                if (r != null && r.Count > 0) return r;
            }
            return new Dictionary<string, string>();
        }

        private static readonly string[] EndpointsFree = { "https://api-free.deepl.com/v2/translate" };
        private static readonly string[] EndpointsPaid = { "https://api.deepl.com/v2/translate" };
        private static readonly string[] EndpointsBoth = { "https://api-free.deepl.com/v2/translate", "https://api.deepl.com/v2/translate" };

        private static string[] GetPreferredEndpoints() => _endpointPref switch
        {
            "free" => EndpointsFree,
            "paid" => EndpointsPaid,
            _ => EndpointsBoth
        };

        private static async Task<string> PostTranslate(string text, string endpoint)
        {
            if (_client == null) return null;

            // DeepLの推薦はapplication/x-www-form-urlencoded
            var content = new FormUrlEncodedContent(new[]
            {
                new KeyValuePair<string, string>("auth_key", _apiKey),
                new KeyValuePair<string, string>("text", text),
                new KeyValuePair<string, string>("target_lang", _targetLang.ToUpperInvariant()),
            });

            using var cts = new System.Threading.CancellationTokenSource(_timeoutMs);
        using var resp = await _client.PostAsync(endpoint, content, cts.Token).ConfigureAwait(false);
            if (!resp.IsSuccessStatusCode)
            {
                try
                {
            var body = await resp.Content.ReadAsStringAsync().ConfigureAwait(false);
            global::TranslateTest2.TranslateTest2.Instance?.Logger?.Warn($"DeepL error {resp.StatusCode} at {endpoint}: {body}");
                }
                catch { }
                return null;
            }

            var json = await resp.Content.ReadAsStringAsync().ConfigureAwait(false);
            using var doc = JsonDocument.Parse(json);
            if (!doc.RootElement.TryGetProperty("translations", out var arr) || arr.GetArrayLength() == 0)
                return null;

            var first = arr[0];
            if (!first.TryGetProperty("text", out var textProp))
                return null;

            return textProp.GetString();
        }

        private static async Task<Dictionary<string, string>> PostTranslateBatch(List<string> texts, string endpoint)
        {
            var result = new Dictionary<string, string>();
            if (_client == null || texts == null || texts.Count == 0) return result;

            // DeepL: 同じキー"text"を複数付与で一括翻訳
            var payload = new List<KeyValuePair<string, string>>(texts.Count + 2)
            {
                new KeyValuePair<string, string>("auth_key", _apiKey),
                new KeyValuePair<string, string>("target_lang", _targetLang.ToUpperInvariant()),
            };
            foreach (var t in texts)
                payload.Add(new KeyValuePair<string, string>("text", t));

            var content = new FormUrlEncodedContent(payload);
            using var cts = new System.Threading.CancellationTokenSource(_timeoutMs);
        using var resp = await _client.PostAsync(endpoint, content, cts.Token).ConfigureAwait(false);
            if (!resp.IsSuccessStatusCode)
            {
                try
                {
            var body = await resp.Content.ReadAsStringAsync().ConfigureAwait(false);
            global::TranslateTest2.TranslateTest2.Instance?.Logger?.Warn($"DeepL error {resp.StatusCode} at {endpoint} (batch {texts.Count}): {body}");
                }
                catch { }
                return result;
            }

            var json = await resp.Content.ReadAsStringAsync().ConfigureAwait(false);
            using var doc = JsonDocument.Parse(json);
            if (!doc.RootElement.TryGetProperty("translations", out var arr))
                return result;
            int n = Math.Min(arr.GetArrayLength(), texts.Count);
            for (int i = 0; i < n; i++)
            {
                var el = arr[i];
                if (el.TryGetProperty("text", out var textProp))
                {
                    var translated = textProp.GetString();
                    if (!string.IsNullOrEmpty(translated))
                        result[texts[i]] = translated;
                }
            }
            return result;
        }

        private static async Task<Dictionary<string, string>> PostTranslateBatchWithRetry(List<string> texts, string endpoint)
        {
            int attempt = 0;
            int delay = _retryDelayMs;
            while (true)
            {
                try
                {
                    try
                    {
                        global::TranslateTest2.TranslateTest2.Instance?.Logger?.Debug($"DeepL BATCH attempt {attempt + 1}/{_retryCount + 1} -> {endpoint}, timeout={_timeoutMs}ms, size={texts.Count}");
                    }
                    catch { }
                    var map = await PostTranslateBatch(texts, endpoint).ConfigureAwait(false);
                    if (map != null && map.Count > 0) return map;
                }
                catch (TaskCanceledException tce)
                {
                    global::TranslateTest2.TranslateTest2.Instance?.Logger?.Warn($"DeepL timeout after {_timeoutMs}ms at {endpoint} (batch attempt {attempt + 1}): {tce.Message}");
                }
                catch (OperationCanceledException oce)
                {
                    global::TranslateTest2.TranslateTest2.Instance?.Logger?.Warn($"DeepL operation canceled at {endpoint} (batch attempt {attempt + 1}): {oce.Message}");
                }
                catch (Exception ex)
                {
                    global::TranslateTest2.TranslateTest2.Instance?.Logger?.Warn($"DeepL transport error at {endpoint} (batch attempt {attempt + 1}): {ex.Message}");
                }
                if (attempt++ >= _retryCount)
                    return new Dictionary<string, string>();
                if (delay > 0)
                    await Task.Delay(delay).ConfigureAwait(false);
                delay = Math.Min(delay * 2, 3000);
            }
        }

        private static async Task<string> PostTranslateWithRetry(string text, string endpoint)
        {
            int attempt = 0;
            int delay = _retryDelayMs;
            while (true)
            {
                try
                {
                    try
                    {
                        global::TranslateTest2.TranslateTest2.Instance?.Logger?.Debug($"DeepL POST attempt {attempt + 1}/{_retryCount + 1} -> {endpoint}, timeout={_timeoutMs}ms, textLen={text?.Length ?? 0}");
                    }
                    catch { }
                    var r = await PostTranslate(text, endpoint).ConfigureAwait(false);
                    if (!string.IsNullOrEmpty(r)) return r;
                }
                catch (TaskCanceledException tce)
                {
                    global::TranslateTest2.TranslateTest2.Instance?.Logger?.Warn($"DeepL timeout after {_timeoutMs}ms at {endpoint} (attempt {attempt + 1}): {tce.Message}");
                }
                catch (OperationCanceledException oce)
                {
                    global::TranslateTest2.TranslateTest2.Instance?.Logger?.Warn($"DeepL operation canceled at {endpoint} (attempt {attempt + 1}): {oce.Message}");
                }
                catch (Exception ex)
                {
                    global::TranslateTest2.TranslateTest2.Instance?.Logger?.Warn($"DeepL transport error at {endpoint} (attempt {attempt + 1}): {ex.Message}");
                }
                if (attempt++ >= _retryCount)
                    return null;
                if (delay > 0)
                    await Task.Delay(delay).ConfigureAwait(false);
                delay = Math.Min(delay * 2, 3000);
            }
        }

        private static string NormalizeLang(string input)
        {
                if (string.IsNullOrWhiteSpace(input)) return "JA";
                var s = input.Trim().Replace('_', '-').ToUpperInvariant();

                if (AllowedLangs.Contains(s)) return s;

            // よくある地域付き→言語コードへの簡易正規化
            if (s.StartsWith("EN-")) return s == "EN-US" || s == "EN-GB" ? s : "EN";
            if (s.StartsWith("PT-")) return (s == "PT-BR" || s == "PT-PT") ? s : "PT";
            if (s.StartsWith("ZH-")) return "ZH";
            if (s.StartsWith("JA-")) return "JA";
            if (s.StartsWith("KO-")) return "KO";
            if (s.Length >= 2 && AllowedLangs.Contains(s.AsSpan(0,2).ToString()))
                return s.Substring(0,2);
            return "JA"; // 無効値は日本語へフォールバック
        }

        // 許可言語セット（イミュータブル）
        private static readonly HashSet<string> AllowedLangs = new(StringComparer.OrdinalIgnoreCase)
        {
            "BG","CS","DA","DE","EL","EN","EN-GB","EN-US","ES","ET","FI","FR","HU","ID",
            "IT","JA","KO","LT","LV","NB","NL","PL","PT","PT-BR","PT-PT","RO","RU","SK",
            "SL","SV","TR","UK","ZH"
        };

        private static void EnsureWorker()
        {
            if (_batchWorker != null && !_batchWorker.IsCompleted) return;
            lock (_workerLock)
            {
                if (_batchWorker != null && !_batchWorker.IsCompleted) return;
                try
                {
                    global::TranslateTest2.TranslateTest2.Instance?.Logger?.Debug("DeepL batch worker started");
                }
                catch { }
                _workerCts?.Dispose();
                _workerCts = new CancellationTokenSource();
                var token = _workerCts.Token;
                _batchWorker = Task.Run(async () =>
                {
                    var list = new List<string>(_batchMax);
                    long lastSentTicks = 0;
                    while (!token.IsCancellationRequested)
                    {
                        // デキュー（空なら終了）
                        if (_queue.TryDequeue(out var item))
                        {
                            list.Add(item);
                            Interlocked.Decrement(ref _queueCount);
                        }
                        else
                        {
                            break; // 現設計では空で終了（必要時にEnsureWorkerで再起動）
                        }

                        // バッチ満杯 or 待ち時間経過
                        var start = DateTime.UtcNow;
                        while (!token.IsCancellationRequested && list.Count < _batchMax)
                        {
                            try { await Task.Delay(_batchIntervalMs, token).ConfigureAwait(false); } catch { }
                            while (list.Count < _batchMax && _queue.TryDequeue(out var nxt))
                            {
                                list.Add(nxt);
                                Interlocked.Decrement(ref _queueCount);
                            }
                            if ((DateTime.UtcNow - start).TotalMilliseconds >= _batchIntervalMs)
                                break;
                        }

                        try
                        {
                            // 全体スロットリング間隔を確保
                            if (lastSentTicks != 0)
                            {
                                var gapMs = (int)TimeSpan.FromTicks(DateTime.UtcNow.Ticks - lastSentTicks).TotalMilliseconds;
                                if (gapMs < _minInterRequestDelayMs)
                                {
                                    var delay = _minInterRequestDelayMs - gapMs;
                                    if (delay > 0) { try { await Task.Delay(delay, token).ConfigureAwait(false); } catch { } }
                                }
                            }

                            // バッチは重複を除いて送信（結果は順序対応）
                            var uniq = list.Where(t => !string.IsNullOrEmpty(t) && t.Length <= _textMaxLen).Distinct().ToList();
                            Dictionary<string, string> map;
                            if (uniq.Count > 1)
                            {
                                map = await TranslateCoreBatchAsync(uniq).ConfigureAwait(false);
                            }
                            else
                            {
                                map = new Dictionary<string, string>();
                                string single = null;
                                if (uniq.Count == 1)
                                    single = await TranslateCoreAsync(uniq[0]).ConfigureAwait(false);
                                if (!string.IsNullOrEmpty(single)) map[uniq[0]] = single;
                            }

                            foreach (var kv in map)
                            {
                                if (!string.IsNullOrEmpty(kv.Value))
                                {
                                    _cache[kv.Key] = kv.Value;
                                }
                            }
                            PruneCacheIfNeeded();
                            lastSentTicks = DateTime.UtcNow.Ticks;
                        }
                        catch { /* 無視 */ }
                        finally
                        {
                            var nowTicks = DateTime.UtcNow.Ticks;
                            foreach (var t in list)
                            {
                                _lastReqTicks[t] = nowTicks;
                                _pending.TryRemove(t, out _);
                            }
                            list.Clear();
                        }
                    }
                    // 最終的なカウンタ補正（負値防止）
                    if (Interlocked.CompareExchange(ref _queueCount, 0, int.MinValue) < 0)
                        Interlocked.Exchange(ref _queueCount, 0);
                }, token);
            }
        }
    }
}



===== FILE: D:\TranslateTest2\Core\InfoPlayer.cs =====
using System.Collections.Generic;
using Terraria;
using Terraria.ModLoader;
using Terraria.Localization;

namespace TranslateTest2.Core
{
    // Biome 情報表示用の最小限 ModPlayer 実装
    public class InfoPlayer : ModPlayer
    {
        public bool biomeDisplay;
        public List<string> biomeNames;
        public int displayTimer; // 経過フレーム
        public static readonly List<string> EmptyList = new List<string>(0);

        public override void Initialize()
        {
            biomeNames = new List<string>();
        }

        public override void ResetInfoAccessories()
        {
            biomeDisplay = false;
        }

        public override void RefreshInfoAccessoriesFromTeamPlayers(Player otherPlayer)
        {
            if (otherPlayer.GetModPlayer<InfoPlayer>().biomeDisplay)
                biomeDisplay = true;
        }

        public override void PreUpdate()
        {
            // 参照実装互換: 1tickごと増加し 4000 超でリセット
            if (++displayTimer > 4000)
                displayTimer = 0;
        }

        public override void PostUpdate()
        {
            // 1秒毎に再計算
            if (biomeDisplay && (biomeNames == null || Main.GameUpdateCount % 60 == 0))
            {
                biomeNames = GetCurrentBiomes();
            }
        }

        private List<string> GetCurrentBiomes()
        {
            var list = new List<string>();
            Player p = Player;

            if (p.townNPCs > 2f && !p.ZoneShadowCandle)
                list.Add(Language.GetTextValue("Mods.TranslateTest2.Biomes.Vanilla.Town"));
            if (p.ZoneUnderworldHeight)
                list.Add(Language.GetTextValue("Mods.TranslateTest2.Biomes.Vanilla.Underworld"));
            else if (p.ZoneSkyHeight)
                list.Add(Language.GetTextValue("Mods.TranslateTest2.Biomes.Vanilla.Space"));
            else if (p.ZoneRockLayerHeight || p.ZoneDirtLayerHeight)
                list.Add(Language.GetTextValue("Mods.TranslateTest2.Biomes.Vanilla.Underground"));
            if (p.ZoneBeach)
                list.Add(Language.GetTextValue("Mods.TranslateTest2.Biomes.Vanilla.Ocean"));
            if (p.ZoneSnow)
                list.Add(Language.GetTextValue("Mods.TranslateTest2.Biomes.Vanilla.Snow"));
            if (p.ZoneDesert || p.ZoneUndergroundDesert)
                list.Add(Language.GetTextValue("Mods.TranslateTest2.Biomes.Vanilla.Desert"));
            if (p.ZoneJungle)
                list.Add(Language.GetTextValue("Mods.TranslateTest2.Biomes.Vanilla.Jungle"));
            if (p.ZoneHallow)
                list.Add(Language.GetTextValue("Mods.TranslateTest2.Biomes.Vanilla.Hallow"));
            if (p.ZoneCorrupt)
                list.Add(Language.GetTextValue("Mods.TranslateTest2.Biomes.Vanilla.Corruption"));
            if (p.ZoneCrimson)
                list.Add(Language.GetTextValue("Mods.TranslateTest2.Biomes.Vanilla.Crimson"));
            if (p.ZoneGlowshroom)
                list.Add(Language.GetTextValue("Mods.TranslateTest2.Biomes.Vanilla.Shroom"));
            if (p.ZoneDungeon)
                list.Add(Language.GetTextValue("Mods.TranslateTest2.Biomes.Vanilla.Dungeon"));
            if (p.ZoneMeteor)
                list.Add(Language.GetTextValue("Mods.TranslateTest2.Biomes.Vanilla.Meteor"));
            if (p.ZoneGranite)
                list.Add(Language.GetTextValue("Mods.TranslateTest2.Biomes.Vanilla.Granite"));
            if (p.ZoneMarble)
                list.Add(Language.GetTextValue("Mods.TranslateTest2.Biomes.Vanilla.Marble"));
            if (p.ZoneLihzhardTemple)
                list.Add(Language.GetTextValue("Mods.TranslateTest2.Biomes.Vanilla.Temple"));
            if (p.ZoneGraveyard)
                list.Add(Language.GetTextValue("Mods.TranslateTest2.Biomes.Vanilla.Graveyard"));

            if (list.Count == 0)
                list.Add(Language.GetTextValue("Mods.TranslateTest2.Biomes.Vanilla.Forest"));

            var seen = new HashSet<string>();
            var dedup = new List<string>();
            foreach (var b in list)
                if (seen.Add(b)) dedup.Add(b);
            return dedup;
        }
    }
}



===== FILE: D:\TranslateTest2\Core\NameComposer.cs =====
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;
using TranslateTest2.Config;
using Terraria.ModLoader;

namespace TranslateTest2.Core
{
    /// <summary>
    /// 英語風のアイテム名 (prefixes + base + of + suffixes) を日本語風の語順に再構成します。
    /// 例: "Legendary Impeding ムラマサ of fending" → "伝説 妨害 受け流しのムラマサ"
    /// </summary>
    public static class NameComposer
    {
        // シンプル辞書（必要に応じてAssets辞書で拡張可能）
    private static readonly Dictionary<string, string> PrefixMap = new(StringComparer.OrdinalIgnoreCase)
        {
            {"Legendary", "伝説"},
            {"Impeding", "妨害"},
            {"Godly", "神"},
            {"Rare", "レア"},
            {"Common", "コモン"},
            {"Uncommon", "アンコモン"},
            {"Epic", "エピック"},
        };

    private static readonly Dictionary<string, string> SuffixMap = new(StringComparer.OrdinalIgnoreCase)
        {
            {"fending", "受け流し"},
            {"warding", "防護"},
        };

        // 固有名詞・ゲーム用語の優先辞書（DeepL前に適用）
        private static readonly Dictionary<string, string> ProperNouns = new(StringComparer.OrdinalIgnoreCase)
        {
            {"Hades", "ハデス"},
            {"terra", "テラ"},
        };

        /// <summary>
        /// 名前行を分析し、英語接頭辞群＋日本語基底名＋of 接尾辞群 の構造なら日本語語順に再構成。
        /// それ以外は原文を返します。
        /// </summary>
        public static bool TryCompose(string input, out string output)
        {
            output = input;
            if (string.IsNullOrWhiteSpace(input)) return false;
            try
            {
                // 末尾のスター囲み（*...* / ＊...＊）セグメントを抽出（空白を含んでもOK）。原文のまま再付与するため翻訳対象から除外する。
                var trailingStarSegments = ExtractTrailingStarSegments(ref input);

                // 基本パターン: [prefix*] [baseName (多言語可)] [" of "] [suffix*]
                int ofIdx = input.IndexOf(" of ", StringComparison.OrdinalIgnoreCase);
                string left = input;
                string right = null;
                if (ofIdx >= 0)
                {
                    left = input.Substring(0, ofIdx);
                    right = input.Substring(ofIdx + 4);
                }

                // 左側をトークナイズ（空白区切り）
                var tokens = left.Split(new[] { ' ' }, StringSplitOptions.RemoveEmptyEntries).ToList();
                // 末尾に (15) や *ModName* のようなトークンを取り除く
                var trailingMarkers = new List<string>();
                while (tokens.Count > 0 && IsTrailingMarkerToken(tokens[^1]))
                {
                    trailingMarkers.Insert(0, tokens[^1]);
                    tokens.RemoveAt(tokens.Count - 1);
                }
                if (tokens.Count == 0) return false;

                // 基底名
                string baseName = tokens[^1];
                string jpBase = baseName;
                if (TextLangHelper.NeedsTranslation(baseName))
                {
                    jpBase = ToJapaneseToken(baseName, isPrefix: false);
                }

                // 接頭辞
                var prefixes = tokens.Take(tokens.Count - 1).ToList();
                var jpPrefixes = new List<string>();
                foreach (var p in prefixes)
                {
                    jpPrefixes.Add(ToJapaneseToken(p, isPrefix: true));
                }

                // 右側（接尾辞群）
                var jpSuffixes = new List<string>();
                if (!string.IsNullOrEmpty(right))
                {
                    var suffixTokens = right.Split(new[] { ' ' }, StringSplitOptions.RemoveEmptyEntries);
                    foreach (var s in suffixTokens)
                    {
                        jpSuffixes.Add(ToJapaneseToken(s, isPrefix: false));
                    }
                }

                // 再構成
                string prefixPart = string.Join(' ', jpPrefixes);
                bool hasJoinerToken = prefixes.Any(IsJoinerToken);
                bool allNumericLikePrefixes = prefixes.Count > 0 && prefixes.All(IsNumericLikeToken);
                string result;
                if (jpSuffixes.Count > 0)
                {
                    string suffixPart = string.Join(' ', jpSuffixes);
                    bool suffixEndsWithNo = suffixPart.EndsWith("の") || suffixPart.EndsWith("ノ");
                    string suffixJoined = suffixEndsWithNo ? $"{suffixPart}{jpBase}" : $"{suffixPart}の{jpBase}";
                    result = string.IsNullOrEmpty(prefixPart) ? suffixJoined : $"{prefixPart} {suffixJoined}";
                }
                else
                {
                    if (string.IsNullOrEmpty(prefixPart))
                    {
                        result = jpBase;
                    }
                    else
                    {
                        if (TextLangHelper.IsJapaneseString(jpBase) && !hasJoinerToken && !allNumericLikePrefixes)
                        {
                            string trimmedPrefix = prefixPart.TrimEnd();
                            bool endsWithNo = trimmedPrefix.EndsWith("の") || trimmedPrefix.EndsWith("ノ");
                            if (endsWithNo)
                            {
                                result = $"{trimmedPrefix}{jpBase}";
                            }
                            else
                            {
                                string lastJpPrefix = jpPrefixes.Count > 0 ? jpPrefixes[^1] : string.Empty;
                                if (IsAdjLikeJapanesePrefix(lastJpPrefix))
                                    result = $"{prefixPart}{jpBase}";
                                else
                                    result = $"{prefixPart}の{jpBase}";
                            }
                        }
                        else
                        {
                            result = $"{prefixPart} {jpBase}";
                        }
                    }
                }

                var reattach = new List<string>();
                if (trailingMarkers.Count > 0) reattach.AddRange(trailingMarkers);
                if (trailingStarSegments.Count > 0) reattach.AddRange(trailingStarSegments);
                if (reattach.Count > 0)
                    result = result + " " + string.Join(" ", reattach);

                output = result;
                return !string.Equals(output, input, StringComparison.Ordinal);
            }
            catch (Exception ex)
            {
                global::TranslateTest2.TranslateTest2.Instance?.Logger?.Warn($"NameComposer error: {ex.Message}");
                output = input;
                return false;
            }
        }

        private static bool IsJoinerToken(string token)
        {
            if (string.IsNullOrEmpty(token)) return false;
            // 「の」を避けたい連結記号
            switch (token)
            {
                case "-":
                case "–":
                case "—":
                case "－":
                case ":":
                case "：":
                case "・":
                case "/":
                case "／":
                    return true;
            }
            return false;
        }

        // 数値様のトークン（+1, -2, 10%, 1.5x など）かどうか
        private static bool IsNumericLikeToken(string token)
        {
            if (string.IsNullOrWhiteSpace(token)) return false;
            var s = token.Trim();
            // 単純高速判定：先頭が+/-か数字で、かつ英字が含まれない
            bool startsOk = s[0] == '+' || s[0] == '-' || char.IsDigit(s[0]);
            if (!startsOk) return false;
            bool hasLetter = s.Any(ch => (ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z'));
            if (hasLetter)
            {
                // 末尾の x/X は倍率記号として許容
                if (!(s.EndsWith("x") || s.EndsWith("X"))) return false;
                // 先頭部は英字なし
                var middle = s.Substring(0, s.Length - 1);
                if (middle.Any(ch => (ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z'))) return false;
            }
            // 数字/符号/小数点/カンマ/パーセント/倍率記号のみ
            foreach (var ch in s)
            {
                if (char.IsDigit(ch)) continue;
                if (ch == '+' || ch == '-' || ch == '.' || ch == ',' || ch == '%' || ch == 'x' || ch == 'X') continue;
                // スペースは許容しない（トークンは空白分割済）
                return false;
            }
            return true;
        }

        // 連体修飾的な和語プレフィックス（「献身的な」「延びる」「軽い」「速く」など）かどうか
        // 条件: 日本語文字列で、末尾が「な/い/る/く/的」「やすい/にくい」などの場合に true
        private static bool IsAdjLikeJapanesePrefix(string token)
        {
            if (string.IsNullOrWhiteSpace(token)) return false;
            var s = token.Trim();
            // 記号はこの時点で概ね除去済みだが、簡易に日本語かを確認
            if (!TextLangHelper.IsJapaneseString(s)) return false;

            // 複合語尾の先に評価
            if (s.EndsWith("やすい") || s.EndsWith("にくい")) return true;
            if (s.EndsWith("的")) return true;

            // 一文字語尾での簡易判定
            char last = s[s.Length - 1];
            switch (last)
            {
                case 'な':
                case 'い':
                case 'る':
                case 'く':
                case 'た':
                    return true;
                default:
                    return false;
            }
        }

        // 文字列末尾にある *...* / ＊...＊ のセグメント（空白含む）を右端から順に切り出し、
        // input から取り除いたうえでリストとして返す（先頭がより左側の順序）。
        private static List<string> ExtractTrailingStarSegments(ref string input)
        {
            var result = new List<string>();
            if (string.IsNullOrEmpty(input)) return result;

            string working = input;
            while (true)
            {
                if (string.IsNullOrWhiteSpace(working)) break;
                // 末尾の空白を除去して判定（後でスペースは付け直す）
                int endTrim = working.Length - 1;
                while (endTrim >= 0 && char.IsWhiteSpace(working[endTrim])) endTrim--;
                if (endTrim < 0) { working = string.Empty; break; }

                char last = working[endTrim];
                if (last != '*' && last != '＊') break;

                // 同じ種類のスターの開始位置を探す
                char star = last;
                int open = working.LastIndexOf(star, endTrim - 1);
                if (open < 0) break;

                // 開始直前は空白か行頭であること（単語の一部ではない）
                int pre = open - 1;
                while (pre >= 0 && char.IsWhiteSpace(working[pre])) pre--;
                int segmentStart = (pre < 0) ? 0 : pre + 1;
                // segmentStart が空白位置なら1つ進めてスター直前の空白を含めない
                while (segmentStart < working.Length && char.IsWhiteSpace(working[segmentStart])) segmentStart++;

                // セグメントは segmentStart 以降にあるスター囲み全体
                string head = working.Substring(0, segmentStart).TrimEnd();
                string seg = working.Substring(segmentStart, endTrim - segmentStart + 1);
                if (!(seg.Length >= 2 && seg[0] == star && seg[seg.Length - 1] == star)) break;

                // 収集（前側のものが先になるよう先頭に挿入）
                result.Insert(0, seg);
                working = head;
            }

            input = working;
            return result;
        }

        private static bool IsTrailingMarkerToken(string token)
        {
            if (string.IsNullOrEmpty(token)) return false;
            var s = token.Trim();
            if (s.Length < 2) return false;
            char first = s[0];
            char last = s[s.Length - 1];
            // ASCII/全角の丸括弧
            if ((first == '(' && last == ')') || (first == '（' && last == '）')) return true;
            // ASCII/全角アスタリスク
            bool isStarFirst = (first == '*' || first == '＊');
            bool isStarLast = (last == '*' || last == '＊');
            if (isStarFirst && isStarLast) return true;
            return false;
        }

        private static string ToJapaneseToken(string token, bool isPrefix)
        {
            if (string.IsNullOrWhiteSpace(token)) return token;

            // 句読点などを分離
            var (lead, core, trail) = TrimPunct(token);

            // 設定で角括弧/スター内は翻訳しない
            try
            {
                var cfg = ModContent.GetInstance<ClientConfig>();
                if (cfg?.SkipBracketContentInNames == true)
                {
                    // トークンが [ ... ] / * ... * / ＊ ... ＊ で囲われている場合はそのまま返す
                    if (token.Length >= 2 && token[0] == '[' && token[token.Length - 1] == ']')
                        return token;
                    if (token.Length >= 2 && (token[0] == '*' || token[0] == '＊') && (token[token.Length - 1] == '*' || token[token.Length - 1] == '＊'))
                        return token;
                    // もしくはリード/トレイルが括弧を含む（TrimPunctで外れたケース）
                    if (lead.IndexOf('[') >= 0 && trail.IndexOf(']') >= 0)
                        return lead + core + trail;
                    // リード/トレイルがスターを含む（*...* が分離されたケース）
                    bool leadStar = lead.IndexOf('*') >= 0 || lead.IndexOf('＊') >= 0;
                    bool trailStar = trail.IndexOf('*') >= 0 || trail.IndexOf('＊') >= 0;
                    if (leadStar && trailStar)
                        return lead + core + trail;
                }
            }
            catch { }

            // 1) 固定辞書
            if (ProperNouns.TryGetValue(core, out var proper))
                return lead + proper + trail;

            if (isPrefix && PrefixMap.TryGetValue(core, out var fixedP))
                return lead + fixedP + trail;
            if (!isPrefix && SuffixMap.TryGetValue(core, out var fixedS))
                return lead + fixedS + trail;

            // 2) 非日本語トークンはDeepL対象
            if (TextLangHelper.NeedsTranslation(core))
            {
                // 接頭辞/接尾辞ともに、まずDeepLキャッシュを試み、未命中なら非同期要求のみ投げて原文維持
                if (DeepLTranslator.IsEnabled)
                {
                    if (DeepLTranslator.TryGetCached(core, out var cached))
                        return lead + cached + trail;
                    DeepLTranslator.RequestIfMissing(core);
                }
                return lead + core + trail;
            }

            // 3) そのまま
            return token;
        }

        private static (string lead, string core, string trail) TrimPunct(string s)
        {
            if (string.IsNullOrEmpty(s)) return (string.Empty, string.Empty, string.Empty);
            int start = 0;
            int end = s.Length - 1;
            while (start <= end && char.IsPunctuation(s[start])) start++;
            while (end >= start && char.IsPunctuation(s[end])) end--;
            // 防御的チェック
            if (start < 0) start = 0;
            if (end < start - 1) end = start - 1; // all punctuation case → empty core
            if (start > s.Length) start = s.Length; // 異常防護
            if (end >= s.Length) end = s.Length - 1;
            int coreLen = end - start + 1;
            if (coreLen < 0) coreLen = 0;
            string lead;
            string core;
            string trail;
            try { lead = (start <= s.Length) ? s.Substring(0, start) : string.Empty; }
            catch { lead = string.Empty; }
            try { core = (start <= s.Length && start + coreLen <= s.Length) ? s.Substring(start, coreLen) : string.Empty; }
            catch { core = string.Empty; }
            try { trail = (end + 1 <= s.Length) ? s.Substring(end + 1) : string.Empty; }
            catch { trail = string.Empty; }
            return (lead, core, trail);
        }
    }
}



===== FILE: D:\TranslateTest2\Core\TextLangHelper.cs =====
using System;

namespace TranslateTest2.Core
{
    public static class TextLangHelper
    {
        // 日本語(ひらがな/カタカナ/半角カナ/漢字)かどうか
        public static bool IsJapaneseChar(char c)
        {
            // ひらがな
            if (c >= '\u3040' && c <= '\u309F') return true;
            // カタカナ
            if (c >= '\u30A0' && c <= '\u30FF') return true;
            // カタカナ拡張
            if (c >= '\u31F0' && c <= '\u31FF') return true;
            // CJK統合漢字
            if (c >= '\u4E00' && c <= '\u9FFF') return true;
            // 半角カナ
            if (c >= '\uFF66' && c <= '\uFF9D') return true;
            // 長音符
            if (c == '\u30FC') return true;
            return false;
        }

        // 空白/記号/数字などの中立文字か
        public static bool IsNeutral(char c)
        {
            if (char.IsWhiteSpace(c)) return true;
            if (char.IsDigit(c)) return true;
            // 一般的な記号は中立扱い
            if (char.IsPunctuation(c) || char.IsSymbol(c)) return true;
            return false;
        }

        // 文字列全体が日本語(と中立)のみで構成されるか
        public static bool IsJapaneseString(string s)
        {
            if (string.IsNullOrEmpty(s)) return true;
            foreach (var ch in s)
            {
                if (IsJapaneseChar(ch)) continue;
                if (IsNeutral(ch)) continue;
                return false; // 非日本語の文字を含む
            }
            return true;
        }

        // DeepLの対象にすべきか: 非日本語の文字(英字等)を含む
        public static bool NeedsTranslation(string s) => !IsJapaneseString(s);
    }
}



===== FILE: D:\TranslateTest2\Core\TooltipTranslator.cs =====
using System;
using System.Collections.Generic;
using System.IO;
using System.Reflection;
using System.Text;
using Terraria.ModLoader;

namespace TranslateTest2.Core
{
    /// <summary>
    /// ツールチップ文言の簡易置換辞書を管理します。
    /// 優先順: Assets/tooltip_dict.txt -> tooltip_dict.txt -> Content/tooltip_dict.txt -> 埋め込みリソース
    /// フォーマット: 1行に1エントリ、"原文 => 訳文" 形式。#で始まる行はコメント。
    /// </summary>
    public static class TooltipTranslator
    {
        private static Dictionary<string, string> _map = new(StringComparer.Ordinal);
    // 大文字小文字無視の完全一致用（線形探索削減）
    private static Dictionary<string, string> _mapIgnoreCase = new(StringComparer.OrdinalIgnoreCase);
        // 置換性能向上用: キー長の降順で事前インデックス
        private static List<KeyValuePair<string, string>> _sortedEntries = new();

        public static bool IsLoaded => _map.Count > 0;

        public static void Load(Mod mod)
        {
            _map.Clear();
            _mapIgnoreCase.Clear();
            _sortedEntries.Clear();

            // Mod内ファイルの探索候補
            string[] candidates = new[]
            {
                "Assets/tooltip_dict.txt",
                "tooltip_dict.txt",
                "Content/tooltip_dict.txt",
            };

            foreach (var path in candidates)
            {
                try
                {
                    using var s = mod.GetFileStream(path);
                    if (s != null)
                    {
                        using var sr = new StreamReader(s, Encoding.UTF8, true);
                        ParseIntoMap(sr);
                        RebuildIndex();
                        try { global::TranslateTest2.TranslateTest2.Instance?.Logger?.Info($"Tooltip dictionary loaded from {path} with {_map.Count} entries"); } catch { }
                        return;
                    }
                }
                catch
                {
                    // 次の候補へ
                }
            }

            // 埋め込みリソースからのフォールバック
            try
            {
                var asm = Assembly.GetExecutingAssembly();
                using var s = asm.GetManifestResourceStream("TranslateTest2.Assets.tooltip_dict.txt")
                             ?? asm.GetManifestResourceStream("TranslateTest2.tooltip_dict.txt")
                             ?? asm.GetManifestResourceStream("TranslateTest2.Content.tooltip_dict.txt");
                if (s != null)
                {
                    using var sr = new StreamReader(s, Encoding.UTF8, true);
                    ParseIntoMap(sr);
                    RebuildIndex();
                    try { global::TranslateTest2.TranslateTest2.Instance?.Logger?.Info($"Tooltip dictionary loaded from embedded resource with {_map.Count} entries"); } catch { }
                }
            }
            catch
            {
                // 読み込めない場合は空のまま
            }
        }

        public static void Unload()
        {
            _map.Clear();
            _mapIgnoreCase.Clear();
            _sortedEntries.Clear();
        }

        private static void ParseIntoMap(StreamReader sr)
        {
            string line;
            while ((line = sr.ReadLine()) != null)
            {
                line = line.Trim();
                if (line.Length == 0 || line.StartsWith("#"))
                    continue;

                // フォーマット: 原文 => 訳文
                int sep = line.IndexOf("=>", StringComparison.Ordinal);
                if (sep <= 0)
                    continue; // 不正行はスキップ

                var left = line.Substring(0, sep).Trim();
                var right = line.Substring(sep + 2).Trim();
                if (left.Length == 0)
                    continue;

                _map[left] = right;
                _mapIgnoreCase[left] = right; // 同期登録
            }
        }

        /// <summary>
        /// 1行のツールチップ文字列に対して辞書置換を適用します。
        /// 完全一致があればそれを優先。なければ全キーの部分一致置換を行います。
        /// </summary>
        public static string TranslateLine(string input)
        {
            if (_map.Count == 0 || string.IsNullOrEmpty(input))
                return input;

            // まずは大小区別での完全一致
            if (_map.TryGetValue(input, out var exact))
            {
#if DEBUG
                try { global::TranslateTest2.TranslateTest2.Instance?.Logger?.Debug($"Tooltip exact hit: '{input}' -> '{exact}'"); } catch { }
#endif
                return exact;
            }
            // 次に大小無視での完全一致（O(1)）
            if (_mapIgnoreCase.TryGetValue(input, out var ciValue))
            {
#if DEBUG
                try { global::TranslateTest2.TranslateTest2.Instance?.Logger?.Debug($"Tooltip exact (ci) hit: '{input}' -> '{ciValue}'"); } catch { }
#endif
                return ciValue;
            }

            string output = input;
            // 長いキーほど優先して置換する
            foreach (var kv in _sortedEntries)
            {
                output = ReplaceIgnoreCase(output, kv.Key, kv.Value);
            }
            
#if DEBUG
            if (!ReferenceEquals(output, input) && output != input)
            {
                try { global::TranslateTest2.TranslateTest2.Instance?.Logger?.Debug($"Tooltip substr hit: '{input}' -> '{output}'"); } catch { }
            }
#endif
            return output;
        }

        private static void RebuildIndex()
        {
            _sortedEntries = new List<KeyValuePair<string, string>>(_map.Count);
            foreach (var kv in _map)
                _sortedEntries.Add(kv);
            _sortedEntries.Sort((a, b) => b.Key.Length.CompareTo(a.Key.Length));
        }

        private static string ReplaceIgnoreCase(string input, string pattern, string replacement)
        {
            if (string.IsNullOrEmpty(input) || string.IsNullOrEmpty(pattern)) return input;
            // まず一度だけ探索し、ヒットが無ければ元文字列をそのまま返す（不要な StringBuilder 回避）
            int first = input.IndexOf(pattern, StringComparison.OrdinalIgnoreCase);
            if (first < 0) return input;
            int idx = 0;
            var sb = new System.Text.StringBuilder(input.Length + Math.Min(32, replacement?.Length ?? 0));
            // 先頭ヒット位置までコピー
            sb.Append(input, 0, first);
            sb.Append(replacement);
            idx = first + pattern.Length;
            while (true)
            {
                int hit = input.IndexOf(pattern, idx, StringComparison.OrdinalIgnoreCase);
                if (hit < 0)
                {
                    sb.Append(input, idx, input.Length - idx);
                    break;
                }
                sb.Append(input, idx, hit - idx);
                sb.Append(replacement);
                idx = hit + pattern.Length;
            }
            return sb.ToString();
        }
    }
}



===== FILE: D:\TranslateTest2\InventoryDragPort\AndroLib.cs =====
using Terraria.ModLoader;
using Terraria;
using System; // for Type
using System.Reflection; // for BindingFlags

namespace InventoryDrag.Compatability
{
    public static class AndroLib
    {
        internal const string androLib = "androLib";
        public static Mod Instance = null;
        public static bool Enabled = ModLoader.TryGetMod(androLib, out Instance);
        // Reflection cache
        private static Type _masterUIManagerType;
        private static PropertyInfo _propNoUIBeingHovered;
        private static PropertyInfo _propUIBeingHovered;
        private static bool _uiReflectionTried;
        private static void EnsureUIReflection()
        {
            if (_uiReflectionTried || !Enabled) return;
            _uiReflectionTried = true;
            _masterUIManagerType = Instance?.Code?.GetType("androLib.UI.MasterUIManager");
            if (_masterUIManagerType != null)
            {
                _propNoUIBeingHovered = _masterUIManagerType.GetProperty("NoUIBeingHovered", BindingFlags.Public|BindingFlags.Static);
                _propUIBeingHovered = _masterUIManagerType.GetProperty("UIBeingHovered", BindingFlags.Public|BindingFlags.Static);
            }
        }
        public static bool PreventDoubleClickInJourneyMode(int context, bool overrideShiftLeftClick) => Enabled && context == 29 & overrideShiftLeftClick;
        public static void Load(Mod mod)
        {
            if (!Enabled) return;
            AndroLibReference.Load();
            mod.AddContent<AndroLibPlayer>();
        }
        public static void Unload(Mod mod) => AndroLibReference.Unload();
    [JITWhenModsEnabled(new string[]{"androLib"})]
        public static bool DidBagSlotChange()
        {
            if (!Enabled || NoBagsHovered) return false;
            if (Main.LocalPlayer.TryGetModPlayer<AndroLibPlayer>(out var p)) return p.didSlotChange;
            return false;
        }
        // Access through reflection to avoid hard compile dependency when androLib not present.
    [JITWhenModsEnabled(new string[]{"androLib"})] public static bool NoBagsHovered
        {
            get
            {
                if (!Enabled) return true;
                EnsureUIReflection();
                return _propNoUIBeingHovered is null ? true : (bool)_propNoUIBeingHovered.GetValue(null);
            }
        }
    [JITWhenModsEnabled(new string[]{"androLib"})] public static int HoverId
        {
            get
            {
                if (!Enabled) return -1;
                EnsureUIReflection();
                return _propUIBeingHovered is null ? -1 : (int)_propUIBeingHovered.GetValue(null);
            }
        }
    [JITWhenModsEnabled(new string[]{"androLib"})] public static void UpdateBagSlotCache() { if (!Enabled) return; AndroLibReference.UpdateItemSlot(); }
    }
}



===== FILE: D:\TranslateTest2\InventoryDragPort\AndroLibPlayer.cs =====
using Terraria.ModLoader;
using Terraria;

namespace InventoryDrag.Compatability
{
    [Autoload(false)]
    public class AndroLibPlayer : ModPlayer
    {
        internal int slotIdCache;
        internal int slotIndexCache;
        internal bool didSlotChange;
        public void UpdateSlotChange(int slotId, int slotIndex)
        {
            if (Main.LocalPlayer.whoAmI != Player.whoAmI) return;
            didSlotChange = slotId != slotIdCache || slotIndex != slotIndexCache;
            slotIdCache = slotId;
            slotIndexCache = slotIndex;
        }
    }
}



===== FILE: D:\TranslateTest2\InventoryDragPort\AndroLibReference.cs =====
using System;
using System.Linq;
using System.Reflection;
using Terraria;
using Terraria.ModLoader;

namespace InventoryDrag.Compatability
{
    [JITWhenModsEnabled(new string[]{"androLib"})]
    public static class AndroLibReference
    {
        internal static FieldInfo BagUI_drawnUIData;
        private static Type BagUIType;
        private static FieldInfo _bagUIsField;
        private static PropertyInfo _hoveringProp;
        private static PropertyInfo _idProp;
        private static FieldInfo _slotDataField;
        private static PropertyInfo _isMouseHoveringProp; // reused dynamically if consistent
        private static bool _bagReflectionTried;
        private static void EnsureBagReflection()
        {
            if (_bagReflectionTried || !Compatability.AndroLib.Enabled) return;
            _bagReflectionTried = true;
            var storageManagerType = Compatability.AndroLib.Instance?.Code?.GetType("androLib.StorageManager");
            _bagUIsField = storageManagerType?.GetField("BagUIs", BindingFlags.Public|BindingFlags.Static);
            BagUIType = Compatability.AndroLib.Instance?.Code?.GetType("androLib.UI.BagUI");
            if (BagUIType != null)
            {
                _hoveringProp = BagUIType.GetProperty("Hovering", BindingFlags.Public|BindingFlags.Instance);
                _idProp = BagUIType.GetProperty("ID", BindingFlags.Public|BindingFlags.Instance);
                BagUI_drawnUIData = BagUIType.GetField("drawnUIData", BindingFlags.NonPublic | BindingFlags.Instance);
            }
        }
    // removed unused UIDataType
        public static void UpdateItemSlot()
        {
            if (!Compatability.AndroLib.Enabled) return;
            EnsureBagReflection();
            var bagUIs = _bagUIsField?.GetValue(null) as System.Collections.IEnumerable;
            object bagUi = null;
            if (bagUIs != null)
            {
                foreach (var ui in bagUIs)
                {
                    if (_hoveringProp != null && _hoveringProp.GetValue(ui) is bool hv && hv)
                    {
                        bagUi = ui; break;
                    }
                }
            }
            if (bagUi == null) return;
            var dataObj = BagUI_drawnUIData?.GetValue(bagUi);
            if (dataObj == null) return;
            if (_slotDataField == null)
                _slotDataField = dataObj.GetType().GetField("slotData", BindingFlags.Public|BindingFlags.NonPublic|BindingFlags.Instance);
            var slotArray = _slotDataField?.GetValue(dataObj) as System.Array;
            if (slotArray == null) return;
            int idx = -1;
            for (int i=0;i<slotArray.Length;i++)
            {
                var elem = slotArray.GetValue(i);
                if (elem == null) continue;
                var t = elem.GetType();
                var isHoverProp = _isMouseHoveringProp ?? t.GetProperty("IsMouseHovering", BindingFlags.Public|BindingFlags.Instance);
                if (_isMouseHoveringProp == null && isHoverProp != null) _isMouseHoveringProp = isHoverProp; // cache first found
                if (isHoverProp != null && isHoverProp.GetValue(elem) is bool b && b) { idx = i; break; }
            }
            if (idx == -1) return;
            int id = _idProp != null ? (int)_idProp.GetValue(bagUi) : -1;
            if (Main.LocalPlayer.TryGetModPlayer<AndroLibPlayer>(out var p)) p.UpdateSlotChange(id, idx);
        }
        public static void Load()
        {
            if (!Compatability.AndroLib.Enabled) return;
            EnsureBagReflection();
        }
        public static void Unload()
        {
            BagUI_drawnUIData = null;
            BagUIType = null;
            _bagUIsField = null;
            _hoveringProp = null;
            _idProp = null;
            _slotDataField = null;
            _isMouseHoveringProp = null;
            _bagReflectionTried = false;
        }
    }
}



===== FILE: D:\TranslateTest2\InventoryDragPort\InventoryConfig.cs =====
using Terraria.ModLoader;
using Terraria.ModLoader.Config;

namespace InventoryDrag.Config
{
    public class InventoryConfig : ModConfig
    {
        [Header("MainFeatures")] public LeftMouseOptions LeftMouse = new();
        public RightMouseOptions RightMouse = new();
        [Header("ExtraFeatures")] public SplittableGrabBags SplittableGrabBags = new();
        public ThrowDragging ThrowDragging = new();
        public bool DebugMessages;
        public static InventoryConfig Instance => ModContent.GetInstance<InventoryConfig>();
        public override ConfigScope Mode => ConfigScope.ClientSide;
    }
}



===== FILE: D:\TranslateTest2\InventoryDragPort\InventoryItem.cs =====
using System.Collections.Generic;
using Terraria;
using Terraria.Localization;
using Terraria.ModLoader;
using InventoryDrag.Config;

namespace InventoryDrag
{
    public class InventoryItem : GlobalItem
    {
        private static LocalizedText _toolipText = Language.GetText("Mods.TranslateTest2.GrabBagTooltip");
        public static bool CanShiftStack(Item item) => Main.ItemDropsDB.GetRulesForItemID(item.type).Count > 0;
        public override void ModifyTooltips(Item item, List<TooltipLine> tooltips)
        {
            var cfg = InventoryConfig.Instance.SplittableGrabBags;
            if (!cfg.Enabled || !cfg.ShowTooltip || !CanShiftStack(item)) return;
            int idx = tooltips.FindIndex(x => x.Name == "Tooltip0");
            if (idx == -1) idx = tooltips.Count;
            tooltips.Insert(idx, new TooltipLine(Mod, "Shift", _toolipText.Value));
        }
    }
}



===== FILE: D:\TranslateTest2\InventoryDragPort\InventoryPlayer.cs =====
using InventoryDrag.Config;
using InventoryDrag.Compatability;
using Microsoft.Xna.Framework;
using System.Reflection;
using Terraria;
using Terraria.Audio;
using Terraria.ID;
using Terraria.ModLoader;
using Terraria.UI;

namespace InventoryDrag
{
    public class InventoryPlayer : ModPlayer
    {
        internal int contextCache = -1;
        internal int slotCache = -1;
        internal int itemCache;
        internal bool hovering;
        internal bool noSlot = true;
        internal bool rightClickCache = Main.mouseRightRelease;
        internal bool leftClickCache = Main.mouseLeftRelease;
        internal bool overrideShiftLeftClick;
        internal static MethodInfo ItemSlot_OverrideLeftClick = typeof(ItemSlot).GetMethod("OverrideLeftClick", BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance);
        internal static MethodInfo ItemSlot_LeftClick_SellOrTrash = typeof(ItemSlot).GetMethod("LeftClick_SellOrTrash", BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance);
        public bool OverrideHover(Item[] inventory, int context, int slot)
        {
            if (Player.whoAmI != Main.LocalPlayer.whoAmI) return false;
            hovering = true;
            bool itemChanged = itemCache != inventory[slot].type && context == 29;
            bool changed = noSlot || contextCache != context || slotCache != slot || itemChanged || AndroLib.DidBagSlotChange();
            contextCache = context;
            slotCache = slot;
            itemCache = inventory[slot].type;
            AndroLib.UpdateBagSlotCache();
            bool isCoinOrTrash = context == 9 || context == 11;
            if (inventory[slot].IsAir && !isCoinOrTrash) return false;
            if (Main.mouseLeft && changed) return HandleLeftClick(inventory, context, slot);
            if (Main.mouseRight && changed) return HandleRightClick(inventory, context, slot);
            return false;
        }
        private bool HandleLeftClick(Item[] inventory, int context, int slot)
        {
            bool release = Main.mouseLeftRelease;
            if (release != leftClickCache) TranslateTest2.TranslateTest2.DebugInChat($"mouseLeftRelease == leftClickCache ({release == leftClickCache})");
            if (release || AndroLib.PreventDoubleClickInJourneyMode(context, overrideShiftLeftClick))
            {
                overrideShiftLeftClick = false;
                TranslateTest2.TranslateTest2.DebugInChat($"vanilla left click context: {context}, slot: {slot} item: {inventory[slot].type}");
                return false;
            }
            var left = InventoryConfig.Instance.LeftMouse;
            if (!left.Enabled || !left.ModifierOptions.IsSatisfied(Player)) return false;
            TranslateTest2.TranslateTest2.DebugInChat($"custom left click context: {context}, slot: {slot} item: {inventory[slot].type}");
            if (HandleDragThrowing(inventory, context, slot) || VanillaLeftClick(inventory, context, slot)) return true;
            Main.mouseLeftRelease = true;
            ItemSlot.LeftClick(inventory, context, slot);
            leftClickCache = false;
            Main.mouseLeftRelease = release;
            return true;
        }
        private bool HandleRightClick(Item[] inventory, int context, int slot)
        {
            bool release = Main.mouseRightRelease;
            bool canRightClick = context == 0 && ItemLoader.CanRightClick(inventory[slot]);
            bool contextSpecial = context == 7 || context == 22;
            if ((release || (rightClickCache && canRightClick)) || contextSpecial)
            {
                TranslateTest2.TranslateTest2.DebugInChat($"vanilla right click context: {context}, slot: {slot} release: {Main.mouseRightRelease} cache: {rightClickCache}");
                return false;
            }
            var right = InventoryConfig.Instance.RightMouse;
            if (!right.Enabled || !right.ModifierOptions.IsSatisfied(Player)) return false;
            TranslateTest2.TranslateTest2.DebugInChat($"custom right click context: {context}, slot: {slot} item: {inventory[slot].type}");
            if (HandleDragThrowing(inventory, context, slot)) return true;
            Main.mouseRightRelease = true;
            ItemSlot.RightClick(inventory, context, slot);
            Main.mouseRightRelease = release;
            return true;
        }
        private bool HandleDragThrowing(Item[] inventory, int context, int slot)
        {
            if (!(Player.controlThrow && context != 29)) return false;
            var cfg = InventoryConfig.Instance.ThrowDragging;
            Player.DropSelectedItem(0, ref inventory[slot]);
            Player.SetItemAnimation(cfg.ThrowDelay);
            if (cfg.PlaySound) SoundEngine.PlaySound(in SoundID.Grab, new Vector2());
            return true;
        }
        private static bool VanillaLeftClick(Item[] inventory, int context, int slot)
        {
            Player lp = Main.LocalPlayer;
            if (Main.mouseLeft)
            {
                if (ItemSlot_OverrideLeftClick != null && (bool)ItemSlot_OverrideLeftClick.Invoke(null, new object[]{inventory, context, slot})) return true;
                inventory[slot].newAndShiny = false;
                if (ItemSlot_LeftClick_SellOrTrash != null && (bool)ItemSlot_LeftClick_SellOrTrash.Invoke(null, new object[]{inventory, context, slot})) return true;
                if (lp.itemAnimation != 0 || lp.itemTime != 0) return true;
            }
            return false;
        }
        public override bool ShiftClickSlot(Item[] inventory, int context, int slot) => base.ShiftClickSlot(inventory, context, slot);
        public override void ResetEffects() { }
    }
}



===== FILE: D:\TranslateTest2\InventoryDragPort\LeftMouseOptions.cs =====
using System.Collections.Generic;

namespace InventoryDrag.Config
{
    public class LeftMouseOptions
    {
        public bool Enabled = true;
        public ModifierOptions ModifierOptions = new(true, true, true, true, true);
        public override bool Equals(object obj) => obj is LeftMouseOptions other && Enabled == other.Enabled && EqualityComparer<ModifierOptions>.Default.Equals(ModifierOptions, other.ModifierOptions);
        public override int GetHashCode() => System.HashCode.Combine(Enabled, ModifierOptions);
    }
}



===== FILE: D:\TranslateTest2\InventoryDragPort\ModifierOptions.cs =====
using Terraria;
using Terraria.UI;
using Microsoft.Xna.Framework.Input;

namespace InventoryDrag.Config
{
    public class ModifierOptions
    {
        public bool AllowCtrl = true;
        public bool AllowShift = true;
        public bool AllowAlt = true;
        public bool AllowThrow = true;
        public bool RequireModifier;
        public ModifierOptions() { }
        public ModifierOptions(bool allowCtrl, bool allowShift, bool allowAlt, bool allowThrow, bool requireModifier)
        {
            AllowCtrl = allowCtrl; AllowShift = allowShift; AllowAlt = allowAlt; AllowThrow = allowThrow; RequireModifier = requireModifier;
        }
        public bool IsSatisfied(Player player)
        {
            bool alt = Main.keyState.IsKeyDown(Main.FavoriteKey);
            bool ctrl = ItemSlot.ControlInUse;
            bool shift = ItemSlot.ShiftInUse;
            bool thr = player.controlThrow;
            if (!AllowAlt && alt) return false;
            if (!AllowCtrl && ctrl) return false;
            if (!AllowShift && shift) return false;
            if (!AllowThrow && thr) return false;
            if (RequireModifier && !(alt || ctrl || shift || thr)) return false;
            return true;
        }
        public override bool Equals(object obj)
        {
            return obj is ModifierOptions m && AllowCtrl == m.AllowCtrl && AllowShift == m.AllowShift && AllowAlt == m.AllowAlt && AllowThrow == m.AllowThrow && RequireModifier == m.RequireModifier;
        }
        public override int GetHashCode() => System.HashCode.Combine(AllowCtrl, AllowShift, AllowAlt, AllowThrow, RequireModifier);
    }
}



===== FILE: D:\TranslateTest2\InventoryDragPort\RightMouseOptions.cs =====
using System.Collections.Generic;

namespace InventoryDrag.Config
{
    public class RightMouseOptions
    {
        public bool Enabled = true;
        public ModifierOptions ModifierOptions = new()
        {
            AllowCtrl = true,
            AllowShift = true,
            AllowAlt = true,
            AllowThrow = false,
            RequireModifier = false
        };
        public override bool Equals(object obj) => obj is RightMouseOptions other && Enabled == other.Enabled && EqualityComparer<ModifierOptions>.Default.Equals(ModifierOptions, other.ModifierOptions);
        public override int GetHashCode() => System.HashCode.Combine(Enabled, ModifierOptions);
    }
}



===== FILE: D:\TranslateTest2\InventoryDragPort\SplittableGrabBags.cs =====
namespace InventoryDrag.Config
{
    public class SplittableGrabBags
    {
        public bool Enabled = true;
        public bool ShowTooltip = true;
        public override bool Equals(object obj) => obj is SplittableGrabBags s && Enabled == s.Enabled && ShowTooltip == s.ShowTooltip;
        public override int GetHashCode() => System.HashCode.Combine(Enabled, ShowTooltip);
    }
}



===== FILE: D:\TranslateTest2\InventoryDragPort\ThrowDragging.cs =====
namespace InventoryDrag.Config
{
    public class ThrowDragging
    {
        public bool PlaySound = true;
        [Terraria.ModLoader.Config.Range(0,100)]
        public int ThrowDelay = 10; // ticks
        public override bool Equals(object obj) => obj is ThrowDragging o && PlaySound == o.PlaySound && ThrowDelay == o.ThrowDelay;
        public override int GetHashCode() => System.HashCode.Combine(PlaySound, ThrowDelay);
    }
}



===== FILE: D:\TranslateTest2\Items\BiomeInfoAccessoryGlobalItem.cs =====
using Terraria;
using Terraria.ID;
using Terraria.ModLoader;

namespace TranslateTest2.Items
{
    public class BiomeInfoAccessoryGlobalItem : GlobalItem
    {
        public override void UpdateInfoAccessory(Item item, Player player)
        {
            switch (item.type)
            {
                case ItemID.PDA:
                case ItemID.CellPhone:
                case ItemID.Shellphone:
                case ItemID.ShellphoneSpawn:
                case ItemID.ShellphoneHell:
                case ItemID.ShellphoneOcean:
                    player.GetModPlayer<Core.InfoPlayer>().biomeDisplay = true;
                    break;
            }
        }
    }
}



===== FILE: D:\TranslateTest2\Items\TooltipTranslateGlobalItem.cs =====
using Microsoft.Xna.Framework.Input;
using System.Collections.Generic;
using System.Linq;
using Terraria;
using Terraria.ModLoader;
using TranslateTest2.Core;
using System.Text.RegularExpressions;

namespace TranslateTest2.Items
{
    /// <summary>
    /// 最適化版: 安全性とパフォーマンスを向上させたツールチップ翻訳処理
    /// </summary>
    public class TooltipTranslateGlobalItem : GlobalItem
    {
        // パフォーマンス最適化: HashSetを使用してO(1)の星文字判定
        private static readonly HashSet<char> StarCharsSet = new HashSet<char> 
        { 
            '*', '＊', '★', '☆', '✦', '✧', '✪', '✩', '❋', '✱', '﹡', '∗' 
        };

        private static bool IsStarChar(char c) => StarCharsSet.Contains(c);

        private static readonly System.Text.RegularExpressions.Regex StarTagRegex = new System.Text.RegularExpressions.Regex(
            $@"^\[[^\]]*:[{System.Text.RegularExpressions.Regex.Escape(new string(StarCharsSet.ToArray()))}]\]$", 
            System.Text.RegularExpressions.RegexOptions.Compiled);

        // キャッシュによる最適化
        private static readonly Dictionary<string, bool> StarTokenCache = new Dictionary<string, bool>();
        private static readonly Dictionary<string, List<(string text, bool protect)>> SegmentCache = new Dictionary<string, List<(string text, bool protect)>>();
        
        // キャッシュサイズ制限（メモリリーク防止）
        private const int MAX_CACHE_SIZE = 1000;
        private static int _cacheCleanupCounter = 0;

        // 安全なShift判定 - より効率的
        private static bool IsShiftPressed()
        {
            try
            {
                var keyboardState = Keyboard.GetState();
                return keyboardState.IsKeyDown(Keys.LeftShift) || keyboardState.IsKeyDown(Keys.RightShift);
            }
            catch
            {
                return false; // エラー時はデフォルトで false
            }
        }

        // 最適化された保護セグメント分割（IndexOutOfRangeException対策強化版）
        private static List<(string text, bool protect)> SplitProtectedSegments(string input)
        {
            if (string.IsNullOrEmpty(input))
                return new List<(string, bool)> { (input ?? string.Empty, false) };

            // キャッシュチェック
            if (SegmentCache.TryGetValue(input, out var cached))
                return cached;

            var list = new List<(string, bool)>();
            int i = 0;
            int safetyCounter = 0;
            const int maxSegments = 1024; // より現実的な上限
            const int maxIterations = 4096; // 無限ループ防止
            int inputLength = input.Length;

            while (i < inputLength && safetyCounter < maxIterations)
            {
                safetyCounter++;
                
                if (list.Count > maxSegments)
                {
                    list.Add((input.Substring(i), false));
                    break;
                }

                try
                {
                    char c = input[i];
                    
                    if (c == '[')
                    {
                        int start = i;
                        int j = input.IndexOf(']', i + 1);
                        if (j >= 0 && j < inputLength)
                        {
                            list.Add((input.Substring(start, j - start + 1), true));
                            i = j + 1;
                            continue;
                        }
                    }
                    else if (IsStarChar(c))
                    {
                        int start = i;
                        int j = input.IndexOf(c, i + 1);
                        if (j >= 0 && j < inputLength)
                        {
                            list.Add((input.Substring(start, j - start + 1), true));
                            i = j + 1;
                            continue;
                        }
                    }

                    // 非保護の連続部分を効率的に収集
                    int begin = i;
                    while (i < inputLength && 
                           i < input.Length && // 二重チェック
                           input[i] != '[' && 
                           !IsStarChar(input[i]))
                    {
                        i++;
                    }
                    
                    if (i > begin)
                    {
                        list.Add((input.Substring(begin, i - begin), false));
                    }
                    else
                    {
                        // 1文字前進（デッドロック防止）
                        if (i < inputLength)
                        {
                            list.Add((input[i].ToString(), false));
                            i++;
                        }
                        else
                        {
                            break; // 安全のための脱出
                        }
                    }
                }
                catch (System.IndexOutOfRangeException)
                {
                    // 境界外アクセスの場合は安全に終了
                    break;
                }
                catch (System.Exception ex)
                {
                    TranslateTest2.Instance?.Logger?.Debug($"Error in segment splitting: {ex.Message}");
                    break;
                }
            }

            // キャッシュに保存（サイズ制限付き）
            if (SegmentCache.Count < MAX_CACHE_SIZE)
            {
                SegmentCache[input] = list;
            }

            return list;
        }

        // 最適化された辞書翻訳
        private static string DictionaryProtectedTranslate(string input)
        {
            if (string.IsNullOrEmpty(input))
                return input;

            try
            {
                var segs = SplitProtectedSegments(input);
                PromoteBetweenStarTokens(segs);

                if (segs.Count == 1 && !segs[0].protect)
                {
                    return TooltipTranslator.TranslateLine(segs[0].text);
                }

                var sb = new System.Text.StringBuilder(input.Length + 32);
                foreach (var (seg, protect) in segs)
                {
                    sb.Append(protect ? seg : TooltipTranslator.TranslateLine(seg));
                }
                return sb.ToString();
            }
            catch
            {
                return input;
            }
        }

        private static void PromoteBetweenStarTokens(List<(string text, bool protect)> segs)
        {
            if (segs?.Count <= 2) return; // 最低3要素必要

            for (int i = 0; i < segs.Count - 2; i++)
            {
                if (segs[i].protect && IsStarTokenSegment(segs[i].text))
                {
                    // 右側の星トークンを探す
                    for (int j = i + 2; j < segs.Count; j++)
                    {
                        if (segs[j].protect && IsStarTokenSegment(segs[j].text))
                        {
                            // 中間要素を保護に昇格
                            for (int k = i + 1; k < j; k++)
                            {
                                if (!segs[k].protect)
                                    segs[k] = (segs[k].text, true);
                            }
                            i = j; // 次の検索開始位置
                            break;
                        }
                    }
                }
            }
        }

        private static bool IsStarTokenSegment(string s)
        {
            if (string.IsNullOrEmpty(s))
                return false;

            // キャッシュチェック
            if (StarTokenCache.TryGetValue(s, out bool cachedResult))
                return cachedResult;

            bool result = false;

            try
            {
                // 単一の星文字
                if (s.Length == 1 && IsStarChar(s[0]))
                {
                    result = true;
                }
                // ブラケットタグの星判定
                else if (s.Length >= 4 && s[0] == '[' && s[s.Length - 1] == ']')
                {
                    result = StarTagRegex.IsMatch(s);
                }

                // キャッシュに保存（サイズ制限付き）
                if (StarTokenCache.Count < MAX_CACHE_SIZE)
                {
                    StarTokenCache[s] = result;
                }
            }
            catch
            {
                result = false;
            }

            return result;
        }

        private static string DeepLProtectedTranslate(string input)
        {
            if (string.IsNullOrEmpty(input))
                return input;

            try
            {
                var segs = SplitProtectedSegments(input);
                PromoteBetweenStarTokens(segs);

                if (segs.Count == 1 && !segs[0].protect)
                {
                    var text = segs[0].text;
                    if (TextLangHelper.NeedsTranslation(text))
                    {
                        if (DeepLTranslator.TryGetCached(text, out var cached))
                            return cached;
                        DeepLTranslator.RequestIfMissing(text);
                    }
                    return text;
                }

                var sb = new System.Text.StringBuilder(input.Length + 32);
                foreach (var (seg, protect) in segs)
                {
                    if (protect)
                    {
                        sb.Append(seg);
                    }
                    else if (TextLangHelper.NeedsTranslation(seg))
                    {
                        if (DeepLTranslator.TryGetCached(seg, out var cached))
                        {
                            sb.Append(cached);
                        }
                        else
                        {
                            DeepLTranslator.RequestIfMissing(seg);
                            sb.Append(seg);
                        }
                    }
                    else
                    {
                        sb.Append(seg);
                    }
                }
                return sb.ToString();
            }
            catch
            {
                return input;
            }
        }

        private static string HardProtectStarBlocks(string input)
        {
            if (string.IsNullOrEmpty(input))
                return input;

            try
            {
                var segs = SplitProtectedSegments(input);
                PromoteBetweenStarTokens(segs);
                
                if (segs.Count == 1)
                    return input;

                var sb = new System.Text.StringBuilder(input.Length + 16);
                foreach (var (seg, _) in segs)
                {
                    sb.Append(seg);
                }
                return sb.ToString();
            }
            catch
            {
                return input;
            }
        }

        private static bool HasProtectedStarBlock(string input)
        {
            if (string.IsNullOrEmpty(input))
                return false;

            try
            {
                var segs = SplitProtectedSegments(input);
                PromoteBetweenStarTokens(segs);
                for (int i = 0; i < segs.Count; i++)
                {
                    var seg = segs[i];
                    if (seg.protect && !IsStarTokenSegment(seg.text) && !string.IsNullOrWhiteSpace(seg.text))
                        return true;
                }
                return false;
            }
            catch
            {
                return false;
            }
        }

        // パフォーマンス改善のためキャッシュをクリア
        public static void ClearCaches()
        {
            StarTokenCache.Clear();
            SegmentCache.Clear();
        }

        public override void ModifyTooltips(Item item, List<TooltipLine> tooltips)
        {
            if (item?.active != true || tooltips?.Count == 0) return;

            bool shift = IsShiftPressed();
            if (!shift && !DeepLTranslator.IsEnabled) return; // 早期リターン最適化

            // 定期的なキャッシュクリア（メモリリーク防止）- より効率的な間隔
            if (++_cacheCleanupCounter >= 7200) // 約2分に1回に延長
            {
                _cacheCleanupCounter = 0;
                if (StarTokenCache.Count > MAX_CACHE_SIZE || SegmentCache.Count > MAX_CACHE_SIZE)
                {
                    // より保守的なクリア（半分だけクリアして有用なキャッシュを保持）
                    if (StarTokenCache.Count > MAX_CACHE_SIZE)
                    {
                        var toRemove = StarTokenCache.Keys.Take(StarTokenCache.Count / 2).ToArray();
                        foreach (var key in toRemove)
                        {
                            StarTokenCache.Remove(key);
                        }
                    }
                    
                    if (SegmentCache.Count > MAX_CACHE_SIZE)
                    {
                        var toRemove = SegmentCache.Keys.Take(SegmentCache.Count / 2).ToArray();
                        foreach (var key in toRemove)
                        {
                            SegmentCache.Remove(key);
                        }
                    }
                }
            }

            for (int i = 0; i < tooltips.Count; i++)
            {
                var line = tooltips[i];
                if (line?.Text == null) continue;

                try
                {
                    string text = line.Text;
                    if (string.IsNullOrWhiteSpace(text)) continue;

                    // 星囲みブロックの保護
                    text = HardProtectStarBlocks(text);

                    // アイテム名の日本語語順再構成
                    if (line.Mod == "Terraria" && line.Name == "ItemName" && !HasProtectedStarBlock(text))
                    {
                        try
                        {
                            if (NameComposer.TryCompose(text, out var composed))
                                text = composed;
                        }
                        catch { /* 継続 */ }
                    }

                    // 辞書翻訳（Shift押下時のみ、Terraira製のみ）
                    if (shift && line.Mod == "Terraria")
                    {
                        text = DictionaryProtectedTranslate(text);
                    }

                    // DeepL翻訳（Shift押下時のみ）
                    if (shift && DeepLTranslator.IsEnabled && TextLangHelper.NeedsTranslation(text))
                    {
                        text = DeepLProtectedTranslate(text);
                    }

                    line.Text = text;
                }
                catch (System.Exception ex)
                {
                    TranslateTest2.Instance?.Logger?.Warn($"Tooltip error: {ex.GetType().Name}: {ex.Message}");
                }
            }
        }
    }
}



===== FILE: D:\TranslateTest2\Localization\en-US_Mods.TranslateTest2.hjson =====
Configs: {
	ClientConfig: {
		DisplayName: Client Settings
		Headers.DeepL: DeepL Settings

		DeepLApiKey: {
			Label: DeepL API Key
			Tooltip: Enter your DeepL API auth_key. Stored client-side only.
		}

		TargetLang: {
			Label: Target Language
			Tooltip: DeepL target language code, e.g. JA, EN-US, EN-GB, ZH.
		}

		UseDeepL: {
			Label: Use DeepL
			Tooltip: Enable DeepL translation for tooltips and item names. Requires API key.
		}

		CacheDeepL: {
			Label: Cache DeepL
			Tooltip: Cache translated strings locally to avoid repeated DeepL requests.
		}

		ShowShiftIndicator: {
			Label: Show Shift Indicator
			Tooltip: Show a small "[Shift-Translate]" marker when translation is active.
		}

		EnableNameReconstruction: {
			Label: Enable Name Reconstruction
			Tooltip: Reconstruct item names like 'Legendary ... of ...' into natural Japanese order
		}

		SkipBracketContentInNames: {
			Label: Skip [brackets] in names
			Tooltip: Do not translate content inside square brackets in item names (e.g., [ModName]).
		}

		DeepLTimeoutMs: {
			Label: DeepL Timeout (ms)
			Tooltip: HTTP timeout per DeepL request (milliseconds).
		}

		DeepLBatchIntervalMs: {
			Label: DeepL Batch Interval (ms)
			Tooltip: Wait time to accumulate texts before sending a batch (milliseconds).
		}

		DeepLBatchMax: {
			Label: DeepL Batch Size
			Tooltip: Maximum number of texts to send per batch request.
		}

		DeepLEndpointPreference: {
			Label: DeepL Endpoint Preference
			Tooltip: Choose which endpoint to use: auto, free, or paid.
		}

		DeepLRetryCount: {
			Label: DeepL Retry Count
			Tooltip: Number of retry attempts when a request fails.
		}

		DeepLRetryInitialDelayMs: {
			Label: DeepL Retry Initial Delay (ms)
			Tooltip: Initial delay before retrying failed requests (milliseconds). Doubles each attempt.
		}

		ProxyUrl: {
			Label: Proxy Url
			Tooltip: Optional HTTP proxy URL (e.g. http://127.0.0.1:8080). Leave empty to disable.
		}
	}

	BiomeDisplayClientConfig: {
		DisplayName: Biome Display Settings
		Headers.BiomeDisplay: Biome Display

		simpleDisplay: {
			Label: Simple Display
			Tooltip:
				'''
				Removes extra symbols from certain cycling info displays.
				Specifically removes the '+' suffix from displays that cycle multiple values
				and removes the '~' (approximate) marker from the spawn rate / cap display.
				Affects: Biome, Combo, Spawn Rate / Cap displays.
				'''
		}
	}

	InventoryConfig: {
		DisplayName: Inventory Config

		Headers: {
			MainFeatures: Main Features Header
			ExtraFeatures: Extra Features Header
		}

		LeftMouse: {
			Label: Left Mouse
			Tooltip: ""
		}

		RightMouse: {
			Label: Right Mouse
			Tooltip: ""
		}

		SplittableGrabBags: {
			Label: Splittable Grab Bags
			Tooltip: ""
		}

		ThrowDragging: {
			Label: Throw Dragging
			Tooltip: ""
		}

		DebugMessages: {
			Label: Debug Messages
			Tooltip: ""
		}
	}

	LeftMouseOptions: {
		Tooltip: ""

		Enabled: {
			Label: Enabled
			Tooltip: ""
		}

		ModifierOptions: {
			Label: Modifier Options
			Tooltip: ""
		}
	}

	ModifierOptions: {
		Tooltip: ""

		AllowCtrl: {
			Label: Allow Ctrl
			Tooltip: ""
		}

		AllowShift: {
			Label: Allow Shift
			Tooltip: ""
		}

		AllowAlt: {
			Label: Allow Alt
			Tooltip: ""
		}

		AllowThrow: {
			Label: Allow Throw
			Tooltip: ""
		}

		RequireModifier: {
			Label: Require Modifier
			Tooltip: ""
		}
	}

	RightMouseOptions: {
		Tooltip: ""

		Enabled: {
			Label: Enabled
			Tooltip: ""
		}

		ModifierOptions: {
			Label: Modifier Options
			Tooltip: ""
		}
	}

	SplittableGrabBags: {
		Tooltip: ""

		Enabled: {
			Label: Enabled
			Tooltip: ""
		}

		ShowTooltip: {
			Label: Show Tooltip
			Tooltip: ""
		}
	}

	ThrowDragging: {
		Tooltip: ""

		PlaySound: {
			Label: Play Sound
			Tooltip: ""
		}

		ThrowDelay: {
			Label: Throw Delay
			Tooltip: ""
		}
	}
}

Prefixes: {
	Abusive.DisplayName: Abusive
	Affable.DisplayName: Affable
	Blessing.DisplayName: Blesseing
	Brisk.DisplayName: Brisk
	Contract.DisplayName: Contract
	Devoted.DisplayName: Devoted
	Deviation.DisplayName: Deviation
	Eager.DisplayName: Eager
	Echo.DisplayName: Echo
	Electrified.DisplayName: Electrified
	Extended.DisplayName: Extended
	Fabled.DisplayName: Fabled
	Focused.DisplayName: Focused
	Focused_Whip.DisplayName: Focused
	Huge.DisplayName: Huge
	Loyal.DisplayName: Loyal
	Mega.DisplayName: Mega
	Oracle.DisplayName: Oracle
	Overload.DisplayName: Overload
	Steady.DisplayName: Steady
	Vengeful.DisplayName: Vengeful
}

"Keybinds.DeepL Status.DisplayName": DeepL Status
PrefixVengefulDescr: Apply additional tag to the target, increasing the damage of minions by {A}% of item damage({B})
PrefixExtendedDescr: +{V}% Whip Range
PrefixAffableDescr: -{A}%({B}) Minion Slots using
PrefixMegaDescr:
	'''
	+100% Minion Slot using
	+100% Minion Size
	+100% Minion Knockback
	'''
PrefixBriskDescr: +{}% Minion Attack Speed
PrefixDeviationDescr: The projectile of the summoning object is even more inaccurate
PrefixSteadyDescr: -{}% Minion Attack Speed
PrefixHugeDescr: +{}% Minion Size
PrefixEchoDescr: Minions has a chance to shoot double projectiles
PrefixBlessingDescr: Minions will provide players nearby some bonus
PrefixContractDescr:
	'''
	Minions heal you for {A}% max HP per hit
	-{B} armor per minion
	'''
PrefixDevotedDescr:
	'''
	Tag hitted enemies
	+{A}% Damage to enemies that has tag
	otherwise -{B}% Damage
	'''
PrefixOverloadDescr: +100% Minion Attack Speed
PrefixAbusiveDescr: +{}% Minion Crit Chance
PrefixEagerDescr: +{}% Minion Attack Speed
PrefixFocusedDescr: +{A}%({B}) Minion Slots using
PrefixLoyalDescr:
	'''
	+{A}%({B}) Minion Slots using
	+{C}% Minion Crit Chance
	'''
PrefixFabledDescr:
	'''
	-{A}%({B}) Minion Slots using
	+{C}% Minion Crit Chance
	+{D}% Minion Knockback
	'''
PrefixOracleDescr:
	'''
	Apply additional tag to the target, 
	increasing the damage of minions by {A}% of item damage({B}),
	gain {C}% minion crit chance
	+{D}% Whip Range
	'''
Projectiles.ElectricLaser.DisplayName: Electric Laser
PrefixElectrifiedDescr: Continuously generate lightning chains to connect you and minions, with lightning damage based on your maximum health
PrefixFocused_WhipDescr: When helding, +{A}%Summon Damage, but -{B} Minion Slot

Biomes: {
	Neutral: None

	Vanilla: {
		Space: Space
		Underworld: Underworld
		Underground: Underground
		Solar: Solar Pillar
		Vortex: Vortex Pillar
		Nebula: Nebula Pillar
		Stardust: Stardust Pillar
		Meteor: Meteor
		Dungeon: Dungeon
		Temple: Jungle Temple
		Aether: Aether
		Spider: Spider Cave
		Corruption: Corruption
		Crimson: Crimson
		Shroom: Mushroom
		Jungle: Jungle
		Hallow: Hallow
		Ocean: Ocean
		Snow: Snow
		Desert: Desert
		Beehive: Beehive
		Granite: Granite Cave
		Marble: Marble Cave
		Graveyard: Graveyard
		Forest: Forest
		Town: Town
	}
}

InfoDisplays.BiomeInfoDisplay.DisplayName: Nearby Biomes
GrabBagTooltip: Shift + Right Click to split



===== FILE: D:\TranslateTest2\Localization\ja-JP_Mods.TranslateTest2.hjson =====
Configs: {
	ClientConfig: {
		DisplayName: クライアント設定
		Headers.DeepL: DeepL設定

		DeepLApiKey: {
			Label: DeepL APIキー
			Tooltip: DeepL API auth_keyを入力してください。クライアント側にのみ保存されます。
		}

		TargetLang: {
			Label: 対象言語
			Tooltip: DeepLの対象言語コード例：JA, EN-US, EN-GB, ZH
		}

		UseDeepL: {
			Label: DeepLを使用
			Tooltip: ツールチップとアイテム名のDeepL翻訳を有効化。APIキーが必要です。
		}

		CacheDeepL: {
			Label: DeepLキャッシュ
			Tooltip: 翻訳済み文字列をローカルキャッシュしてDeepL要求の重複を避けます。
		}

		ShowShiftIndicator: {
			Label: Shiftインジケータ表示
			Tooltip: "翻訳が有効な時に小さな\"[Shift-翻訳]\"マーカーを表示します。"
		}

		EnableNameReconstruction: {
			Label: 名前再構成を有効化
			Tooltip: "\"Legendary ... of ...\"のようなアイテム名を自然な日本語語順に再構成"
		}

		"SkipBracketContentInNames": {
			Label: "名前の[括弧]をスキップ"
			Tooltip: "アイテム名の角括弧内コンテンツを翻訳しません（例：[ModName]）。"
		}

		DeepLTimeoutMs: {
			Label: DeepLタイムアウト(ms)
			Tooltip: DeepLリクエスト毎のHTTPタイムアウト（ミリ秒）。
		}

		DeepLBatchIntervalMs: {
			Label: DeepLバッチ間隔(ms)
			Tooltip: バッチ送信前にテキストを蓄積する待機時間（ミリ秒）。
		}

		DeepLBatchMax: {
			Label: DeepLバッチサイズ
			Tooltip: バッチリクエスト毎の最大テキスト数。
		}

		DeepLEndpointPreference: {
			Label: DeepLエンドポイント設定
			Tooltip: 使用するエンドポイントを選択：auto, free, paid
		}

		DeepLRetryCount: {
			Label: DeepL再試行回数
			Tooltip: リクエスト失敗時の再試行回数。
		}

		DeepLRetryInitialDelayMs: {
			Label: DeepL再試行初期遅延(ms)
			Tooltip: 失敗したリクエストの再試行前の初期遅延（ミリ秒）。試行毎に倍増。
		}

		ProxyUrl: {
			Label: プロキシURL
			Tooltip: "オプションのHTTPプロキシURL（例：http://127.0.0.1:8080）。空の場合無効。"
		}
	}

	BiomeDisplayClientConfig: {
		DisplayName: バイオーム表示設定
		Headers.BiomeDisplay: バイオーム表示

		simpleDisplay: {
			Label: 簡易ディスプレイ
			Tooltip:
				'''
				一部のサイクル表示から余計な記号を削除します。
				具体的には複数情報を切り替えるディスプレイの「+」記号と、
				敵出現率/上限ディスプレイの「~」(概算記号) を取り除きます。
				影響する対象: バイオーム / コンボ / 敵出現率・上限 ディスプレイ。
				'''
		}
}

	# ===== InventoryDrag 設定ブロック（Configキー配下に統合） =====
	InventoryConfig: {
		DisplayName: 設定

		Headers: {
			MainFeatures: 機能全般
			ExtraFeatures: 追加機能
		}

		LeftMouse: {
			Label: 左マウス
			Tooltip: マウスの左ボタンによるドラッグの設定
		}
		RightMouse: {
			Label: 右マウス
			Tooltip: マウスの右ボタンによるドラッグの設定
		}
		SplittableGrabBags: {
			Label: 分割トレジャーバッグ
			Tooltip: トレジャーバッグの分割用設定
		}
		ThrowDragging: {
			Label: Throw ドラッグ
			Tooltip: ""
		}
		DebugMessages: {
			Label: Debug メッセージ
			Tooltip: ""
		}
	}

	LeftMouseOptions: {
		Tooltip: ""
		Enabled: {
			Label: 有効
			Tooltip: オフにすると、マウスの左ボタンを押したままのドラッグが無効になる
		}
		ModifierOptions: {
			Label: モディファイア設定
			Tooltip: マウスの左ボタンで使用できるモディファイアを設定する
		}
	}

	RightMouseOptions: {
		Tooltip: ""
		Enabled: {
			Label: 有効
			Tooltip: オフにすると、マウスの右ボタンを押したままのドラッグが無効になる
		}
		ModifierOptions: {
			Label: モディファイア設定
			Tooltip: マウスの右ボタンで使用できるモディファイアを設定する
		}
	}

	ModifierOptions: {
		Tooltip: ""
		AllowCtrl: {
			Label: Ctrlを許可する
			Tooltip: オフにすると、Ctrlを押しながらのドラッグが無効になる
		}
		AllowShift: {
			Label: Shiftを許可する
			Tooltip: オフにすると、Shiftを押しながらのドラッグが無効になる
		}
		AllowAlt: {
			Label: Altを許可する
			Tooltip: オフにすると、Altを押しながらのドラッグが無効になる
		}
		AllowThrow: {
			Label: 投げるを許可する
			Tooltip: オフにすると、投げるキーを押しながらのドラッグが無効になる
		}
		RequireModifier: {
			Label: モディファイアを要求する
			Tooltip: ドラッグを有効にするためにモディファイア（Ctrl、Shift、Altなど）が必要な場合はオンを推奨
		}
	}

	SplittableGrabBags: {
		Tooltip: ""
		Enabled: {
			Label: 有効
			Tooltip: Shift + 右クリックでバッグを開く代わりに分割する
		}
		ShowTooltip: {
			Label: ツールチップの表示
			Tooltip: ツールチップにコントロールを表示する
		}
	}

	ThrowDragging: {
		Tooltip: ""
		PlaySound: {
			Label: サウンドを再生
			Tooltip: アイテムを投げるときに音を鳴らす
		}
		ThrowDelay: {
			Label: スローディレイ
			Tooltip: スローの間隔をティック単位でどれだけディレイをかけるかを設定する（60ティック＝1秒）
		}
	}
}

Prefixes: {
	# Prefix名の表示名（DisplayName）のみを保持
	Abusive: {
		DisplayName: 虐待的な
	}

	Affable: {
		DisplayName: 親しみやすい
	}

	Blessing: {
		DisplayName: 祝福の
	}

	Brisk: {
		DisplayName: 機敏な
	}

	Contract: {
		DisplayName: 契約の
	}

	Devoted: {
		DisplayName: 献身的な
	}

	Deviation: {
		DisplayName: 逸脱した
	}

	Eager: {
		DisplayName: 熱心な
	}

	Echo: {
		DisplayName: 反響する
	}

	Electrified: {
		DisplayName: 帯電した
	}

	Extended: {
		DisplayName: 延びる
	}

	Fabled: {
		DisplayName: 伝説の
	}

	Focused: {
		DisplayName: 集中する
	}

	Focused_Whip: {
		DisplayName: 集中する
	}

	Huge: {
		DisplayName: 巨大な
	}

	Loyal: {
		DisplayName: 忠実な
	}

	Mega: {
		DisplayName: メガ
	}

	Oracle: {
		DisplayName: 神託の
	}

	Overload: {
		DisplayName: 過負荷の
	}

	Steady: {
		DisplayName: 安定した
	}

	Vengeful: {
		DisplayName: 復讐の
	}

	}

Keybinds: {
	"DeepL Status": {
		DisplayName: DeepLステータス
	}
}

PrefixVengefulDescr: ターゲットに追加タグを付与し、ミニオンダメージがアイテムダメージの{A}%増加（{B}）

PrefixExtendedDescr: 鞭の攻撃範囲+{V}%

PrefixAffableDescr: ミニオンスロット使用量-{A}%（{B}）

PrefixMegaDescr:
	'''
	ミニオンスロット使用量+100%
	ミニオンサイズ+100%
	ミニオンノックバック+100%
	'''

PrefixBriskDescr: ミニオン攻撃速度+{}%

PrefixDeviationDescr: 召喚対象の攻撃の精度がさらに不正確になる

PrefixSteadyDescr: ミニオン攻撃速度-{}%

PrefixHugeDescr: ミニオンサイズ+{}%

PrefixEchoDescr: ミニオンが二重に攻撃を放つチャンスがある

PrefixBlessingDescr: ミニオンが近くのプレイヤーにボーナスを与える

PrefixContractDescr:
	'''
	ミニオンがヒット時に最大HPの{A}%を回復
	ミニオン1体あたり防御力-{B}
	'''

PrefixDevotedDescr:
	'''
	攻撃した敵にタグを付与
	タグ付きの敵にダメージ+{A}%
	そうでなければダメージ-{B}%
	'''

PrefixOverloadDescr: ミニオン攻撃速度+100%

PrefixAbusiveDescr: ミニオンクリティカル率+{}%

PrefixEagerDescr: ミニオン攻撃速度+{}%

PrefixFocusedDescr: ミニオンスロット使用量+{A}%（{B}）

PrefixLoyalDescr:
	'''
	ミニオンスロット使用量+{A}%（{B}）
	ミニオンクリティカル率+{C}%
	'''

PrefixFabledDescr:
	'''
	ミニオンスロット使用量-{A}%（{B}）
	ミニオンクリティカル率+{C}%
	ミニオンノックバック+{D}%
	'''

PrefixOracleDescr:
	'''
	ターゲットに追加タグを付与、
	ミニオンダメージがアイテムダメージの{A}%増加（{B}）、
	ミニオンクリティカル率+{C}%
	鞭の攻撃範囲+{D}%
	'''

Projectiles: {
	ElectricLaser: {
		DisplayName: 電気レーザー
	}
}

PrefixElectrifiedDescr: あなたとミニオンを結ぶ雷の鎖を継続的に生成、雷ダメージは最大ライフに基づく

PrefixFocused_WhipDescr: 持っている間、召喚ダメージ+{A}%、しかしミニオンスロット-{B}
Biomes: {
	Neutral: なし
	Vanilla: {
		Space: 宇宙
		Underworld: 地下世界
		Underground: 地下
		Solar: ソーラーピラー
		Vortex: ボルテックスピラー
		Nebula: ネビュラピラー
		Stardust: スターダストピラー
		Meteor: 隕石
		Dungeon: ダンジョン
		Temple: ジャングル寺院
		Aether: エーテル
		Spider: クモの巣
		Corruption: 不浄の地
		Crimson: 真紅の地
		Shroom: キノコ群生地
		Jungle: ジャングル
		Hallow: 聖域
		Ocean: 海
		Snow: 雪原
		Desert: 砂漠
		Beehive: ハチの巣
		Granite: 御影石の洞窟
		Marble: 大理石の洞窟
		Graveyard: 墓地
		Forest: 森林
		Town: 町
	}
}

InfoDisplays: {
	BiomeInfoDisplay.DisplayName: 近くのバイオーム
}

GrabBagTooltip: Shift + 右クリックで分割




===== FILE: D:\TranslateTest2\obj\Debug\net8.0\.NETCoreApp,Version=v8.0.AssemblyAttributes.cs =====
// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v8.0", FrameworkDisplayName = ".NET 8.0")]



===== FILE: D:\TranslateTest2\obj\Debug\net8.0\TranslateTest2.AssemblyInfo.cs =====
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("TranslateTest2")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0")]
[assembly: System.Reflection.AssemblyProductAttribute("TranslateTest2")]
[assembly: System.Reflection.AssemblyTitleAttribute("TranslateTest2")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]

// MSBuild WriteCodeFragment クラスによって生成されました。




===== FILE: D:\TranslateTest2\obj\Release\net8.0\.NETCoreApp,Version=v8.0.AssemblyAttributes.cs =====
// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v8.0", FrameworkDisplayName = ".NET 8.0")]



===== FILE: D:\TranslateTest2\obj\Release\net8.0\TranslateTest2.AssemblyInfo.cs =====
//------------------------------------------------------------------------------
// <auto-generated>
//     このコードはツールによって生成されました。
//     ランタイム バージョン:4.0.30319.42000
//
//     このファイルへの変更は、以下の状況下で不正な動作の原因になったり、
//     コードが再生成されるときに損失したりします。
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("TranslateTest2")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Release")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0")]
[assembly: System.Reflection.AssemblyProductAttribute("TranslateTest2")]
[assembly: System.Reflection.AssemblyTitleAttribute("TranslateTest2")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]

// MSBuild WriteCodeFragment クラスによって生成されました。




===== FILE: D:\TranslateTest2\Prefixes\Abusive.cs =====
// Decompiled with JetBrains decompiler
// Type: SummonerPrefix.Prefixes.Abusive
// Assembly: SummonerPrefix, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 8925F543-424F-4302-A9BE-42DFABB73BB2
// Assembly location: D:\dorad\Documents\My Games\Terraria\tModLoader\ModReader\SummonerPrefix\SummonerPrefix.dll

using System;
using System.Collections.Generic;
using Terraria;
using Terraria.ID;
using Terraria.Localization;
using Terraria.ModLoader;

namespace TranslateTest2.Prefixes
{
    public class Abusive : ModPrefix
    {
        public static float TagCrit = 0.04f;

    public override PrefixCategory Category => (PrefixCategory)3;

        public override float RollChance(Item item) => 0.6f;

    public override bool CanRoll(Item item) => item.shoot > 0 && ProjectileID.Sets.IsAWhip[item.shoot];

        public override void SetStats(
            ref float damageMult,
            ref float knockbackMult,
            ref float useTimeMult,
            ref float scaleMult,
            ref float shootSpeedMult,
            ref float manaMult,
            ref int critBonus)
        {
        }

        public override void ModifyValue(ref float valueMult) => valueMult *= 1.5f;

        public override void Apply(Item item)
        {
            item.global().CanGiveTag = true;
            item.global().wTag.CritAdd += TagCrit;
        }

        public override IEnumerable<TooltipLine> GetTooltipLines(Item item)
        {
            var tl = new TooltipLine(Mod, "PrefixDescription", AdditionalTooltip.Value)
            {
                IsModifier = true,
                IsModifierBad = false
            };
            tl.Replace("{}", TagCrit.ToPercent().ToString());
            yield return tl;
        }

        /// <summary>
        /// 元のSummonerPrefix方式: ローカリゼーションからツールチップテキストを取得
        /// </summary>
    public LocalizedText AdditionalTooltip => Language.GetOrRegister(Mod.GetLocalizationKey($"Prefix{Name}Descr"), null);

        public override void SetStaticDefaults()
        {
            _ = AdditionalTooltip;
        }
    }
}


===== FILE: D:\TranslateTest2\Prefixes\Affable.cs =====
using System;
using System.Collections.Generic;
using Terraria;
using Terraria.ID;
using Terraria.GameContent;
using Terraria.Localization;
using Terraria.ModLoader;

namespace TranslateTest2.Prefixes
{
    public class Affable : ModPrefix
    {
        public static float MinionSlotMult = 0.8f;

    public override PrefixCategory Category => (PrefixCategory)3;

    public override float RollChance(Item item) => 1f;

    public override bool CanRoll(Item item) => item.shoot > 0 && item.isMinionSummonItem();

        public override void SetStats(
            ref float damageMult,
            ref float knockbackMult,
            ref float useTimeMult,
            ref float scaleMult,
            ref float shootSpeedMult,
            ref float manaMult,
            ref int critBonus)
        {
        }

    public override void ModifyValue(ref float valueMult) => valueMult *= 1.2f;

    public override void Apply(Item item) => item.global().MinionSlotMult = MinionSlotMult;

        public override IEnumerable<TooltipLine> GetTooltipLines(Item item)
        {
            var tl = new TooltipLine(Mod, "PrefixDescription", AdditionalTooltip.Value)
            {
                IsModifier = true,
                IsModifierBad = false
            };
            tl.Replace("{A}", (1f - MinionSlotMult).ToPercent().ToString());
            Projectile projectile = new Projectile();
            projectile.SetDefaults(item.shoot);
            tl.Replace("{B}", Math.Round(projectile.minionSlots * (1 - MinionSlotMult), 2).ToString());
            yield return tl;
        }

        /// <summary>
        /// 元のSummonerPrefix方式: ローカリゼーションからツールチップテキストを取得
        /// </summary>
    public LocalizedText AdditionalTooltip => Language.GetOrRegister(Mod.GetLocalizationKey($"Prefix{Name}Descr"), null);

        public override void SetStaticDefaults()
        {
            _ = AdditionalTooltip;
        }
    }
}


===== FILE: D:\TranslateTest2\Prefixes\Blessing.cs =====
// Decompiled with JetBrains decompiler
// Type: SummonerPrefix.Prefixes.Blessing
// Assembly: SummonerPrefix, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 8925F543-424F-4302-A9BE-42DFABB73BB2
// Assembly location: D:\dorad\Documents\My Games\Terraria\tModLoader\ModReader\SummonerPrefix\SummonerPrefix.dll

using System;
using System.Collections.Generic;
using Terraria;
using Terraria.ID;
using Terraria.Localization;
using Terraria.ModLoader;

namespace TranslateTest2.Prefixes
{
    public class Blessing : ModPrefix
    {
        public static float Bonus = 1f;
        public static int range = 420;

    public override PrefixCategory Category => (PrefixCategory)3;

    public override float RollChance(Item item) => 0.6f;

    public override bool CanRoll(Item item) => item.shoot > 0 && item.isMinionSummonItem();

        public override void SetStats(
            ref float damageMult,
            ref float knockbackMult,
            ref float useTimeMult,
            ref float scaleMult,
            ref float shootSpeedMult,
            ref float manaMult,
            ref int critBonus)
        {
        }

    public override void ModifyValue(ref float valueMult) => valueMult *= 1.5f;

        public override void Apply(Item item)
        {
            // Reference: no direct state change required here
        }

        public override IEnumerable<TooltipLine> GetTooltipLines(Item item)
        {
            var tl = new TooltipLine(Mod, "PrefixDescription", AdditionalTooltip.Value)
            {
                IsModifier = true,
                IsModifierBad = false
            };
            yield return tl;
        }

        /// <summary>
        /// 元のSummonerPrefix方式: ローカリゼーションからツールチップテキストを取得
        /// </summary>
    public LocalizedText AdditionalTooltip => Language.GetOrRegister(Mod.GetLocalizationKey($"Prefix{Name}Descr"), null);

        public override void SetStaticDefaults()
        {
            _ = AdditionalTooltip;
        }
    }
}


===== FILE: D:\TranslateTest2\Prefixes\Brisk.cs =====
using System;
using System.Collections.Generic;
using Terraria;
using Terraria.ID;
using Terraria.Localization;
using Terraria.ModLoader;

namespace TranslateTest2.Prefixes
{
    public class Brisk : ModPrefix
    {
    public static float MinionSpeedMult = 1.2f; // Attack speed x1.2

    public override PrefixCategory Category => (PrefixCategory)3;

        public override float RollChance(Item item) => 0.8f;

    public override bool CanRoll(Item item) => item.shoot > 0 && item.isMinionSummonItem();

        public override void SetStats(
            ref float damageMult,
            ref float knockbackMult,
            ref float useTimeMult,
            ref float scaleMult,
            ref float shootSpeedMult,
            ref float manaMult,
            ref int critBonus)
        {
        }

        public override void ModifyValue(ref float valueMult) => valueMult *= 1.4f;

        public override void Apply(Item item)
        {
            // Reference: use MinionSpeedMult (consumed by SPGlobalProj)
            item.global().MinionSpeedMult += MinionSpeedMult - 1f;
        }

        public override IEnumerable<TooltipLine> GetTooltipLines(Item item)
        {
            var tl = new TooltipLine(Mod, "PrefixDescription", AdditionalTooltip.Value)
            {
                IsModifier = true,
                IsModifierBad = false
            };
            tl.Replace("{}", (MinionSpeedMult - 1f).ToPercent().ToString());
            yield return tl;
        }

        /// <summary>
        /// 元のSummonerPrefix方式: ローカリゼーションからツールチップテキストを取得
        /// キー: "Mods.TranslateTest2.PrefixBriskDescr"
        /// </summary>
    public LocalizedText AdditionalTooltip => Language.GetOrRegister(Mod.GetLocalizationKey($"Prefix{Name}Descr"), null);

        public override void SetStaticDefaults()
        {
            _ = AdditionalTooltip;
        }
    }
}


===== FILE: D:\TranslateTest2\Prefixes\Contract.cs =====
using System;
using System.Collections.Generic;
using Terraria;
using Terraria.ID;
using Terraria.Localization;
using Terraria.ModLoader;

namespace TranslateTest2.Prefixes
{
    public class Contract : ModPrefix
    {
    public static int ArmorDecrease = 6;
    public static float LifeSteal = 0.02f;

    public override PrefixCategory Category => (PrefixCategory)3;

    public override float RollChance(Item item) => 0.7f;

    public override bool CanRoll(Item item) => item.shoot > 0 && item.isMinionSummonItem();

        public override void SetStats(
            ref float damageMult,
            ref float knockbackMult,
            ref float useTimeMult,
            ref float scaleMult,
            ref float shootSpeedMult,
            ref float manaMult,
            ref int critBonus)
        {
            // Reference: no direct damage bonus here
        }

    public override void ModifyValue(ref float valueMult) { }

        public override void Apply(Item item)
        {
            item.global().MinionLifeSteal += LifeSteal;
        }

        public override IEnumerable<TooltipLine> GetTooltipLines(Item item)
        {
            var tl = new TooltipLine(Mod, "PrefixDescription", AdditionalTooltip.Value)
            {
                IsModifier = true,
                IsModifierBad = false
            };
            tl.Replace("{A}", LifeSteal.ToPercent().ToString());
            tl.Replace("{B}", ArmorDecrease.ToString());
            yield return tl;
        }

        /// <summary>
        /// 元のSummonerPrefix方式: ローカリゼーションからツールチップテキストを取得
        /// </summary>
    public LocalizedText AdditionalTooltip => Language.GetOrRegister(Mod.GetLocalizationKey($"Prefix{Name}Descr"), null);

        public override void SetStaticDefaults()
        {
            _ = AdditionalTooltip;
        }
    }
}


===== FILE: D:\TranslateTest2\Prefixes\Deviation.cs =====
// Decompiled with JetBrains decompiler
// Type: SummonerPrefix.Prefixes.Deviation
// Assembly: SummonerPrefix, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 8925F543-424F-4302-A9BE-42DFABB73BB2
// Assembly location: D:\dorad\Documents\My Games\Terraria\tModLoader\ModReader\SummonerPrefix\SummonerPrefix.dll

using System;
using System.Collections.Generic;
using Terraria;
using Terraria.ID;
using Terraria.Localization;
using Terraria.ModLoader;

namespace TranslateTest2.Prefixes
{
    public class Deviation : ModPrefix
    {
    public override PrefixCategory Category => (PrefixCategory)3;

    public override float RollChance(Item item) => 0.8f;

    public override bool CanRoll(Item item) => item.shoot > 0 && item.isMinionSummonItem();

        public override void SetStats(
            ref float damageMult,
            ref float knockbackMult,
            ref float useTimeMult,
            ref float scaleMult,
            ref float shootSpeedMult,
            ref float manaMult,
            ref int critBonus)
        {
            damageMult = 1.1f;
        }

    public override void ModifyValue(ref float valueMult) => valueMult *= 1.4f;

        public override void Apply(Item item)
        {
        }

        /// <summary>
        /// 元のSummonerPrefix方式: ローカリゼーションからツールチップテキストを取得
        /// </summary>
    public LocalizedText AdditionalTooltip => Language.GetOrRegister(Mod.GetLocalizationKey($"Prefix{Name}Descr"), null);

        public override void SetStaticDefaults()
        {
            _ = AdditionalTooltip;
        }

        public override IEnumerable<TooltipLine> GetTooltipLines(Item item)
        {
            // ローカライズはAdditionalTooltipのみを使用
            var tl = new TooltipLine(Mod, "PrefixDescription", AdditionalTooltip.Value)
            {
                IsModifier = true,
                IsModifierBad = true
            };

            // Deviationはプレースホルダーなし（固定テキスト）
            yield return tl;
        }
    }
}


===== FILE: D:\TranslateTest2\Prefixes\Devoted.cs =====
// Decompiled with JetBrains decompiler
// Type: SummonerPrefix.Prefixes.Devoted
// Assembly: SummonerPrefix, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 8925F543-424F-4302-A9BE-42DFABB73BB2
// Assembly location: D:\dorad\Documents\My Games\Terraria\tModLoader\ModReader\SummonerPrefix\SummonerPrefix.dll

using System;
using System.Collections.Generic;
using Terraria;
using Terraria.ID;
using Terraria.Localization;
using Terraria.ModLoader;

namespace TranslateTest2.Prefixes
{
    public class Devoted : ModPrefix
    {
    public static float Increase = 0.15f;
    public static float Decrease = 0.2f;

    public override PrefixCategory Category => (PrefixCategory)3;

    public override float RollChance(Item item) => 1f;

    public override bool CanRoll(Item item) => item.shoot > 0 && ProjectileID.Sets.IsAWhip[item.shoot];

        public override void SetStats(
            ref float damageMult,
            ref float knockbackMult,
            ref float useTimeMult,
            ref float scaleMult,
            ref float shootSpeedMult,
            ref float manaMult,
            ref int critBonus)
        {
        }

    public override void ModifyValue(ref float valueMult) => valueMult *= 1.2f;

        public override void Apply(Item item)
        {
            item.global().CanGiveTag = true;
            item.global().wTag.SpecialType = nameof(Devoted);
        }

        public override IEnumerable<TooltipLine> GetTooltipLines(Item item)
        {
            var tl = new TooltipLine(Mod, "PrefixDescription", AdditionalTooltip.Value)
            {
                IsModifier = true,
                IsModifierBad = false
            };
            tl.Replace("{A}", Increase.ToPercent().ToString());
            tl.Replace("{B}", Decrease.ToPercent().ToString());
            yield return tl;
        }

        /// <summary>
        /// 元のSummonerPrefix方式: ローカリゼーションからツールチップテキストを取得
        /// </summary>
    public LocalizedText AdditionalTooltip => Language.GetOrRegister(Mod.GetLocalizationKey($"Prefix{Name}Descr"), null);

        public override void SetStaticDefaults()
        {
            _ = AdditionalTooltip;
        }
    }
}


===== FILE: D:\TranslateTest2\Prefixes\Eager.cs =====
using System;
using System.Collections.Generic;
using Terraria;
using Terraria.ID;
using Terraria.Localization;
using Terraria.ModLoader;

namespace TranslateTest2.Prefixes
{
    public class Eager : ModPrefix
    {
        public static float MinionSpeedMult = 1.3f;

        public override PrefixCategory Category => (PrefixCategory)3; // Unified category per original mod

        public override float RollChance(Item item) => 0.6f; // Original probability

        public override bool CanRoll(Item item) => item.shoot > 0 && item.isMinionSummonItem();

        public override void SetStats(
            ref float damageMult,
            ref float knockbackMult,
            ref float useTimeMult,
            ref float scaleMult,
            ref float shootSpeedMult,
            ref float manaMult,
            ref int critBonus) { }

        public override void ModifyValue(ref float valueMult) => valueMult *= 1.6f; // Original value multiplier

        public override void Apply(Item item)
        {
            item.global().MinionSpeedMult += MinionSpeedMult - 1f;
        }

        public override IEnumerable<TooltipLine> GetTooltipLines(Item item)
        {
            var tl = new TooltipLine(Mod, "PrefixDescription", AdditionalTooltip.Value)
            {
                IsModifier = true,
                IsModifierBad = false
            };
            // Original placeholder pattern
            tl.Replace("{}", (MinionSpeedMult - 1f).ToPercent().ToString());
            yield return tl;
        }

        public LocalizedText AdditionalTooltip
        {
            get
            {
                var key = Mod.GetLocalizationKey($"Prefix{Name}Descr");
                return Language.GetOrRegister(key, (Func<string>)null);
            }
        }

        public override void SetStaticDefaults() => _ = AdditionalTooltip; // Force key registration only
    }
}


===== FILE: D:\TranslateTest2\Prefixes\Echo.cs =====
// Decompiled with JetBrains decompiler
// Type: SummonerPrefix.Prefixes.Echo
// Assembly: SummonerPrefix, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 8925F543-424F-4302-A9BE-42DFABB73BB2
// Assembly location: D:\dorad\Documents\My Games\Terraria\tModLoader\ModReader\SummonerPrefix\SummonerPrefix.dll

using System;
using System.Collections.Generic;
using Terraria;
using Terraria.ID;
using Terraria.Localization;
using Terraria.ModLoader;

namespace TranslateTest2.Prefixes
{
    public class Echo : ModPrefix
    {
        public static float DoubleChance = 0.25f; // Used by projectile logic, not shown here

        public override PrefixCategory Category => (PrefixCategory)3; // Original unified category

        public override float RollChance(Item item) => 0.6f;

        public override bool CanRoll(Item item) => item.shoot > 0 && item.isMinionSummonItem();

        public override void SetStats(
            ref float damageMult,
            ref float knockbackMult,
            ref float useTimeMult,
            ref float scaleMult,
            ref float shootSpeedMult,
            ref float manaMult,
            ref int critBonus)
        {
        }

        public override void ModifyValue(ref float valueMult) => valueMult *= 1.4f;

        public override void Apply(Item item)
        {
        }

        public override IEnumerable<TooltipLine> GetTooltipLines(Item item)
        {
            var tl = new TooltipLine(Mod, "PrefixDescription", AdditionalTooltip.Value)
            {
                IsModifier = true,
                IsModifierBad = false
            };
            // Original had no runtime placeholder replacement (value baked in localization)
            yield return tl;
        }

        public LocalizedText AdditionalTooltip
        {
            get
            {
                var key = Mod.GetLocalizationKey($"Prefix{Name}Descr");
                return Language.GetOrRegister(key, (Func<string>)null);
            }
        }

        public override void SetStaticDefaults() => _ = AdditionalTooltip;
    }
}


===== FILE: D:\TranslateTest2\Prefixes\Electrified.cs =====
// Decompiled with JetBrains decompiler
// Type: SummonerPrefix.Prefixes.Electrified
// Assembly: SummonerPrefix, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 8925F543-424F-4302-A9BE-42DFABB73BB2
// Assembly location: D:\dorad\Documents\My Games\Terraria\tModLoader\ModReader\SummonerPrefix\SummonerPrefix.dll

using System;
using System.Collections.Generic;
using Terraria;
using Terraria.ID;
using Terraria.Localization;
using Terraria.ModLoader;

namespace TranslateTest2.Prefixes
{
    public class Electrified : ModPrefix
    {
        public static float DmgMultByPlayerMaxHealth = 0.08f;

        public override PrefixCategory Category => (PrefixCategory)3; // Unified category

        public override float RollChance(Item item) => 0.4f;

        public override bool CanRoll(Item item) => item.shoot > 0 && item.isMinionSummonItem();

        public override void SetStats(
            ref float damageMult,
            ref float knockbackMult,
            ref float useTimeMult,
            ref float scaleMult,
            ref float shootSpeedMult,
            ref float manaMult,
            ref int critBonus)
        {
        }

        public override void ModifyValue(ref float valueMult) => valueMult *= 1.4f;

        public override void Apply(Item item) => item.global().electrified = true;

        public override IEnumerable<TooltipLine> GetTooltipLines(Item item)
        {
            var tl = new TooltipLine(Mod, "PrefixDescription", AdditionalTooltip.Value)
            {
                IsModifier = true,
                IsModifierBad = false
            };
            yield return tl; // Original had no dynamic replacement
        }

        public LocalizedText AdditionalTooltip
        {
            get
            {
                var key = Mod.GetLocalizationKey($"Prefix{Name}Descr");
                return Language.GetOrRegister(key, (Func<string>)null);
            }
        }

        public override void SetStaticDefaults() => _ = AdditionalTooltip;
    }
}


===== FILE: D:\TranslateTest2\Prefixes\Extended.cs =====
// Decompiled with JetBrains decompiler
// Type: SummonerPrefix.Prefixes.Extended
// Assembly: SummonerPrefix, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 8925F543-424F-4302-A9BE-42DFABB73BB2
// Assembly location: D:\dorad\Documents\My Games\Terraria\tModLoader\ModReader\SummonerPrefix\SummonerPrefix.dll

using System;
using System.Collections.Generic;
using Terraria;
using Terraria.ID;
using Terraria.Localization;
using Terraria.ModLoader;

namespace TranslateTest2.Prefixes
{
    public class Extended : ModPrefix
    {
        public static float RangeMult = 1.3f;

        public override PrefixCategory Category => (PrefixCategory)3; // Original unified category

        public override float RollChance(Item item) => 1f;

        public override bool CanRoll(Item item) => item.shoot > 0 && ProjectileID.Sets.IsAWhip[item.shoot];

        public override void SetStats(
            ref float damageMult,
            ref float knockbackMult,
            ref float useTimeMult,
            ref float scaleMult,
            ref float shootSpeedMult,
            ref float manaMult,
            ref int critBonus)
        {
        }

        public override void ModifyValue(ref float valueMult) => valueMult *= 1.2f;

    public override void Apply(Item item) => item.global().WhipRangeMult += RangeMult - 1f;

        public override IEnumerable<TooltipLine> GetTooltipLines(Item item)
        {
            var tl = new TooltipLine(Mod, "PrefixDescription", AdditionalTooltip.Value)
            {
                IsModifier = true,
                IsModifierBad = false
            };
            tl.Replace("{V}", (RangeMult - 1f).ToPercent().ToString());
            yield return tl;
        }

        public LocalizedText AdditionalTooltip
        {
            get
            {
                var key = Mod.GetLocalizationKey($"Prefix{Name}Descr");
                return Language.GetOrRegister(key, (Func<string>)null);
            }
        }

        public override void SetStaticDefaults() => _ = AdditionalTooltip;
    }
}


===== FILE: D:\TranslateTest2\Prefixes\Fabled.cs =====
// Decompiled with JetBrains decompiler
// Type: SummonerPrefix.Prefixes.Fabled
// Assembly: SummonerPrefix, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 8925F543-424F-4302-A9BE-42DFABB73BB2
// Assembly location: D:\dorad\Documents\My Games\Terraria\tModLoader\ModReader\SummonerPrefix\SummonerPrefix.dll

using System;
using System.Collections.Generic;
using Terraria;
using Terraria.ID;
using Terraria.Localization;
using Terraria.ModLoader;

namespace TranslateTest2.Prefixes
{
    public class Fabled : ModPrefix
    {
        public static float MinionSlotMult = 0.8f;
        public static float Crit = 0.05f;
        public static float Kb = 1.6f;

        public override PrefixCategory Category => (PrefixCategory)3; // Unified category

        public override float RollChance(Item item) => 0.35f;

        public override bool CanRoll(Item item) => item.shoot > 0 && item.isMinionSummonItem();

        public override void SetStats(
            ref float damageMult,
            ref float knockbackMult,
            ref float useTimeMult,
            ref float scaleMult,
            ref float shootSpeedMult,
            ref float manaMult,
            ref int critBonus)
        {
            damageMult = 1.2f;
        }

        public override void ModifyValue(ref float valueMult) => valueMult *= 3f;

        public override void Apply(Item item) => item.global().MinionSlotMult = MinionSlotMult;

        public override IEnumerable<TooltipLine> GetTooltipLines(Item item)
        {
            var tl = new TooltipLine(Mod, "PrefixDescription", AdditionalTooltip.Value)
            {
                IsModifier = true,
                IsModifierBad = false
            };
            tl.Replace("{A}", (1f - MinionSlotMult).ToPercent().ToString());
            var proj = new Projectile();
            proj.SetDefaults(item.shoot);
            tl.Replace("{B}", Math.Round(proj.minionSlots * (1f - MinionSlotMult), 2).ToString());
            tl.Replace("{C}", Crit.ToPercent().ToString());
            tl.Replace("{D}", (Kb - 1f).ToPercent().ToString());
            yield return tl;
        }

        public LocalizedText AdditionalTooltip
        {
            get
            {
                var key = Mod.GetLocalizationKey($"Prefix{Name}Descr");
                return Language.GetOrRegister(key, (Func<string>)null);
            }
        }

        public override void SetStaticDefaults() => _ = AdditionalTooltip;
    }
}


===== FILE: D:\TranslateTest2\Prefixes\Focused.cs =====
// Decompiled with JetBrains decompiler
// Type: SummonerPrefix.Prefixes.Focused
// Assembly: SummonerPrefix, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 8925F543-424F-4302-A9BE-42DFABB73BB2
// Assembly location: D:\dorad\Documents\My Games\Terraria\tModLoader\ModReader\SummonerPrefix\SummonerPrefix.dll

using System;
using System.Collections.Generic;
using Terraria;
using Terraria.ID;
using Terraria.GameContent;
using Terraria.Localization;
using Terraria.ModLoader;

namespace TranslateTest2.Prefixes
{
    public class Focused : ModPrefix
    {
        public static float MinionSlotAndDmgMult = 1.4f;

        public override PrefixCategory Category => (PrefixCategory)3; // Original unified category

        public override float RollChance(Item item) => 1f;

        public override bool CanRoll(Item item) => item.shoot > 0 && item.isMinionSummonItem();

        public override void SetStats(
            ref float damageMult,
            ref float knockbackMult,
            ref float useTimeMult,
            ref float scaleMult,
            ref float shootSpeedMult,
            ref float manaMult,
            ref int critBonus)
        {
            damageMult = MinionSlotAndDmgMult + 0.4f;
        }

        public override void ModifyValue(ref float valueMult) => valueMult *= 1.25f;

        public override void Apply(Item item)
        {
            item.global().MinionSlotMult = MinionSlotAndDmgMult;
        }

        public override IEnumerable<TooltipLine> GetTooltipLines(Item item)
        {
            var tl = new TooltipLine(Mod, "PrefixDescription", AdditionalTooltip.Value)
            {
                IsModifier = true,
                IsModifierBad = false
            };
            tl.Replace("{A}", (MinionSlotAndDmgMult - 1f).ToPercent().ToString());
            var proj = new Projectile();
            proj.SetDefaults(item.shoot);
            tl.Replace("{B}", Math.Round(proj.minionSlots * (MinionSlotAndDmgMult - 1f), 2).ToString());
            yield return tl;
        }

        public LocalizedText AdditionalTooltip
        {
            get
            {
                var key = Mod.GetLocalizationKey($"Prefix{Name}Descr");
                return Language.GetOrRegister(key, (Func<string>)null);
            }
        }

        public override void SetStaticDefaults() => _ = AdditionalTooltip;
    }
}


===== FILE: D:\TranslateTest2\Prefixes\Focused_Whip.cs =====
// Decompiled with JetBrains decompiler
// Type: SummonerPrefix.Prefixes.Focused_Whip
// Assembly: SummonerPrefix, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 8925F543-424F-4302-A9BE-42DFABB73BB2
// Assembly location: D:\dorad\Documents\My Games\Terraria\tModLoader\ModReader\SummonerPrefix\SummonerPrefix.dll

using System;
using System.Collections.Generic;
using Terraria;
using Terraria.ID;
using Terraria.Localization;
using Terraria.ModLoader;

namespace TranslateTest2.Prefixes
{
    public class Focused_Whip : ModPrefix
    {
        public static float SummonDmgAddition = 0.1f;
        public static int MinionSlotDecrease = 1;

        public override PrefixCategory Category => (PrefixCategory)3; // Unified category

        public override float RollChance(Item item) => 0.8f; // Original value

        public override bool CanRoll(Item item) => item.shoot > 0 && ProjectileID.Sets.IsAWhip[item.shoot];

        public override void SetStats(
            ref float damageMult,
            ref float knockbackMult,
            ref float useTimeMult,
            ref float scaleMult,
            ref float shootSpeedMult,
            ref float manaMult,
            ref int critBonus)
        {
        }

    public override void ModifyValue(ref float valueMult) { }

        public override void Apply(Item item)
        {
        }

        public override IEnumerable<TooltipLine> GetTooltipLines(Item item)
        {
            var tl = new TooltipLine(Mod, "PrefixDescription", AdditionalTooltip.Value)
            {
                IsModifier = true,
                IsModifierBad = false
            };
            tl.Replace("{A}", SummonDmgAddition.ToPercent().ToString());
            tl.Replace("{B}", MinionSlotDecrease.ToString());
            yield return tl;
        }

        public LocalizedText AdditionalTooltip
        {
            get
            {
                var key = Mod.GetLocalizationKey($"Prefix{Name}Descr");
                return Language.GetOrRegister(key, (Func<string>)null);
            }
        }

        public override void SetStaticDefaults() => _ = AdditionalTooltip;
    }
}


===== FILE: D:\TranslateTest2\Prefixes\Huge.cs =====
using System;
using System.Collections.Generic;
using Terraria;
using Terraria.ID;
using Terraria.Localization;
using Terraria.ModLoader;

namespace TranslateTest2.Prefixes
{
    public class Huge : ModPrefix
    {
        public static float MinionScaleMult = 0.4f;

        public override PrefixCategory Category => (PrefixCategory)3; // Unified original category

        public override float RollChance(Item item) => 1f;

        public override bool CanRoll(Item item) => item.shoot > 0 && item.isMinionSummonItem();

        public override void SetStats(
            ref float damageMult,
            ref float knockbackMult,
            ref float useTimeMult,
            ref float scaleMult,
            ref float shootSpeedMult,
            ref float manaMult,
            ref int critBonus)
        {
            damageMult = 1.2f;
        }

        public override void ModifyValue(ref float valueMult) => valueMult *= 1.2f;

        public override void Apply(Item item) => item.global().MinionScaleMult += MinionScaleMult;

        public override IEnumerable<TooltipLine> GetTooltipLines(Item item)
        {
            var tl = new TooltipLine(Mod, "PrefixDescription", AdditionalTooltip.Value)
            {
                IsModifier = true,
                IsModifierBad = false
            };
            tl.Replace("{}", MinionScaleMult.ToPercent().ToString());
            yield return tl;
        }

        public LocalizedText AdditionalTooltip
        {
            get
            {
                var key = Mod.GetLocalizationKey($"Prefix{Name}Descr");
                return Language.GetOrRegister(key, (Func<string>)null);
            }
        }

        public override void SetStaticDefaults() => _ = AdditionalTooltip;
    }
}


===== FILE: D:\TranslateTest2\Prefixes\Loyal.cs =====
using System;
using System.Collections.Generic;
using Terraria;
using Terraria.ID;
using Terraria.GameContent;
using Terraria.Localization;
using Terraria.ModLoader;

namespace TranslateTest2.Prefixes
{
    public class Loyal : ModPrefix
    {
        public static float MinionSlotAndDmgMult = 3f;
        public static float Crit = 0.05f;

        public override PrefixCategory Category => (PrefixCategory)3; // Unified category

        public override float RollChance(Item item) => 1f;

        public override bool CanRoll(Item item) => item.shoot > 0 && item.isMinionSummonItem(false);

        public override void SetStats(
            ref float damageMult,
            ref float knockbackMult,
            ref float useTimeMult,
            ref float scaleMult,
            ref float shootSpeedMult,
            ref float manaMult,
            ref int critBonus)
        {
            damageMult = MinionSlotAndDmgMult;
        }

        public override void ModifyValue(ref float valueMult) => valueMult *= 1.6f;

        public override void Apply(Item item) => item.global().MinionSlotMult = MinionSlotAndDmgMult;

        public override IEnumerable<TooltipLine> GetTooltipLines(Item item)
        {
            var tl = new TooltipLine(Mod, "PrefixDescription", AdditionalTooltip.Value)
            {
                IsModifier = true,
                IsModifierBad = false
            };
            tl.Replace("{A}", (MinionSlotAndDmgMult - 1f).ToPercent().ToString());
            var proj = new Projectile();
            proj.SetDefaults(item.shoot);
            tl.Replace("{B}", Math.Round(proj.minionSlots * (MinionSlotAndDmgMult - 1f), 2).ToString());
            tl.Replace("{C}", Crit.ToPercent().ToString());
            yield return tl;
        }

        public LocalizedText AdditionalTooltip
        {
            get
            {
                var key = Mod.GetLocalizationKey($"Prefix{Name}Descr");
                return Language.GetOrRegister(key, (Func<string>)null);
            }
        }

        public override void SetStaticDefaults() => _ = AdditionalTooltip;
    }
}


===== FILE: D:\TranslateTest2\Prefixes\Mega.cs =====
using System;
using System.Collections.Generic;
using Terraria;
using Terraria.ID;
using Terraria.Localization;
using Terraria.ModLoader;

namespace TranslateTest2.Prefixes
{
    public class Mega : ModPrefix
    {
        public static float MinionSlotMult = 2f;
        public static float MinionDmgAddition = 1.2f;

        public override PrefixCategory Category => (PrefixCategory)3; // Unified category

        public override float RollChance(Item item) => 1f;

        public override bool CanRoll(Item item) => item.shoot > 0 && item.isMinionSummonItem(false);

        public override void SetStats(
            ref float damageMult,
            ref float knockbackMult,
            ref float useTimeMult,
            ref float scaleMult,
            ref float shootSpeedMult,
            ref float manaMult,
            ref int critBonus)
        {
            damageMult = 1f + MinionDmgAddition; // Original adds MinionDmgAddition
        }

        public override void ModifyValue(ref float valueMult) => valueMult *= 1.4f;

        public override void Apply(Item item)
        {
            item.global().MinionSlotMult = MinionSlotMult;
            item.global().MinionScaleMult += 1f;
            item.global().MinionKnockbackMult += 1f;
        }

        public override IEnumerable<TooltipLine> GetTooltipLines(Item item)
        {
            var tl = new TooltipLine(Mod, "PrefixDescription", AdditionalTooltip.Value)
            {
                IsModifier = true,
                IsModifierBad = false
            };
            yield return tl; // No runtime replacements in original
        }

        public LocalizedText AdditionalTooltip
        {
            get
            {
                var key = Mod.GetLocalizationKey($"Prefix{Name}Descr");
                return Language.GetOrRegister(key, (Func<string>)null);
            }
        }

        public override void SetStaticDefaults() => _ = AdditionalTooltip;
    }
}


===== FILE: D:\TranslateTest2\Prefixes\Oracle.cs =====
using System;
using System.Collections.Generic;
using Terraria;
using Terraria.ID;
using Terraria.Localization;
using Terraria.ModLoader;

namespace TranslateTest2.Prefixes
{
    public class Oracle : ModPrefix
    {
        public static float TagCrit = 0.08f;
        public static float TagDmg = 0.07f;
        public static float RangeMult = 1.35f;

        public override PrefixCategory Category => (PrefixCategory)3; // Unified category

        public override float RollChance(Item item) => 0.35f;

        public override bool CanRoll(Item item) => item.shoot > 0 && ProjectileID.Sets.IsAWhip[item.shoot];

        public override void SetStats(
            ref float damageMult,
            ref float knockbackMult,
            ref float useTimeMult,
            ref float scaleMult,
            ref float shootSpeedMult,
            ref float manaMult,
            ref int critBonus)
        {
            damageMult = 1.2f;
            useTimeMult *= 0.8f;
        }

        public override void ModifyValue(ref float valueMult) => valueMult *= 3f;

        public override void Apply(Item item)
        {
            var g = item.global();
            g.CanGiveTag = true;
            g.wTag.CritAdd += TagCrit;
            g.wTag.TagDamage = (int)Math.Ceiling(item.damage * TagDmg);
            g.WhipRangeMult += RangeMult - 1f;
        }

        public override IEnumerable<TooltipLine> GetTooltipLines(Item item)
        {
            var tl = new TooltipLine(Mod, "PrefixDescription", AdditionalTooltip.Value)
            {
                IsModifier = true,
                IsModifierBad = false
            };
            tl.Replace("{A}", TagDmg.ToPercent().ToString());
            tl.Replace("{B}", Math.Ceiling(item.damage * TagDmg).ToString());
            tl.Replace("{C}", TagCrit.ToPercent().ToString());
            tl.Replace("{D}", (RangeMult - 1f).ToPercent().ToString());
            yield return tl;
        }

        public LocalizedText AdditionalTooltip
        {
            get
            {
                var key = Mod.GetLocalizationKey($"Prefix{Name}Descr");
                return Language.GetOrRegister(key, (Func<string>)null);
            }
        }

        public override void SetStaticDefaults() => _ = AdditionalTooltip;
    }
}


===== FILE: D:\TranslateTest2\Prefixes\Overload.cs =====
using System;
using System.Collections.Generic;
using Terraria;
using Terraria.Localization;
using Terraria.ModLoader;

namespace TranslateTest2.Prefixes
{
    public class Overload : ModPrefix
    {
        public static float MinionSpeedMult = 2f;

        public override PrefixCategory Category => (PrefixCategory)3;

        public override float RollChance(Item item) => 0.6f;

        public override bool CanRoll(Item item) => item.shoot > 0 && item.isMinionSummonItem();

        public override void SetStats(
            ref float damageMult,
            ref float knockbackMult,
            ref float useTimeMult,
            ref float scaleMult,
            ref float shootSpeedMult,
            ref float manaMult,
            ref int critBonus)
        {
            damageMult *= 0.52f;
        }

        public override void ModifyValue(ref float valueMult) => valueMult *= 1.2f;

        public override void Apply(Item item)
        {
            item.global().MinionSpeedMult += MinionSpeedMult - 1f;
        }

        public override IEnumerable<TooltipLine> GetTooltipLines(Item item)
        {
            var tl = new TooltipLine(Mod, "PrefixDescription", AdditionalTooltip.Value)
            {
                IsModifier = true,
                IsModifierBad = false
            };
            tl.Replace("{}", (MinionSpeedMult - 1f).ToPercent().ToString());
            yield return tl;
        }

        public LocalizedText AdditionalTooltip
        {
            get
            {
                var key = Mod.GetLocalizationKey($"Prefix{Name}Descr");
                return Language.GetOrRegister(key, null);
            }
        }

        public override void SetStaticDefaults()
        {
            _ = AdditionalTooltip;
        }
    }
}


===== FILE: D:\TranslateTest2\Prefixes\Steady.cs =====
using System;
using System.Collections.Generic;
using Terraria;
using Terraria.Localization;
using Terraria.ModLoader;

namespace TranslateTest2.Prefixes
{
    public class Steady : ModPrefix
    {
        public static float MinionSpeedMult = 0.5f;

        public override PrefixCategory Category => (PrefixCategory)3;

        public override float RollChance(Item item) => 0.8f;

        public override bool CanRoll(Item item) => item.shoot > 0 && item.isMinionSummonItem();

        public override void SetStats(
            ref float damageMult,
            ref float knockbackMult,
            ref float useTimeMult,
            ref float scaleMult,
            ref float shootSpeedMult,
            ref float manaMult,
            ref int critBonus)
        {
            damageMult = 2.3f;
        }

        public override void ModifyValue(ref float valueMult) { }

        public override void Apply(Item item)
        {
            item.global().MinionSpeedMult += MinionSpeedMult - 1f;
        }

        public override IEnumerable<TooltipLine> GetTooltipLines(Item item)
        {
            var tl = new TooltipLine(Mod, "PrefixDescription", AdditionalTooltip.Value)
            {
                IsModifier = true,
                IsModifierBad = false
            };
            tl.Replace("{}", (1f - MinionSpeedMult).ToPercent().ToString());
            yield return tl;
        }

        public LocalizedText AdditionalTooltip
        {
            get
            {
                var key = Mod.GetLocalizationKey($"Prefix{Name}Descr");
                return Language.GetOrRegister(key, null);
            }
        }

        public override void SetStaticDefaults()
        {
            _ = AdditionalTooltip;
        }
    }
}


===== FILE: D:\TranslateTest2\Prefixes\Vengeful.cs =====
using System;
using System.Collections.Generic;
using Terraria;
using Terraria.ID;
using Terraria.Localization;
using Terraria.ModLoader;

namespace TranslateTest2.Prefixes
{
    public class Vengeful : ModPrefix
    {
        public static float ExtraTagDamage = 0.03f;

        public override PrefixCategory Category => (PrefixCategory)3;

        public override float RollChance(Item item) => 1f;

        public override bool CanRoll(Item item) => item.shoot > 0 && ProjectileID.Sets.IsAWhip[item.shoot];

        public override void SetStats(
            ref float damageMult,
            ref float knockbackMult,
            ref float useTimeMult,
            ref float scaleMult,
            ref float shootSpeedMult,
            ref float manaMult,
            ref int critBonus)
        { }

        public override void ModifyValue(ref float valueMult) => valueMult *= 1.2f;

        public override void Apply(Item item)
        {
            int num = (int)Math.Ceiling(item.damage * ExtraTagDamage);
            if (num <= 0)
                return;
            item.global().CanGiveTag = true;
            item.global().wTag.TagDamage += num;
        }

        public override IEnumerable<TooltipLine> GetTooltipLines(Item item)
        {
            var tl = new TooltipLine(Mod, "PrefixDescription", AdditionalTooltip.Value)
            {
                IsModifier = true,
                IsModifierBad = false
            };
            tl.Replace("{A}", ExtraTagDamage.ToPercent().ToString());
            tl.Replace("{B}", ((int)Math.Ceiling(item.damage * ExtraTagDamage)).ToString());
            yield return tl;
        }

        public LocalizedText AdditionalTooltip
        {
            get
            {
                var key = Mod.GetLocalizationKey($"Prefix{Name}Descr");
                return Language.GetOrRegister(key, null);
            }
        }

        public override void SetStaticDefaults()
        {
            _ = AdditionalTooltip;
        }
    }
}


===== FILE: D:\TranslateTest2\Projectiles\ElectricLaser.cs =====
// Decompiled with JetBrains decompiler
// Type: SummonerPrefix.Projectiles.ElectricLaser
// Assembly: SummonerPrefix, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 8925F543-424F-4302-A9BE-42DFABB73BB2
// Assembly location: D:\dorad\Documents\My Games\Terraria\tModLoader\ModReader\SummonerPrefix\SummonerPrefix.dll

using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using Terraria;
using Terraria.GameContent;
using Terraria.ModLoader;

namespace TranslateTest2.Projectiles
{
    public class ElectricLaser : ModProjectile
    {
        public int frame;
        public int framecounter;

        public override void SetStaticDefaults()
        {
            // DisplayName.SetDefault("Electric Laser");
        }

        public override void SetDefaults()
        {
            Projectile.width = 14;
            Projectile.height = 14;
            Projectile.friendly = true;
            Projectile.tileCollide = false;
            Projectile.ignoreWater = true;
            Projectile.DamageType = DamageClass.Summon;
            Projectile.penetrate = -1;
            Projectile.timeLeft = 30;
            Projectile.alpha = 0;
        }

        public override void AI()
        {
            if (++framecounter >= 6)
            {
                framecounter = 0;
                if (++frame >= 4)
                    frame = 0;
            }
            
            Player owner = Main.player[Projectile.owner];
            if (owner == null || !owner.active)
            {
                Projectile.Kill();
                return;
            }

            Vector2 targetPos = new Vector2(Projectile.ai[0], Projectile.ai[1]);
            Projectile.position = Vector2.Lerp(Projectile.position, targetPos, 0.1f);
        }

        public override bool PreDraw(ref Color lightColor)
        {
            Texture2D texture = TextureAssets.Projectile[Projectile.type].Value;
            int frameHeight = texture.Height / 4;
            Rectangle sourceRectangle = new Rectangle(0, frame * frameHeight, texture.Width, frameHeight);
            Vector2 origin = sourceRectangle.Size() / 2f;
            
            Main.EntitySpriteDraw(texture, Projectile.Center - Main.screenPosition, sourceRectangle, 
                Color.White * (1f - Projectile.alpha / 255f), Projectile.rotation, origin, 
                Projectile.scale, SpriteEffects.None, 0);
            
            return false;
        }
    }
}



===== FILE: D:\TranslateTest2\Systems\ChatTranslationSystem.cs =====
using Terraria;
using Terraria.ModLoader;
using TranslateTest2.Core;

namespace TranslateTest2.Systems
{
	/// <summary>
	/// チャットメッセージ翻訳の将来的実装用骨格。
	/// 今後: OnChatMessage などの適切な Hook で DeepLTranslator / TooltipTranslator を適用し、
	/// 言語判定 (TextLangHelper) により必要時のみ翻訳を要求する予定。
	/// </summary>
	public class ChatTranslationSystem : ModSystem
	{
		public override void OnModLoad()
		{
			TranslateTest2.Instance?.Logger?.Debug("ChatTranslationSystem loaded (skeleton)");
		}

		public override void OnModUnload()
		{
			TranslateTest2.Instance?.Logger?.Debug("ChatTranslationSystem unloaded (skeleton)");
		}
	}
}



===== FILE: D:\TranslateTest2\Systems\MenuTranslationSystem.cs =====
using Terraria.ModLoader;

namespace TranslateTest2.Systems
{
	/// <summary>
	/// メニュー(UIロビー/タイトル/設定) テキスト翻訳の将来拡張用骨格。
	/// 実装時: ロード済み文字列テーブル巡回し TooltipTranslator/DeepLTranslator を適用する仕組みを検討。
	/// </summary>
	public class MenuTranslationSystem : ModSystem
	{
		public override void OnModLoad()
		{
			TranslateTest2.Instance?.Logger?.Debug("MenuTranslationSystem loaded (skeleton)");
		}

		public override void OnModUnload()
		{
			TranslateTest2.Instance?.Logger?.Debug("MenuTranslationSystem unloaded (skeleton)");
		}
	}
}



===== FILE: D:\TranslateTest2\Systems\UITranslationSystem.cs =====
using Terraria.ModLoader;

namespace TranslateTest2.Systems
{
	/// <summary>
	/// UI 文字列 (Hover/Tooltip/特定メニュー) 翻訳の骨格。
	/// 実装予定: UI 再描画タイミングでの文字列取得・部分辞書置換・DeepL 非同期要求。
	/// </summary>
	public class UITranslationSystem : ModSystem
	{
		public override void OnModLoad()
		{
			TranslateTest2.Instance?.Logger?.Debug("UITranslationSystem loaded (skeleton)");
		}

		public override void OnModUnload()
		{
			TranslateTest2.Instance?.Logger?.Debug("UITranslationSystem unloaded (skeleton)");
		}
	}
}



===== FILE: D:\TranslateTest2\Systems\UniversalTextTranslateSystem.cs =====
using Terraria.ModLoader;

namespace TranslateTest2.Systems
{
	/// <summary>
	/// 今後、ゲーム内で発生する様々な動的文字列 (NPC会話 / ステータス / UI) に対する統合的翻訳エントリポイントを提供する予定の骨格。
	/// 現状は初期化ログのみ。必要なイベントが判明次第、適切な Hook / コールバックを追加する。
	/// </summary>
	public class UniversalTextTranslateSystem : ModSystem
	{
		public override void OnModLoad()
		{
			TranslateTest2.Instance?.Logger?.Debug("UniversalTextTranslateSystem loaded (skeleton)");
		}

		public override void OnModUnload()
		{
			TranslateTest2.Instance?.Logger?.Debug("UniversalTextTranslateSystem unloaded (skeleton)");
		}
	}
}



===== FILE: D:\TranslateTest2\UI\HoverTextTranslateModSystem.cs =====
using Terraria.ModLoader;

namespace TranslateTest2.UI
{
    /// <summary>
    /// ホバー時のテキスト（看板、チェスト名、NPC名等）を翻訳するModSystemです。
    /// 左Shiftキー押下時にMain.hoverItemNameを翻訳対象として処理します。
    /// </summary>
    // 原点回帰のため、ホバー翻訳は無効化（必要になれば復活させます）
    public class HoverTextTranslateModSystem : ModSystem { }
}

